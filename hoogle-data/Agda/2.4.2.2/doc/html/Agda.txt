-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A dependently typed functional programming language and proof assistant
--   
@package Agda
@version 2.4.2.2


-- | A strict version of the <a>Maybe</a> type.
--   
--   Import qualified, as in <tt> import qualified Agda.Utils.Maybe.Strict
--   as Strict </tt>
--   
--   Copyright : (c) 2006-2007 Roman Leshchinskiy (c) 2013 Simon Meier
--   License : BSD-style (see the file LICENSE)
--   
--   Copyright : (c) 2014 Andreas Abel
module Agda.Utils.Maybe.Strict
toStrict :: Maybe a -> Maybe a
toLazy :: Maybe a -> Maybe a

-- | Analogous to <a>listToMaybe</a> in <a>Data.Maybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Analogous to <a>maybeToList</a> in <a>Data.Maybe</a>.
maybeToList :: Maybe a -> [a]

-- | Analogous to <a>catMaybes</a> in <a>Data.Maybe</a>.
catMaybes :: [Maybe a] -> [a]

-- | Analogous to <a>mapMaybe</a> in <a>Data.Maybe</a>.
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | <tt>unionWith</tt> for collections of size &lt;= 1.
unionMaybeWith :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a

-- | Unzipping a list of length &lt;= 1.
unzipMaybe :: Maybe (a, b) -> (Maybe a, Maybe b)

-- | Filtering a singleton list.
--   
--   <pre>
--   filterMaybe p a = <a>listToMaybe</a> (<a>filter</a> p [a])
--   </pre>
filterMaybe :: (a -> Bool) -> a -> Maybe a

-- | Version of <a>mapMaybe</a> with different argument ordering.
forMaybe :: [a] -> (a -> Maybe b) -> [b]

-- | Version of <a>maybe</a> with different argument ordering. Often, we
--   want to case on a <a>Maybe</a>, do something interesting in the
--   <a>Just</a> case, but only a default action in the <a>Nothing</a>
--   case. Then, the argument ordering of <tt>caseMaybe</tt> is preferable.
--   
--   <pre>
--   caseMaybe m err f = flip (maybe err) m f
--   </pre>
caseMaybe :: Maybe a -> b -> (a -> b) -> b

-- | Monadic version of <a>maybe</a>.
maybeM :: Monad m => m b -> (a -> m b) -> m (Maybe a) -> m b

-- | Monadic version of <a>fromMaybe</a>.
fromMaybeM :: Monad m => m a -> m (Maybe a) -> m a

-- | Monadic version of <a>caseMaybe</a>. That is, <a>maybeM</a> with a
--   different argument ordering.
caseMaybeM :: Monad m => m (Maybe a) -> m b -> (a -> m b) -> m b

-- | <a>caseMaybeM</a> with flipped branches.
ifJustM :: Monad m => m (Maybe a) -> (a -> m b) -> m b -> m b

-- | A more telling name for <a>forM</a> for the <a>Maybe</a> collection
--   type. Or: <a>caseMaybe</a> without the <a>Nothing</a> case.
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | <a>caseMaybeM</a> without the <a>Nothing</a> case.
whenJustM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()
instance Generic (Maybe a)
instance Typeable Maybe
instance Data a => Data (Maybe a)
instance Datatype D1Maybe
instance Constructor C1_0Maybe
instance Constructor C1_1Maybe
instance Arbitrary a => Arbitrary (Maybe a)
instance Binary a => Binary (Maybe a)
instance NFData a => NFData (Maybe a)
instance Traversable Maybe
instance Foldable Maybe
instance Monoid a => Monoid (Maybe a)


-- | Provides <tt>Data.IORef.modifyIORef'</tt> for <tt>base &lt; 4.6</tt>.
module Agda.Utils.IORef

-- | Read <a>IORef</a>, modify it strictly, and return old value.
readModifyIORef' :: IORef a -> (a -> a) -> IO a

module Agda.Utils.SemiRing
class SemiRing a
oplus :: SemiRing a => a -> a -> a
otimes :: SemiRing a => a -> a -> a
instance SemiRing a => SemiRing (Maybe a)

module Agda.TypeChecking.Monad.Debug
debug :: MonadIO m => String -> m ()


-- | Create clusters of non-overlapping things.
module Agda.Utils.Cluster

-- | Given a function <tt>f :: a -&gt; (C,[C])</tt> which returns a
--   non-empty list of characteristics <tt>C</tt> of <tt>a</tt>, partition
--   a list of <tt>a</tt>s into groups such that each element in a group
--   shares at least one characteristic with at least one other element of
--   the group.
cluster :: (a -> (C, [C])) -> [a] -> [[a]]

-- | Partition a list of <tt>a</tt>s paired with a non-empty list of
--   characteristics $C$ into groups such that each element in a group
--   shares at least one characteristic with at least one other element of
--   the group.
cluster' :: [(a, (C, [C]))] -> [[a]]
tests :: IO Bool


-- | Finite bijections (implemented as a pair of maps).
module Agda.Utils.BiMap

-- | Finite bijective map from <tt>a</tt> to <tt>b</tt>. There, and back
--   again.
data BiMap a b
BiMap :: Map a b -> Map b a -> BiMap a b
biMapThere :: BiMap a b -> Map a b
biMapBack :: BiMap a b -> Map b a

-- | Lookup. O(log n).
lookup :: (Ord a, Ord b) => a -> BiMap a b -> Maybe b

-- | Inverse lookup. O(log n).
invLookup :: (Ord a, Ord b) => b -> BiMap a b -> Maybe a

-- | Empty bimap. O(1).
empty :: (Ord a, Ord b) => BiMap a b

-- | Singleton bimap. O(1).
singleton :: (Ord a, Ord b) => a -> b -> BiMap a b

-- | Insert. Overwrites existing value if present.
insert :: (Ord a, Ord b) => a -> b -> BiMap a b -> BiMap a b

-- | Left-biased Union. O(Map.union).
union :: (Ord a, Ord b) => BiMap a b -> BiMap a b -> BiMap a b

-- | Construct from a list of pairs.
--   
--   Does not check for actual bijectivity of constructed finite map.
fromList :: (Ord a, Ord b) => [(a, b)] -> BiMap a b

-- | Turn into list, sorted ascendingly by first value.
toList :: (Ord a, Ord b) => BiMap a b -> [(a, b)]
prop_BiMap_invariant :: (Ord a, Ord b) => BiMap a b -> Bool
tests :: IO Bool
instance Typeable BiMap
instance (Ord a, Ord b, Arbitrary a, Arbitrary b) => Arbitrary (BiMap a b)
instance (Show a, Show b, Ord a, Ord b) => Show (BiMap a b)
instance (Ord a, Ord b) => Ord (BiMap a b)
instance (Ord a, Ord b) => Eq (BiMap a b)

module Agda.Utils.Pointed

-- | Pointed class.
--   
--   We could have used Data.Pointed by Edward Kmett, but it has a lot of
--   package dependencies.
class Pointed f
point :: Pointed f => a -> f a
instance Pointed Set
instance Pointed Maybe
instance Pointed []


-- | Var field implementation of sets of (small) natural numbers.
module Agda.Utils.VarSet
type VarSet = IntSet

-- | <i>O(n+m)</i>. The union of two sets.
union :: IntSet -> IntSet -> IntSet

-- | The union of a list of sets.
unions :: [IntSet] -> IntSet

-- | <i>O(min(n,W))</i>. Is the value a member of the set?
member :: Key -> IntSet -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: IntSet

-- | <i>O(min(n,W))</i>. Delete a value in the set. Returns the original
--   set when the value was not present.
delete :: Key -> IntSet -> IntSet

-- | <i>O(1)</i>. A set of one element.
singleton :: Key -> IntSet

-- | <i>O(n*min(n,W))</i>. Create a set from a list of integers.
fromList :: [Key] -> IntSet

-- | <i>O(n)</i>. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: IntSet -> [Key]

-- | <i>O(n)</i>. Convert the set to a descending list of elements. Subject
--   to list fusion.
toDescList :: IntSet -> [Key]

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: IntSet -> IntSet -> Bool

-- | <i>O(1)</i>. Is the set empty?
null :: IntSet -> Bool

-- | <i>O(n+m)</i>. The intersection of two sets.
intersection :: IntSet -> IntSet -> IntSet

-- | <i>O(n+m)</i>. Difference between two sets.
difference :: IntSet -> IntSet -> IntSet
subtract :: Int -> VarSet -> VarSet

module Agda.Utils.Char

-- | Convert a character in <tt>'0'..'9'</tt> into the corresponding digit
--   <tt>0..9</tt>.
decDigit :: Char -> Int

-- | Convert a character in <tt>'0'..'9','A'..'F','a'..'f'</tt> into the
--   corresponding digit <tt>0..15</tt>.
hexDigit :: Char -> Int

-- | Convert a character in <tt>'0'..'7'</tt> into the corresponding digit
--   <tt>0..7</tt>.
octDigit :: Char -> Int

-- | Unicode characters are divided into letters, numbers, marks,
--   punctuation, symbols, separators (including spaces) and others
--   (including control characters).
--   
--   These are the tests that <a>Char</a> offers
data UnicodeTest
IsControl :: UnicodeTest
IsSpace :: UnicodeTest
IsLower :: UnicodeTest
IsUpper :: UnicodeTest
IsAlpha :: UnicodeTest
IsAlphaNum :: UnicodeTest
IsPrint :: UnicodeTest
IsDigit :: UnicodeTest
IsOctDigit :: UnicodeTest
IsHexDigit :: UnicodeTest
IsLetter :: UnicodeTest
IsMark :: UnicodeTest
IsNumber :: UnicodeTest
IsPunctuation :: UnicodeTest
IsSymbol :: UnicodeTest
IsSeparator :: UnicodeTest

-- | Test names paired with their implementation.
unicodeTests :: [(UnicodeTest, Char -> Bool)]

-- | Find out which tests a character satisfies.
testChar :: Char -> [UnicodeTest]
instance Eq UnicodeTest
instance Ord UnicodeTest
instance Show UnicodeTest

module Agda.Utils.Pointer
data Ptr a
newPtr :: a -> Ptr a
derefPtr :: Ptr a -> a
setPtr :: a -> Ptr a -> Ptr a
updatePtr :: (a -> a) -> Ptr a -> Ptr a

-- | If <tt>f a</tt> contains many copies of <tt>a</tt> they will all be
--   the same pointer in the result. If the function is well-behaved (i.e.
--   preserves the implicit equivalence, this shouldn't matter).
updatePtrM :: Functor f => (a -> f a) -> Ptr a -> f (Ptr a)
instance Typeable Ptr
instance NFData (Ptr a)
instance Hashable (Ptr a)
instance Ord (Ptr a)
instance Eq (Ptr a)
instance Traversable Ptr
instance Foldable Ptr
instance Functor Ptr
instance Show a => Show (Ptr a)


-- | Defines <a>CutOff</a> type which is used in <a>Options</a>. This
--   module's purpose is to eliminate the dependency of <a>Base</a> on the
--   termination checker and everything it imports.
module Agda.Termination.CutOff

-- | Cut off structural order comparison at some depth in termination
--   checker?
data CutOff

-- | <tt>c &gt;= 0</tt> means: record decrease up to including
--   <tt>c+1</tt>.
CutOff :: Int -> CutOff
DontCutOff :: CutOff
instance Eq CutOff
instance Ord CutOff
instance Show CutOff


-- | Binary IO.
module Agda.Utils.IO.Binary

-- | Returns a close function for the file together with the contents.
readBinaryFile' :: FilePath -> IO (ByteString, IO ())

module Agda.Utils.Tuple

-- | Bifunctoriality for pairs.
(-*-) :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)

-- | <pre>
--   mapFst f = f -*- id
--   </pre>
mapFst :: (a -> c) -> (a, b) -> (c, b)

-- | <pre>
--   mapSnd g = id -*- g
--   </pre>
mapSnd :: (b -> d) -> (a, b) -> (a, d)

-- | Lifted pairing.
(/\) :: (a -> b) -> (a -> c) -> a -> (b, c)

-- | Swap. (Only in Data.Tuple from base-4.3)
swap :: (a, b) -> (b, a)
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e

-- | Monadic version of <a>-*-</a>.
mapPairM :: Applicative m => (a -> m c) -> (b -> m d) -> (a, b) -> m (c, d)

-- | Monadic <a>mapFst</a>.
mapFstM :: Applicative m => (a -> m c) -> (a, b) -> m (c, b)

-- | Monadic <a>mapSnd</a>.
mapSndM :: Applicative m => (b -> m d) -> (a, b) -> m (a, d)
newtype List2 a
List2 :: (a, a) -> List2 a
list2 :: List2 a -> (a, a)
instance Eq a => Eq (List2 a)
instance Functor List2
instance Foldable List2
instance Traversable List2
instance Applicative List2

module Agda.Utils.Update

-- | The <tt>Change</tt> monad.
data Change a

-- | The class of change monads.
class Monad m => MonadChange m
tellDirty :: MonadChange m => m ()
listenDirty :: MonadChange m => m a -> m (a, Bool)

-- | Run a <a>Change</a> computation, returning result plus change flag.
runChange :: Change a -> (a, Bool)
type Updater a = a -> Change a

-- | Replace result of updating with original input if nothing has changed.
sharing :: Updater a -> Updater a

-- | Blindly run an updater.
runUpdater :: Updater a -> a -> (a, Bool)

-- | Mark a computation as dirty.
dirty :: Updater a
ifDirty :: MonadChange m => m a -> (a -> m b) -> (a -> m b) -> m b

-- | Like <a>Functor</a>, but preserving sharing.
class Traversable f => Updater1 f where updater1 = traverse updates1 f = sharing $ updater1 f update1 f = evalUpdater $ updater1 f
updater1 :: Updater1 f => Updater a -> Updater (f a)
updates1 :: Updater1 f => Updater a -> Updater (f a)
update1 :: Updater1 f => Updater a -> EndoFun (f a)

-- | Like <tt>Bifunctor</tt>, but preserving sharing.
class Updater2 f where updates2 f1 f2 = sharing $ updater2 f1 f2 update2 f1 f2 = evalUpdater $ updater2 f1 f2
updater2 :: Updater2 f => Updater a -> Updater b -> Updater (f a b)
updates2 :: Updater2 f => Updater a -> Updater b -> Updater (f a b)
update2 :: Updater2 f => Updater a -> Updater b -> EndoFun (f a b)
instance Functor m => Functor (ChangeT m)
instance Applicative m => Applicative (ChangeT m)
instance Monad m => Monad (ChangeT m)
instance MonadTrans ChangeT
instance Functor Change
instance Applicative Change
instance Monad Change
instance Updater2 Either
instance Updater2 (,)
instance Updater1 []
instance Updater1 Maybe
instance MonadChange Change
instance MonadChange Identity
instance Monad m => MonadChange (ChangeT m)


-- | Some functions and generators suitable for writing QuickCheck
--   properties.
module Agda.Utils.TestHelpers

-- | Is the operator associative?
associative :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> a -> a -> a -> Bool

-- | Is the operator commutative?
commutative :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> a -> a -> Bool

-- | Is the operator idempotent?
idempotent :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> a -> Bool

-- | Is the element a zero for the operator?
isZero :: (Arbitrary a, Eq a, Show a) => a -> (a -> a -> a) -> a -> Bool

-- | Is the element a unit for the operator?
identity :: (Arbitrary a, Eq a, Show a) => a -> (a -> a -> a) -> a -> Bool

-- | Does the first operator distribute (from the left) over the second
--   one?
leftDistributive :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> (a -> a -> a) -> a -> a -> a -> Bool

-- | Does the first operator distribute (from the right) over the second
--   one?
rightDistributive :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> (a -> a -> a) -> a -> a -> a -> Bool

-- | Does the first operator distribute over the second one?
distributive :: (Arbitrary a, Eq a, Show a) => (a -> a -> a) -> (a -> a -> a) -> a -> a -> a -> Bool

-- | Generates natural numbers.
natural :: Integral i => Gen i

-- | Generates positive numbers.
positive :: Integral i => Gen i

-- | Generates values of <a>Maybe</a> type, using the given generator to
--   generate the contents of the <a>Just</a> constructor.
maybeGen :: Gen a -> Gen (Maybe a)

-- | <tt>Coarbitrary</tt> "generator" for <a>Maybe</a>.
maybeCoGen :: (a -> Gen b -> Gen b) -> (Maybe a -> Gen b -> Gen b)

-- | Generates a list of elements picked from a given list.
listOfElements :: [a] -> Gen [a]

-- | If the given list is non-empty, then an element from the list is
--   generated, and otherwise an arbitrary element is generated.
elementsUnlessEmpty :: Arbitrary a => [a] -> Gen a

-- | Generates two elements.
two :: Gen a -> Gen (a, a)

-- | Generates three elements.
three :: Gen a -> Gen (a, a, a)

-- | Runs the tests, and returns <a>True</a> if all tests were successful.
runTests :: String -> [IO Bool] -> IO Bool

module Agda.Utils.QuickCheck
isSuccess :: Result -> Bool
quickCheck' :: Testable prop => prop -> IO Bool
quickCheckWith' :: Testable prop => Args -> prop -> IO Bool


-- | Utilities for the <a>Either</a> type
module Agda.Utils.Either

-- | Loop while we have an exception.
whileLeft :: Monad m => (a -> Either b c) -> (a -> b -> m a) -> (a -> c -> m d) -> a -> m d

-- | Monadic version of <a>either</a> with a different argument ordering.
caseEitherM :: Monad m => m (Either a b) -> (a -> m c) -> (b -> m c) -> m c

-- | <a>Either</a> is a bifunctor.
mapEither :: (a -> c) -> (b -> d) -> Either a b -> Either c d

-- | 'Either _ b' is a functor.
mapLeft :: (a -> c) -> Either a b -> Either c b

-- | 'Either a' is a functor.
mapRight :: (b -> d) -> Either a b -> Either a d

-- | Returns <a>True</a> iff the argument is <tt><a>Left</a> x</tt> for
--   some <tt>x</tt>. Note: from <tt>base &gt;= 4.7.0.0</tt> already
--   present in <tt>Data.Either</tt>.
isLeft :: Either a b -> Bool

-- | Returns <a>True</a> iff the argument is <tt><a>Right</a> x</tt> for
--   some <tt>x</tt>. Note: from <tt>base &gt;= 4.7.0.0</tt> already
--   present in <tt>Data.Either</tt>.
isRight :: Either a b -> Bool

-- | Analogue of <a>fromMaybe</a>.
fromLeft :: (b -> a) -> Either a b -> a

-- | Analogue of <a>fromMaybe</a>.
fromRight :: (a -> b) -> Either a b -> b

-- | Returns <tt><a>Just</a> <a>with tags stripped</a></tt> if all elements
--   are to the right, and otherwise <a>Nothing</a>.
--   
--   <pre>
--   allRight xs ==
--     if all isRight xs then
--       Just (map ((Right x) -&gt; x) xs)
--      else
--       Nothing
--   </pre>
allRight :: [Either a b] -> Maybe [b]
tests :: IO Bool


-- | Semirings.
module Agda.Termination.Semiring

-- | <tt>HasZero</tt> is needed for sparse matrices, to tell which is the
--   element that does not have to be stored. It is a cut-down version of
--   <tt>SemiRing</tt> which is definable without the implicit
--   <tt>?cutoff</tt>.
class Eq a => HasZero a
zeroElement :: HasZero a => a

-- | SemiRing type class. Additive monoid with multiplication operation.
--   Inherit addition and zero from Monoid.
class (Eq a, Monoid a) => SemiRing a
multiply :: SemiRing a => a -> a -> a

-- | Semirings.
data Semiring a
Semiring :: (a -> a -> a) -> (a -> a -> a) -> a -> Semiring a

-- | Addition.
add :: Semiring a -> a -> a -> a

-- | Multiplication.
mul :: Semiring a -> a -> a -> a

-- | Zero. The one is never used in matrix multiplication , one :: a -- ^
--   One.
zero :: Semiring a -> a

-- | Semiring invariant.
semiringInvariant :: (Arbitrary a, Eq a, Show a) => Semiring a -> a -> a -> a -> Bool
integerSemiring :: Semiring Integer
intSemiring :: Semiring Int

-- | The standard semiring on <a>Bool</a>s.
boolSemiring :: Semiring Bool
tests :: IO Bool
instance SemiRing Int
instance Monoid Int
instance HasZero Int
instance SemiRing Integer
instance Monoid Integer
instance HasZero Integer

module Agda.Utils.PartialOrd

-- | The result of comparing two things (of the same type).
data PartialOrdering

-- | Less than.
POLT :: PartialOrdering

-- | Less or equal than.
POLE :: PartialOrdering

-- | Equal
POEQ :: PartialOrdering

-- | Greater or equal.
POGE :: PartialOrdering

-- | Greater than.
POGT :: PartialOrdering

-- | No information (incomparable).
POAny :: PartialOrdering

-- | Comparing the information content of two elements of
--   <a>PartialOrdering</a>. More precise information is smaller.
--   
--   Includes equality: <tt>x <a>leqPO</a> x == True</tt>.
leqPO :: PartialOrdering -> PartialOrdering -> Bool

-- | Opposites.
--   
--   <tt>related a po b</tt> iff <tt>related b (oppPO po) a</tt>.
oppPO :: PartialOrdering -> PartialOrdering

-- | Combining two pieces of information (picking the least information).
--   Used for the dominance ordering on tuples.
--   
--   <tt>orPO</tt> is associative, commutative, and idempotent.
--   <tt>orPO</tt> has dominant element <tt>POAny</tt>, but no neutral
--   element.
orPO :: PartialOrdering -> PartialOrdering -> PartialOrdering

-- | Chains (transitivity) <tt>x R y S z</tt>.
--   
--   <tt>seqPO</tt> is associative, commutative, and idempotent.
--   <tt>seqPO</tt> has dominant element <tt>POAny</tt> and neutral element
--   (unit) <tt>POEQ</tt>.
seqPO :: PartialOrdering -> PartialOrdering -> PartialOrdering

-- | Partial ordering forms a monoid under sequencing.

-- | Partial ordering forms a semiring under supremum (disjunction) and
--   composition (transitivity, sequencing)

-- | Embed <a>Ordering</a>.
fromOrdering :: Ordering -> PartialOrdering

-- | Represent a non-empty disjunction of <a>Ordering</a>s as
--   <a>PartialOrdering</a>.
fromOrderings :: [Ordering] -> PartialOrdering

-- | A <a>PartialOrdering</a> information is a disjunction of
--   <a>Ordering</a> informations.
toOrderings :: PartialOrdering -> [Ordering]
type Comparable a = a -> a -> PartialOrdering

-- | Decidable partial orderings.
class PartialOrd a
comparable :: PartialOrd a => Comparable a

-- | Any <a>Ord</a> is a <a>PartialOrd</a>.
comparableOrd :: Ord a => Comparable a

-- | Are two elements related in a specific way?
--   
--   <tt>related a o b</tt> holds iff <tt>comparable a b</tt> is contained
--   in <tt>o</tt>.
related :: PartialOrd a => a -> PartialOrdering -> a -> Bool

-- | <a>Nothing</a> and <tt><a>Just</a> _</tt> are unrelated.
--   
--   Partial ordering for <tt>Maybe a</tt> is the same as for <tt>Either ()
--   a</tt>.

-- | Partial ordering for disjoint sums: <tt>Left _</tt> and <tt>Right
--   _</tt> are unrelated.

-- | Pointwise partial ordering for tuples.
--   
--   <tt>related (x1,x2) o (y1,y2)</tt> iff <tt>related x1 o x2</tt> and
--   <tt>related y1 o y2</tt>.

-- | Pointwise comparison wrapper.
newtype Pointwise a
Pointwise :: a -> Pointwise a
pointwise :: Pointwise a -> a

-- | The pointwise ordering for lists of the same length.
--   
--   There are other partial orderings for lists, e.g., prefix, sublist,
--   subset, lexicographic, simultaneous order.

-- | Inclusion comparison wrapper.
newtype Inclusion a
Inclusion :: a -> Inclusion a
inclusion :: Inclusion a -> a

-- | Sublist for ordered lists.

-- | Sets are partially ordered by inclusion.

-- | Less is ``less general'' (i.e., more precise).

-- | We test our properties on integer sets ordered by inclusion.
newtype ISet
ISet :: Inclusion (Set Int) -> ISet
iset :: ISet -> Inclusion (Set Int)

-- | Any two elements are <a>related</a> in the way <a>comparable</a>
--   computes.
prop_comparable_related :: ISet -> ISet -> Bool

-- | <pre>
--   flip comparable a b == oppPO (comparable a b)
--   </pre>
prop_oppPO :: ISet -> ISet -> Bool

-- | Auxiliary function: lists to sets = sorted duplicate-free lists.
sortUniq :: [Ordering] -> [Ordering]

-- | <a>leqPO</a> is inclusion of the associated <a>Ordering</a> sets.
prop_leqPO_sound :: PartialOrdering -> PartialOrdering -> Bool

-- | <a>orPO</a> amounts to the union of the associated <a>Ordering</a>
--   sets. Except that 'orPO POLT POGT == POAny' which should also include
--   <a>POEQ</a>.
prop_orPO_sound :: PartialOrdering -> PartialOrdering -> Bool

-- | <a>orPO</a> is associative.
prop_associative_orPO :: PartialOrdering -> PartialOrdering -> PartialOrdering -> Bool

-- | <a>orPO</a> is commutative.
prop_commutative_orPO :: PartialOrdering -> PartialOrdering -> Bool

-- | <a>orPO</a> is idempotent.
prop_idempotent_orPO :: PartialOrdering -> Bool

-- | The dominant element wrt. <a>orPO</a> is <a>POAny</a>.
prop_zero_orPO :: PartialOrdering -> Bool

-- | Soundness of <a>seqPO</a>.
--   
--   As QuickCheck test, this property is inefficient, see
--   <a>prop_seqPO</a>.
property_seqPO :: ISet -> PartialOrdering -> ISet -> PartialOrdering -> ISet -> Property

-- | A more efficient way of stating soundness of <a>seqPO</a>.
prop_seqPO :: ISet -> ISet -> ISet -> Bool

-- | The unit of <a>seqPO</a> is <a>POEQ</a>.
prop_identity_seqPO :: PartialOrdering -> Bool

-- | The zero of <a>seqPO</a> is <a>POAny</a>.
prop_zero_seqPO :: PartialOrdering -> Bool

-- | <a>seqPO</a> is associative.
prop_associative_seqPO :: PartialOrdering -> PartialOrdering -> PartialOrdering -> Bool

-- | <a>seqPO</a> is also commutative.
prop_commutative_seqPO :: PartialOrdering -> PartialOrdering -> Bool

-- | <a>seqPO</a> is idempotent.
prop_idempotent_seqPO :: PartialOrdering -> Bool

-- | <a>seqPO</a> distributes over <a>orPO</a>.
prop_distributive_seqPO_orPO :: PartialOrdering -> PartialOrdering -> PartialOrdering -> Bool

-- | The result of <a>toOrderings</a> is a sorted list without duplicates.
prop_sorted_toOrderings :: PartialOrdering -> Bool

-- | From <a>Ordering</a> to <a>PartialOrdering</a> and back is the
--   identity.
prop_toOrderings_after_fromOrdering :: Ordering -> Bool

-- | From <a>PartialOrdering</a> to <tt>Orderings</tt> and back is the
--   identity.
prop_fromOrderings_after_toOrderings :: PartialOrdering -> Bool

-- | From <tt>Orderings</tt> to <a>PartialOrdering</a> and back is the
--   identity. Except for <tt>[LT,GT]</tt> which is a non-canonical
--   representative of <a>POAny</a>.
prop_toOrderings_after_fromOrderings :: NonEmptyList Ordering -> Bool

-- | Pairs are related iff both components are related.
prop_related_pair :: ISet -> ISet -> ISet -> ISet -> PartialOrdering -> Bool

-- | Comparing <a>PartialOrdering</a>s amounts to compare their
--   representation as <a>Ordering</a> sets.
prop_comparable_PartialOrdering :: PartialOrdering -> PartialOrdering -> Bool

-- | All tests as collected by <a>quickCheckAll</a>.
--   
--   Using <a>quickCheckAll</a> is convenient and superior to the manual
--   enumeration of tests, since the name of the property is added
--   automatically.
tests :: IO Bool
instance Eq PartialOrdering
instance Show PartialOrdering
instance Enum PartialOrdering
instance Bounded PartialOrdering
instance Eq a => Eq (Pointwise a)
instance Show a => Show (Pointwise a)
instance Functor Pointwise
instance Eq a => Eq (Inclusion a)
instance Ord a => Ord (Inclusion a)
instance Show a => Show (Inclusion a)
instance Functor Inclusion
instance Eq ISet
instance Ord ISet
instance PartialOrd ISet
instance Show ISet
instance Arbitrary ISet
instance Arbitrary PartialOrdering
instance PartialOrd PartialOrdering
instance Ord a => PartialOrd (Inclusion (Set a))
instance Ord a => PartialOrd (Inclusion [a])
instance PartialOrd a => PartialOrd (Pointwise [a])
instance (PartialOrd a, PartialOrd b) => PartialOrd (a, b)
instance (PartialOrd a, PartialOrd b) => PartialOrd (Either a b)
instance PartialOrd a => PartialOrd (Maybe a)
instance PartialOrd ()
instance PartialOrd Integer
instance PartialOrd Int
instance SemiRing PartialOrdering
instance Monoid PartialOrdering


module Agda.Utils.ReadP
data ReadP t a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadP t t

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadP t [t]

-- | Symmetric choice.
(+++) :: ReadP t a -> ReadP t a -> ReadP t a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadP t a -> ReadP t a -> ReadP t a

-- | Transforms a parser into one that does the same, but in addition
--   returns the exact characters read. IMPORTANT NOTE: <a>gather</a> gives
--   a runtime error if its first argument is built using any occurrences
--   of readS_to_P.
gather :: ReadP t a -> ReadP t ([t], a)

-- | Run a parser on a list of tokens. Returns the list of complete
--   matches.
parse :: ReadP t a -> [t] -> [a]
parse' :: ReadP t a -> [t] -> Either a [t]

-- | Always fails.
pfail :: ReadP t a

-- | Consumes and returns the next character, if it satisfies the specified
--   predicate.
satisfy :: (t -> Bool) -> ReadP t t

-- | Parses and returns the specified character.
char :: Eq t => t -> ReadP t t

-- | Parses and returns the specified string.
string :: Eq t => [t] -> ReadP t [t]

-- | Parses the first zero or more characters satisfying the predicate.
munch :: (t -> Bool) -> ReadP t [t]

-- | Parses the first one or more characters satisfying the predicate.
munch1 :: (t -> Bool) -> ReadP t [t]

-- | Skips all whitespace.
skipSpaces :: ReadP Char ()

-- | Combines all parsers in the specified list.
choice :: [ReadP t a] -> ReadP t a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence. A list of results is returned.
count :: Int -> ReadP t a -> ReadP t [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: ReadP t open -> ReadP t close -> ReadP t a -> ReadP t a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: a -> ReadP t a -> ReadP t a

-- | <tt>optional p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optional :: ReadP t a -> ReadP t ()

-- | Parses zero or more occurrences of the given parser.
many :: ReadP t a -> ReadP t [a]

-- | Parses one or more occurrences of the given parser.
many1 :: ReadP t a -> ReadP t [a]

-- | Like <a>many</a>, but discards the result.
skipMany :: ReadP t a -> ReadP t ()

-- | Like <a>many1</a>, but discards the result.
skipMany1 :: ReadP t a -> ReadP t ()

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: ReadP t a -> ReadP t sep -> ReadP t [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: ReadP t a -> ReadP t sep -> ReadP t [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: ReadP t a -> ReadP t sep -> ReadP t [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: ReadP t a -> ReadP t sep -> ReadP t [a]

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: ReadP t a -> ReadP t (a -> a -> a) -> a -> ReadP t a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: ReadP t a -> ReadP t (a -> a -> a) -> a -> ReadP t a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: ReadP t a -> ReadP t (a -> a -> a) -> ReadP t a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: ReadP t a -> ReadP t (a -> a -> a) -> ReadP t a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: ReadP t a -> ReadP t end -> ReadP t [a]
instance Functor (P t)
instance MonadPlus (ReadP t)
instance Alternative (ReadP t)
instance Monad (ReadP t)
instance Applicative (ReadP t)
instance Functor (ReadP t)
instance MonadPlus (P t)
instance Alternative (P t)
instance Monad (P t)
instance Applicative (P t)


-- | Text IO using the UTF8 character encoding.
module Agda.Utils.IO.UTF8

-- | Reads a UTF8-encoded text file and converts all Unicode line endings
--   into '\n'.
readTextFile :: FilePath -> IO String

-- | Writes UTF8-encoded text to the handle, which should be opened for
--   writing and in text mode. The native convention for line endings is
--   used.
--   
--   The handle's text encoding is not necessarily preserved, it is changed
--   to UTF8.
hPutStr :: Handle -> String -> IO ()

-- | Writes a UTF8-encoded text file. The native convention for line
--   endings is used.
writeFile :: FilePath -> String -> IO ()

module Agda.Utils.Function

-- | Repeat something while a condition on some state is true. Return the
--   last state (including the changes of the last transition, even if the
--   condition became false then).
repeatWhile :: (a -> (Bool, a)) -> a -> a

-- | Monadic version of <a>repeatWhile</a>.
repeatWhileM :: Monad m => (a -> m (Bool, a)) -> a -> m a

-- | A version of the trampoline function.
--   
--   The usual function iterates <tt>f :: a -&gt; Maybe a</tt> as long as
--   <tt>Just{}</tt> is returned, and returns the last value of <tt>a</tt>
--   upon <tt>Nothing</tt>.
--   
--   <tt>usualTrampoline f = trampolineWhile $ a -&gt; maybe (False,a)
--   (True,) (f a)</tt>.
--   
--   <tt>trampolineWhile</tt> is very similar to <tt>repeatWhile</tt>, only
--   that it discards the state on which the condition went <tt>False</tt>,
--   and returns the last state on which the condition was <tt>True</tt>.
trampolineWhile :: (a -> (Bool, a)) -> a -> a

-- | Monadic version of <a>trampolineWhile</a>.
trampolineWhileM :: Monad m => (a -> m (Bool, a)) -> a -> m a

-- | More general trampoline, which allows some final computation from
--   iteration state <tt>a</tt> into result type <tt>b</tt>.
trampoline :: (a -> Either b a) -> a -> b

-- | Monadic version of <a>trampoline</a>.
trampolineM :: Monad m => (a -> m (Either b a)) -> a -> m b

-- | Iteration to fixed-point.
--   
--   <tt>iterateUntil r f a0</tt> iterates endofunction <tt>f</tt>,
--   starting with <tt>a0</tt>, until <tt>r</tt> relates its result to its
--   input, i.e., <tt>f a <tt>r</tt> a</tt>.
--   
--   This is the generic pattern behind saturation algorithms.
--   
--   If <tt>f</tt> is monotone with regard to <tt>r</tt>, meaning <tt>a
--   <tt>r</tt> b</tt> implies <tt>f a <tt>r</tt> f b</tt>, and
--   <tt>f</tt>-chains starting with <tt>a0</tt> are finite then iteration
--   is guaranteed to terminate.
--   
--   A typical instance will work on sets, and <tt>r</tt> could be set
--   inclusion, and <tt>a0</tt> the empty set, and <tt>f</tt> the step
--   function of a saturation algorithm.
iterateUntil :: (a -> a -> Bool) -> (a -> a) -> a -> a

-- | Monadic version of <a>iterateUntil</a>.
iterateUntilM :: Monad m => (a -> a -> Bool) -> (a -> m a) -> a -> m a

-- | <tt><a>iterate'</a> n f x</tt> applies <tt>f</tt> to <tt>x</tt>
--   <tt>n</tt> times and returns the result.
--   
--   The applications are calculated strictly.
iterate' :: Integral i => i -> (a -> a) -> a -> a

-- | <tt>applyWhen b f a</tt> applies <tt>f</tt> to <tt>a</tt> when
--   <tt>b</tt>.
applyWhen :: Bool -> (a -> a) -> a -> a

-- | <tt>applyUnless b f a</tt> applies <tt>f</tt> to <tt>a</tt> unless
--   <tt>b</tt>.
applyUnless :: Bool -> (a -> a) -> a -> a

-- | Monadic version of <tt>applyWhen</tt>
applyWhenM :: Monad m => m Bool -> (m a -> m a) -> m a -> m a

-- | Monadic version of <tt>applyUnless</tt>
applyUnlessM :: Monad m => m Bool -> (m a -> m a) -> m a -> m a

module Agda.TypeChecking.SizedTypes.Utils
debug :: Bool
trace :: String -> a -> a
traceM :: Applicative f => String -> f ()
class Eq a => Top a where isTop = (== top)
top :: Top a => a
isTop :: Top a => a -> Bool
class Plus a b c
plus :: Plus a b c => a -> b -> c
class MeetSemiLattice a
meet :: MeetSemiLattice a => a -> a -> a

-- | Semiring with idempotent <a>+</a> == dioid
class (MeetSemiLattice a, Top a) => Dioid a
compose :: Dioid a => a -> a -> a
unitCompose :: Dioid a => a


-- | Syntax of size expressions and constraints.
module Agda.TypeChecking.SizedTypes.Syntax

-- | Constant finite sizes <tt>n &gt;= 0</tt>.
type Offset = Int

-- | Fixed size variables <tt>i</tt>.
newtype Rigid
RigidId :: String -> Rigid
rigidId :: Rigid -> String

-- | Size meta variables <tt>X</tt> to solve for.
newtype Flex
FlexId :: String -> Flex
flexId :: Flex -> String

-- | Size expressions appearing in constraints.
data SizeExpr' rigid flex

-- | Constant number <tt>n</tt>.
Const :: Offset -> SizeExpr' rigid flex
offset :: SizeExpr' rigid flex -> Offset

-- | Variable plus offset <tt>i + n</tt>.
Rigid :: rigid -> Offset -> SizeExpr' rigid flex
rigid :: SizeExpr' rigid flex -> rigid
offset :: SizeExpr' rigid flex -> Offset

-- | Infinity <tt>∞</tt>.
Infty :: SizeExpr' rigid flex

-- | Meta variable <tt>X + n</tt>.
Flex :: flex -> Offset -> SizeExpr' rigid flex
flex :: SizeExpr' rigid flex -> flex
offset :: SizeExpr' rigid flex -> Offset
type SizeExpr = SizeExpr' Rigid Flex

-- | Comparison operator, e.g. for size expression.
data Cmp

-- | <tt>&lt;</tt>.
Lt :: Cmp

-- | <tt>≤</tt>.
Le :: Cmp

-- | Comparison operator is ordered <tt><a>Lt</a> &lt; <a>Le</a></tt>.

-- | Constraint: an inequation between size expressions, e.g. <tt>X &lt;
--   ∞</tt> or <tt>i + 3 ≤ j</tt>.
data Constraint' rigid flex
Constraint :: SizeExpr' rigid flex -> Cmp -> SizeExpr' rigid flex -> Constraint' rigid flex
leftExpr :: Constraint' rigid flex -> SizeExpr' rigid flex
cmp :: Constraint' rigid flex -> Cmp
rightExpr :: Constraint' rigid flex -> SizeExpr' rigid flex
type Constraint = Constraint' Rigid Flex

-- | What type of solution are we looking for?
data Polarity
Least :: Polarity
Greatest :: Polarity

-- | Assigning a polarity to a flexible variable.
data PolarityAssignment flex
PolarityAssignment :: Polarity -> flex -> PolarityAssignment flex

-- | Type of solution wanted for each flexible.
type Polarities flex = Map flex Polarity
emptyPolarities :: Polarities flex
polaritiesFromAssignments :: Ord flex => [PolarityAssignment flex] -> Polarities flex

-- | Default polarity is <a>Least</a>.
getPolarity :: Ord flex => Polarities flex -> flex -> Polarity

-- | Partial substitution from flexible variables to size expression.
type Solution rigid flex = Map flex (SizeExpr' rigid flex)

-- | Executing a substitution.
class Substitute r f a
subst :: Substitute r f a => Solution r f -> a -> a

-- | Add offset to size expression.
type CTrans r f = Constraint' r f -> Maybe [Constraint' r f]

-- | Returns <a>Nothing</a> if we have a contradictory constraint.
simplify1 :: Eq r => CTrans r f -> CTrans r f

-- | <a>Le</a> acts as <a>True</a>, <a>Lt</a> as <a>False</a>.
ifLe :: Cmp -> a -> a -> a

-- | Interpret <a>Cmp</a> as relation on <a>Offset</a>.
compareOffset :: Offset -> Cmp -> Offset -> Bool

-- | Offsets <tt>+ n</tt> must be non-negative
class ValidOffset a
validOffset :: ValidOffset a => a -> Bool

-- | Make offsets non-negative by rounding up.
class TruncateOffset a
truncateOffset :: TruncateOffset a => a -> a

-- | The rigid variables contained in a pice of syntax.
class Rigids r a
rigids :: Rigids r a => a -> Set r

-- | The flexibe variables contained in a pice of syntax.
class Flexs flex a | a -> flex
flexs :: Flexs flex a => a -> Set flex
instance Eq Rigid
instance Ord Rigid
instance Eq Flex
instance Ord Flex
instance (Eq rigid, Eq flex) => Eq (SizeExpr' rigid flex)
instance (Ord rigid, Ord flex) => Ord (SizeExpr' rigid flex)
instance Functor (SizeExpr' rigid)
instance Foldable (SizeExpr' rigid)
instance Traversable (SizeExpr' rigid)
instance Eq Cmp
instance Bounded Cmp
instance Enum Cmp
instance Functor (Constraint' rigid)
instance Foldable (Constraint' rigid)
instance Traversable (Constraint' rigid)
instance Eq Polarity
instance Ord Polarity
instance Ord flex => Flexs flex (Constraint' rigid flex)
instance Ord flex => Flexs flex (SizeExpr' rigid flex)
instance (Ord flex, Flexs flex a) => Flexs flex [a]
instance Ord r => Rigids r (Constraint' r f)
instance Rigids r (SizeExpr' r f)
instance (Ord r, Rigids r a) => Rigids r [a]
instance TruncateOffset (SizeExpr' r f)
instance TruncateOffset Offset
instance ValidOffset (SizeExpr' r f)
instance ValidOffset Offset
instance (Show r, Show f) => Show (Constraint' r f)
instance Show Cmp
instance Show flex => Show (PolarityAssignment flex)
instance Show Polarity
instance (Show r, Show f) => Show (SizeExpr' r f)
instance Plus (SizeExpr' r f) Offset (SizeExpr' r f)
instance Substitute r f a => Substitute r f [a]
instance Ord f => Substitute r f (Constraint' r f)
instance Ord f => Substitute r f (SizeExpr' r f)
instance Top Cmp
instance MeetSemiLattice Cmp
instance Ord Cmp
instance Show Flex
instance Show Rigid

module Agda.Utils.HashMap


-- | Extend <a>Maybe</a> by common operations for the <a>Maybe</a> type.
--   
--   Note: since this module is usually imported unqualified, we do not use
--   short names, but all names contain <a>Maybe</a>, <a>Just</a>, or
--   'Nothing.
module Agda.Utils.Maybe

-- | <tt>unionWith</tt> for collections of size &lt;= 1.
unionMaybeWith :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a

-- | Unzipping a list of length &lt;= 1.
unzipMaybe :: Maybe (a, b) -> (Maybe a, Maybe b)

-- | Filtering a singleton list.
--   
--   <pre>
--   filterMaybe p a = <a>listToMaybe</a> (<a>filter</a> p [a])
--   </pre>
filterMaybe :: (a -> Bool) -> a -> Maybe a

-- | Version of <a>mapMaybe</a> with different argument ordering.
forMaybe :: [a] -> (a -> Maybe b) -> [b]

-- | Version of <a>maybe</a> with different argument ordering. Often, we
--   want to case on a <a>Maybe</a>, do something interesting in the
--   <a>Just</a> case, but only a default action in the <a>Nothing</a>
--   case. Then, the argument ordering of <tt>caseMaybe</tt> is preferable.
--   
--   <pre>
--   caseMaybe m err f = flip (maybe err) m f
--   </pre>
caseMaybe :: Maybe a -> b -> (a -> b) -> b

-- | Monadic version of <a>maybe</a>.
maybeM :: Monad m => m b -> (a -> m b) -> m (Maybe a) -> m b

-- | Monadic version of <a>fromMaybe</a>.
fromMaybeM :: Monad m => m a -> m (Maybe a) -> m a

-- | Monadic version of <a>caseMaybe</a>. That is, <a>maybeM</a> with a
--   different argument ordering.
caseMaybeM :: Monad m => m (Maybe a) -> m b -> (a -> m b) -> m b

-- | <a>caseMaybeM</a> with flipped branches.
ifJustM :: Monad m => m (Maybe a) -> (a -> m b) -> m b -> m b

-- | A more telling name for <a>forM_</a> for the <a>Maybe</a> collection
--   type. Or: <a>caseMaybe</a> without the <a>Nothing</a> case.
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | <a>caseMaybeM</a> without the <a>Nothing</a> case.
whenJustM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()


-- | Utilities for functors.
module Agda.Utils.Functor
($>) :: Functor f => f a -> b -> f b

-- | Composition: pure function after functorial (monadic) function.
(<.>) :: Functor m => (b -> c) -> (a -> m b) -> a -> m c

-- | The true pure <tt>for</tt> loop. <a>for</a> is a misnomer, it should
--   be <tt>forA</tt>.
for :: Functor m => m a -> (a -> b) -> m b

-- | Infix version of <a>for</a>.
(<&>) :: Functor m => m a -> (a -> b) -> m b

-- | A decoration is a functor that is traversable into any functor.
--   
--   The <a>Functor</a> superclass is given because of the limitations of
--   the Haskell class system. <tt>traverseF</tt> actually implies
--   functoriality.
--   
--   Minimal complete definition: <tt>traverseF</tt> or
--   <tt>distributeF</tt>.
class Functor t => Decoration t where traverseF f = distributeF . fmap f distributeF = traverseF id
traverseF :: (Decoration t, Functor m) => (a -> m b) -> t a -> m (t b)
distributeF :: (Decoration t, Functor m) => t (m a) -> m (t a)

-- | Any decoration is traversable with <tt>traverse = traverseF</tt>. Just
--   like any <tt>Traversable</tt> is a functor, so is any decoration,
--   given by just <tt>traverseF</tt>, a functor.
dmap :: Decoration t => (a -> b) -> t a -> t b

-- | Any decoration is a lens. <tt>set</tt> is a special case of
--   <tt>fmap</tt>.
dget :: Decoration t => t a -> a

-- | The identity functor is a decoration.

-- | Decorations compose. (Thus, they form a category.)

-- | A typical decoration is pairing with some stuff.

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
instance Decoration ((,) a)
instance (Decoration d, Decoration t) => Decoration (Compose d t)
instance Decoration Identity
instance Eq a => Eq (Identity a)


-- | Directed graphs (can of course simulate undirected graphs).
--   
--   Represented as adjacency maps.
--   
--   Each source node maps to a adjacency map, which is a map from target
--   nodes to edges.
--   
--   This allows to get the outgoing edges in O(log n) time where
--   <tt>n</tt> is the number of nodes in the graph. However, the set of
--   incoming edges can only be obtained in O(n log n), or O(e) where
--   <tt>e</tt> is the total number of edges.
module Agda.Utils.Graph.AdjacencyMap

-- | <tt>Graph n e</tt> is a directed graph with nodes in <tt>n</tt> and
--   edges in <tt>e</tt>.
--   
--   Only one edge between any two nodes.
--   
--   Represented as "adjacency list", or rather, adjacency map. This allows
--   to get all outgoing edges for a node in <tt>O(log n)</tt> time where
--   <tt>n</tt> is the number of nodes of the graph. Incoming edges can
--   only be computed in <tt>O(n + e)</tt> time where <tt>e</tt> is the
--   number of edges.
newtype Graph n e
Graph :: Map n (Map n e) -> Graph n e
unGraph :: Graph n e -> Map n (Map n e)

-- | A structural invariant for the graphs.
--   
--   The set of nodes is obtained by <tt>Map.keys . unGraph</tt> meaning
--   that each node, be it only the target of an edge, must be assigned an
--   adjacency map, albeit it could be empty.
--   
--   See <a>singleton</a>.
invariant :: Ord n => Graph n e -> Bool

-- | Turn a graph into a list of edges. <tt>O(n + e)</tt>
edges :: Ord n => Graph n e -> [(n, n, e)]

-- | All edges originating in the given nodes. (I.e., all outgoing edges
--   for the given nodes.)
--   
--   Roughly linear in the length of the result list <tt>O(result)</tt>.
edgesFrom :: Ord n => Graph n e -> [n] -> [(n, n, e)]

-- | Returns all the nodes in the graph. <tt>O(n)</tt>.
nodes :: Ord n => Graph n e -> Set n
filterEdges :: Ord n => (e -> Bool) -> Graph n e -> Graph n e

-- | Constructs a completely disconnected graph containing the given nodes.
--   <tt>O(n)</tt>.
fromNodes :: Ord n => [n] -> Graph n e

-- | Constructs a graph from a list of edges. O(e)
fromList :: (SemiRing e, Ord n) => [(n, n, e)] -> Graph n e

-- | Empty graph (no nodes, no edges).
empty :: Graph n e

-- | A graph with two nodes and a single connecting edge.
singleton :: Ord n => n -> n -> e -> Graph n e

-- | Insert an edge into the graph.
insert :: (SemiRing e, Ord n) => n -> n -> e -> Graph n e -> Graph n e

-- | Removes the given node, and all corresponding edges, from the graph.
removeNode :: Ord n => n -> Graph n e -> Graph n e

-- | <tt>removeEdge n1 n2 g</tt> removes the edge going from <tt>n1</tt> to
--   <tt>n2</tt>, if any.
removeEdge :: Ord n => n -> n -> Graph n e -> Graph n e
union :: (SemiRing e, Ord n) => Graph n e -> Graph n e -> Graph n e
unions :: (SemiRing e, Ord n) => [Graph n e] -> Graph n e
lookup :: Ord n => n -> n -> Graph n e -> Maybe e
neighbours :: Ord n => n -> Graph n e -> [(n, e)]

-- | The graph's strongly connected components, in reverse topological
--   order.
sccs' :: Ord n => Graph n e -> [SCC n]

-- | The graph's strongly connected components, in reverse topological
--   order.
sccs :: Ord n => Graph n e -> [[n]]

-- | Returns <tt>True</tt> iff the graph is acyclic.
acyclic :: Ord n => Graph n e -> Bool

-- | Computes the transitive closure of the graph.
--   
--   Note that this algorithm is not guaranteed to be correct (or
--   terminate) for arbitrary semirings.
--   
--   This function operates on the entire graph at once.
transitiveClosure1 :: (Eq e, SemiRing e, Ord n) => Graph n e -> Graph n e

-- | Computes the transitive closure of the graph.
--   
--   Note that this algorithm is not guaranteed to be correct (or
--   terminate) for arbitrary semirings.
--   
--   This function operates on one strongly connected component at a time.
transitiveClosure :: (Eq e, SemiRing e, Ord n) => Graph n e -> Graph n e
findPath :: (SemiRing e, Ord n) => (e -> Bool) -> n -> n -> Graph n e -> Maybe e

-- | <tt>allPaths classify a b g</tt> returns a list of pathes (accumulated
--   edge weights) from node <tt>a</tt> to node <tt>b</tt> in <tt>g</tt>.
--   Alternative intermediate pathes are only considered if they are
--   distinguished by the <tt>classify</tt> function.
allPaths :: (SemiRing e, Ord n, Ord c) => (e -> c) -> n -> n -> Graph n e -> [e]

-- | Generates a node from the graph. (Unless the graph is empty.)
nodeIn :: (Ord n, Arbitrary n) => Graph n e -> Gen n

-- | Generates an edge from the graph. (Unless the graph contains no
--   edges.)
edgeIn :: (Ord n, Arbitrary n, Arbitrary e) => Graph n e -> Gen (n, n, e)

-- | All tests.
tests :: IO Bool
instance (Eq n, Eq e) => Eq (Graph n e)
instance Functor (Graph n)
instance (Show n, Show e) => Show (Graph n e)
instance Arbitrary E
instance Eq E
instance Show E
instance SemiRing E
instance (Ord n, SemiRing e, Arbitrary n, Arbitrary e) => Arbitrary (Graph n e)


-- | An interface for reporting "impossible" errors
module Agda.Utils.Impossible

-- | "Impossible" errors, annotated with a file name and a line number
--   corresponding to the source code location of the error.
data Impossible
Impossible :: String -> Integer -> Impossible

-- | Abort by throwing an "impossible" error. You should not use this
--   function directly. Instead use the macro in <tt>undefined.h</tt>.
throwImpossible :: Impossible -> a

-- | Catch an "impossible" error, if possible.
catchImpossible :: IO a -> (Impossible -> IO a) -> IO a
instance Typeable Impossible
instance Exception Impossible
instance Show Impossible

module Agda.ImpossibleTest
impossibleTest :: a


-- | Operations on file names.
module Agda.Utils.FileName

-- | Paths which are known to be absolute.
--   
--   Note that the <a>Eq</a> and <a>Ord</a> instances do not check if
--   different paths point to the same files or directories.
--   
--   Andreas, 2014-03-30: For efficiency of serialization,
--   <a>AbsolutePath</a> is implemented as <a>ByteString</a> which
--   short-cuts equality testing using pointer equality. This saves 20% of
--   the serialization time of the standard library!
data AbsolutePath

-- | Extract the <a>AbsolutePath</a> to be used as <a>FilePath</a>.
filePath :: AbsolutePath -> FilePath

-- | maps <tt><i>bla</i>bla<i>bla</i>foo.bar.xxx</tt> to <tt>foo.bar</tt>.
rootName :: AbsolutePath -> String

-- | Constructs <a>AbsolutePath</a>s.
--   
--   Precondition: The path must be absolute and valid.
mkAbsolute :: FilePath -> AbsolutePath

-- | Makes the path absolute.
--   
--   This function may raise an <tt>__IMPOSSIBLE__</tt> error if
--   <a>canonicalizePath</a> does not return an absolute path.
absolute :: FilePath -> IO AbsolutePath

-- | Tries to establish if the two file paths point to the same file (or
--   directory).
(===) :: AbsolutePath -> AbsolutePath -> Bool

-- | Case-sensitive doesFileExist for Windows. This is case-sensitive only
--   on the file name part, not on the directory part. (Ideally, path
--   components coming from module name components should be checked
--   case-sensitively and the other path components should be checked case
--   insenstively.)
doesFileExistCaseSensitive :: FilePath -> IO Bool
tests :: IO Bool
instance Typeable AbsolutePath
instance Eq AbsolutePath
instance Ord AbsolutePath
instance Arbitrary AbsolutePath
instance Show AbsolutePath


-- | Instead of checking time-stamps we compute a hash of the module source
--   and store it in the interface file. This module contains the functions
--   to do that.
module Agda.Utils.Hash
type Hash = Word64
hashByteString :: ByteString -> Hash
hashFile :: AbsolutePath -> IO Hash
combineHashes :: [Hash] -> Hash

-- | Hashing a module name for unique identifiers.
hashString :: String -> Integer

module Agda.Utils.Suffix

-- | Is the character one of the subscripts <tt>'₀'</tt>-<tt>'₉'</tt>?
isSubscriptDigit :: Char -> Bool

-- | Converts <tt>'0'</tt>-<tt>'9'</tt> to <tt>'₀'</tt>-<tt>'₉'</tt>.
--   
--   Precondition: The digit needs to be in range.
toSubscriptDigit :: Char -> Char

-- | Converts <tt>'₀'</tt>-<tt>'₉'</tt> to <tt>'0'</tt>-<tt>'9'</tt>.
--   
--   Precondition: The digit needs to be in range.
fromSubscriptDigit :: Char -> Char

-- | Classification of identifier variants.
data Suffix
NoSuffix :: Suffix

-- | Identifier ends in <tt>Int</tt> many primes.
Prime :: Int -> Suffix

-- | Identifier ends in number <tt>Int</tt> (ordinary digits).
Index :: Int -> Suffix

-- | Identifier ends in number <tt>Int</tt> (subscript digits).
Subscript :: Int -> Suffix

-- | Increase the suffix by one. If no suffix yet, put a subscript
--   <tt>1</tt>.
nextSuffix :: Suffix -> Suffix

-- | Parse suffix.
suffixView :: String -> (String, Suffix)

-- | Print suffix.
addSuffix :: String -> Suffix -> String

-- | Add first available <tt>Suffix</tt> to a name.
nameVariant :: (String -> Bool) -> String -> String


-- | An empty type with some useful instances.
module Agda.Utils.Empty
data Empty
absurd :: Empty -> a
instance Show Empty
instance Ord Empty
instance Eq Empty


-- | Additional functions for association lists.
module Agda.Utils.AssocList

-- | A finite map, represented as a set of pairs.
--   
--   Invariant: at most one value per key.
type AssocList k v = [(k, v)]

-- | O(n). Reexport <a>lookup</a>.
lookup :: Eq k => k -> AssocList k v -> Maybe v

-- | O(n). Get the domain (list of keys) of the finite map.
keys :: AssocList k v -> [k]

-- | O(1). Add a new binding. Assumes the binding is not yet in the list.
insert :: k -> v -> AssocList k v -> AssocList k v

-- | O(n). Update the value at a key. The key must be in the domain of the
--   finite map. Otherwise, an internal error is raised.
update :: Eq k => k -> v -> AssocList k v -> AssocList k v

-- | O(n). Update the value at a key with a certain function. The key must
--   be in the domain of the finite map. Otherwise, an internal error is
--   raised.
updateAt :: Eq k => k -> (v -> v) -> AssocList k v -> AssocList k v

-- | O(n). Map over an association list, preserving the order.
mapWithKey :: (k -> v -> v) -> AssocList k v -> AssocList k v

-- | O(n). If called with a effect-producing function, violation of the
--   invariant could matter here (duplicating effects).
mapWithKeyM :: (Functor m, Applicative m) => (k -> v -> m v) -> AssocList k v -> m (AssocList k v)

-- | O(n). Named in analogy to <a>mapKeysMonotonic</a>. To preserve the
--   invariant, it is sufficient that the key transformation is injective
--   (rather than monotonic).
mapKeysMonotonic :: (k -> k') -> AssocList k v -> AssocList k' v

module Agda.Utils.Map
data EitherOrBoth a b
L :: a -> EitherOrBoth a b
B :: a -> b -> EitherOrBoth a b
R :: b -> EitherOrBoth a b

-- | Not very efficient (goes via a list), but it'll do.
unionWithM :: (Ord k, Functor m, Monad m) => (a -> a -> m a) -> Map k a -> Map k a -> m (Map k a)
insertWithKeyM :: (Ord k, Monad m) => (k -> a -> a -> m a) -> k -> a -> Map k a -> m (Map k a)

-- | Big conjunction over a map.
allWithKey :: (k -> a -> Bool) -> Map k a -> Bool

-- | Filter a map based on the keys.
filterKeys :: Ord k => (k -> Bool) -> Map k a -> Map k a

-- | Unzip a map.
unzip :: Map k (a, b) -> (Map k a, Map k b)
unzip3 :: Map k (a, b, c) -> (Map k a, Map k b, Map k c)


-- | Maintaining a list of favorites of some partially ordered type. Only
--   the best elements are kept.
--   
--   To avoid name clashes, import this module qualified, as in <tt> import
--   Agda.Utils.Favorites (Favorites) import qualified Agda.Utils.Favorites
--   as Fav </tt>
module Agda.Utils.Favorites

-- | A list of incomparable favorites.
newtype Favorites a
Favorites :: [a] -> Favorites a
toList :: Favorites a -> [a]

-- | Equality checking is a bit expensive, since we need to sort! Maybe use
--   a <a>Set</a> of favorites in the first place?

-- | No favories yet?
null :: Favorites a -> Bool

-- | No favorites yet. Poor me!
empty :: Favorites a

-- | You are my one and only, darling!
singleton :: a -> Favorites a

-- | Result of comparing a candidate with the current favorites.
data CompareResult a

-- | Great, you are dominating a possibly (empty list of favorites) but
--   there is also a rest that is not dominated. If <tt>null
--   dominated</tt>, then <tt>notDominated</tt> is necessarily the complete
--   list of favorites.
Dominates :: [a] -> [a] -> CompareResult a
dominated :: CompareResult a -> [a]
notDominated :: CompareResult a -> [a]

-- | Sorry, but you are dominated by that favorite.
IsDominated :: a -> CompareResult a
dominator :: CompareResult a -> a

-- | Gosh, got some pretty <tt>a</tt> here, compare with my current
--   favorites! Discard it if there is already one that is better or equal.
--   (Skewed conservatively: faithful to the old favorites.) If there is no
--   match for it, add it, and dispose of all that are worse than
--   <tt>a</tt>.
--   
--   We require a partial ordering. Less is better! (Maybe paradoxically.)
compareWithFavorites :: PartialOrd a => a -> Favorites a -> CompareResult a

-- | Compare a new set of favorites to an old one and discard the new
--   favorites that are dominated by the old ones and vice verse. (Skewed
--   conservatively: faithful to the old favorites.)
--   
--   <pre>
--   compareFavorites new old = (new', old')
--   </pre>
compareFavorites :: PartialOrd a => Favorites a -> Favorites a -> (Favorites a, Favorites a)
unionCompared :: PartialOrd a => (Favorites a, Favorites a) -> Favorites a

-- | After comparing, do the actual insertion.
insertCompared :: PartialOrd a => a -> Favorites a -> CompareResult a -> Favorites a

-- | Compare, then insert accordingly. <tt>insert a l = insertCompared a l
--   (compareWithFavorites a l)</tt>
insert :: PartialOrd a => a -> Favorites a -> Favorites a

-- | Insert all the favorites from the first list into the second.
union :: PartialOrd a => Favorites a -> Favorites a -> Favorites a

-- | Construct favorites from elements of a partial order. The result
--   depends on the order of the list if it contains equal elements, since
--   earlier seen elements are favored over later seen equals. The first
--   element of the list is seen first.
fromList :: PartialOrd a => [a] -> Favorites a

-- | <a>Favorites</a> forms a <a>Monoid</a> under <a>empty</a> and 'union.
property_null_empty :: Bool
property_not_null_singleton :: a -> Bool
prop_compareWithFavorites :: ISet -> Favorites ISet -> Bool
prop_fromList_after_toList :: Favorites ISet -> Bool

-- | A second way to compute the <a>union</a> is to use
--   <a>compareFavorites</a>.
prop_union_union2 :: Favorites ISet -> Favorites ISet -> Bool

-- | All tests as collected by <a>quickCheckAll</a>.
--   
--   Using <a>quickCheckAll</a> is convenient and superior to the manual
--   enumeration of tests, since the name of the property is added
--   automatically.
tests :: IO Bool
instance Foldable Favorites
instance Show a => Show (Favorites a)
instance CoArbitrary a => CoArbitrary (Favorites a)
instance (PartialOrd a, Arbitrary a) => Arbitrary (Favorites a)
instance PartialOrd a => Monoid (Favorites a)
instance Ord a => Eq (Favorites a)


-- | A simple overlay over Data.Map to manage unordered sets with
--   duplicates.
module Agda.Utils.Bag

-- | A set with duplicates. Faithfully stores elements which are equal with
--   regard to (==).
newtype Bag a
Bag :: Map a [a] -> Bag a
bag :: Bag a -> Map a [a]
null :: Bag a -> Bool
size :: Bag a -> Int

-- | <tt>bag ! a</tt> finds all elements equal to <tt>a</tt>.
(!) :: Ord a => Bag a -> a -> [a]
member :: Ord a => a -> Bag a -> Bool
notMember :: Ord a => a -> Bag a -> Bool

-- | Return the multiplicity of the given element.
count :: Ord a => a -> Bag a -> Int
empty :: Bag a
singleton :: a -> Bag a
union :: Ord a => Bag a -> Bag a -> Bag a
unions :: Ord a => [Bag a] -> Bag a

-- | <pre>
--   insert a b = union b (singleton a)
--   </pre>
insert :: Ord a => a -> Bag a -> Bag a

-- | <pre>
--   fromList = unions . map singleton
--   </pre>
fromList :: Ord a => [a] -> Bag a

-- | Returns the elements of the bag, grouped by equality (==).
groups :: Bag a -> [[a]]

-- | Returns the bag, with duplicates.
toList :: Bag a -> [a]

-- | Returns the bag without duplicates.
keys :: Bag a -> [a]

-- | Returns the bag, with duplicates.
elems :: Bag a -> [a]
toAscList :: Bag a -> [a]
map :: (Ord a, Ord b) => (a -> b) -> Bag a -> Bag b
traverse :: (Applicative m, Ord b) => (a -> m b) -> Bag a -> m (Bag b)
prop_count_empty :: Ord a => a -> Bool
prop_count_singleton :: Ord a => a -> Bool
prop_count_insert :: Ord a => a -> Bag a -> Bool
prop_size_union :: Ord a => Bag a -> Bag a -> Bool
prop_size_fromList :: Ord a => [a] -> Bool
prop_fromList_toList :: Ord a => Bag a -> Bool
prop_toList_fromList :: Ord a => [a] -> Bool
prop_keys_fromList :: Ord a => [a] -> Bool
prop_nonempty_groups :: Bag a -> Bool
prop_map_id :: Ord a => Bag a -> Bool
prop_map_compose :: (Ord a, Ord b, Ord c) => (b -> c) -> (a -> b) -> Bag a -> Bool
prop_traverse_id :: Ord a => Bag a -> Bool

-- | All tests as collected by <a>quickCheckAll</a>.
--   
--   Using <a>quickCheckAll</a> is convenient and superior to the manual
--   enumeration of tests, since the name of the property is added
--   automatically.
tests :: IO Bool
instance Eq a => Eq (Bag a)
instance Ord a => Ord (Bag a)
instance (Ord a, Arbitrary a) => Arbitrary (Bag a)
instance Foldable Bag
instance Ord a => Monoid (Bag a)
instance Show a => Show (Bag a)


-- | Utitlity functions on lists.
module Agda.Utils.List

-- | Case distinction for lists, with list first. Cf. <a>ifNull</a>.
caseList :: [a] -> b -> (a -> [a] -> b) -> b

-- | Case distinction for lists, with list last.
listCase :: b -> (a -> [a] -> b) -> [a] -> b

-- | Head function (safe).
headMaybe :: [a] -> Maybe a

-- | Head function (safe). Returns a value on empty lists.
--   
--   <pre>
--   headWithDefault 42 []      = 42
--   headWithDefault 42 [1,2,3] = 1
--   </pre>
headWithDefault :: a -> [a] -> a

-- | Last element (safe).
lastMaybe :: [a] -> Maybe a

-- | Opposite of cons <tt>(:)</tt>, safe.
uncons :: [a] -> Maybe (a, [a])

-- | Maybe cons. <tt>mcons ma as = maybeToList ma ++ as</tt>
mcons :: Maybe a -> [a] -> [a]

-- | <a>init</a> and <a>last</a> in one go, safe.
initLast :: [a] -> Maybe ([a], a)

-- | Lookup function (partially safe).
(!!!) :: [a] -> Int -> Maybe a

-- | downFrom n = [n-1,..1,0]
downFrom :: Integral a => a -> [a]

-- | Update the last element of a list, if it exists
updateLast :: (a -> a) -> [a] -> [a]

-- | A generalized version of <tt>partition</tt>. (Cf. <tt>mapMaybe</tt>
--   vs. <tt>filter</tt>).
mapEither :: (a -> Either b c) -> [a] -> ([b], [c])
deal :: (a -> Either b c) -> a -> ([b], [c]) -> ([b], [c])

-- | A generalized version of <tt>takeWhile</tt>. (Cf. <tt>mapMaybe</tt>
--   vs. <tt>filter</tt>).
takeWhileJust :: (a -> Maybe b) -> [a] -> [b]

-- | A generalized version of <tt>span</tt>.
spanJust :: (a -> Maybe b) -> [a] -> ([b], [a])

-- | Partition a list into <a>Nothing</a>s and <a>Just</a>s.
--   <tt><a>mapMaybe</a> f = snd . partitionMaybe f</tt>.
partitionMaybe :: (a -> Maybe b) -> [a] -> ([a], [b])

-- | Sublist relation.
isSublistOf :: Eq a => [a] -> [a] -> Bool
type Prefix a = [a]
type Suffix a = [a]

-- | Check if a list has a given prefix. If so, return the list minus the
--   prefix.
maybePrefixMatch :: Eq a => Prefix a -> [a] -> Maybe (Suffix a)

-- | Result of <a>preOrSuffix</a>.
data PreOrSuffix a

-- | First list is prefix of second.
IsPrefix :: a -> [a] -> PreOrSuffix a

-- | First list is suffix of second.
IsSuffix :: a -> [a] -> PreOrSuffix a

-- | The lists are equal.
IsBothfix :: PreOrSuffix a

-- | The lists are incomparable.
IsNofix :: PreOrSuffix a

-- | Compare lists with respect to prefix partial order.
preOrSuffix :: Eq a => [a] -> [a] -> PreOrSuffix a

-- | Split a list into sublists. Generalisation of the prelude function
--   <tt>words</tt>.
--   
--   <pre>
--   words xs == wordsBy isSpace xs
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Chop up a list in chunks of a given length.
chop :: Int -> [a] -> [[a]]

-- | All ways of removing one element from a list.
holes :: [a] -> [(a, [a])]

-- | Check whether a list is sorted.
--   
--   Assumes that the <a>Ord</a> instance implements a partial order.
sorted :: Ord a => [a] -> Bool

-- | Check whether all elements in a list are distinct from each other.
--   Assumes that the <a>Eq</a> instance stands for an equivalence
--   relation.
distinct :: Eq a => [a] -> Bool

-- | An optimised version of <a>distinct</a>.
--   
--   Precondition: The list's length must fit in an <a>Int</a>.
fastDistinct :: Ord a => [a] -> Bool
prop_distinct_fastDistinct :: [Integer] -> Bool

-- | Checks if all the elements in the list are equal. Assumes that the
--   <a>Eq</a> instance stands for an equivalence relation.
allEqual :: Eq a => [a] -> Bool

-- | Returns an (arbitrary) representative for each list element that
--   occurs more than once.
duplicates :: Ord a => [a] -> [a]

-- | A variant of <a>groupBy</a> which applies the predicate to consecutive
--   pairs.
groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]
prop_groupBy' :: (Bool -> Bool -> Bool) -> [Bool] -> Property

-- | <tt><a>groupOn</a> f = <a>groupBy</a> ((<a>==</a>) `on` f) <a>.</a>
--   <a>sortBy</a> (<a>compare</a> `on` f)</tt>.
groupOn :: Ord b => (a -> b) -> [a] -> [[a]]

-- | <tt>splitExactlyAt n xs = Just (ys, zs)</tt> iff <tt>xs = ys ++
--   zs</tt> and <tt>genericLength ys = n</tt>.
splitExactlyAt :: Integral n => n -> [a] -> Maybe ([a], [a])

-- | <tt><a>extractNthElement</a> n xs</tt> gives the <tt>n</tt>-th element
--   in <tt>xs</tt> (counting from 0), plus the remaining elements
--   (preserving order).
extractNthElement' :: Integral i => i -> [a] -> ([a], a, [a])
extractNthElement :: Integral i => i -> [a] -> (a, [a])
prop_extractNthElement :: Integer -> [Integer] -> Property

-- | A generalised variant of <a>elemIndex</a>.
genericElemIndex :: (Eq a, Integral i) => a -> [a] -> Maybe i
prop_genericElemIndex :: Integer -> [Integer] -> Property

-- | Requires both lists to have the same length.
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
prop_zipWith' :: (Integer -> Integer -> Integer) -> Property

-- | Efficient version of nub that sorts the list via a search tree
--   (<a>Map</a>).
uniqOn :: Ord b => (a -> b) -> [a] -> [a]
prop_uniqOn :: [Integer] -> Bool

-- | Compute the common suffix of two lists.
commonSuffix :: Eq a => [a] -> [a] -> [a]

-- | Compute the common prefix of two lists.
commonPrefix :: Eq a => [a] -> [a] -> [a]
prop_commonPrefix :: [Integer] -> [Integer] -> [Integer] -> Bool
prop_commonSuffix :: [Integer] -> [Integer] -> [Integer] -> Bool
tests :: IO Bool


-- | Directed graphs (can of course simulate undirected graphs).
--   
--   Represented as adjacency maps in direction from source to target.
--   
--   Each source node maps to a adjacency map of outgoing edges, which is a
--   map from target nodes to edges.
--   
--   This allows to get outgoing edges in O(log n) time where <tt>n</tt> is
--   the number of nodes in the graph.
module Agda.Utils.Graph.AdjacencyMap.Unidirectional

-- | <tt>Graph s t e</tt> is a directed graph with source nodes in
--   <tt>s</tt> target nodes in <tt>t</tt> and edges in <tt>e</tt>.
--   
--   Admits at most one edge between any two nodes. Several edges can be
--   modeled by using a collection type for <tt>e</tt>.
--   
--   Represented as "adjacency list", or rather, adjacency map. This allows
--   to get all outgoing edges for a node in <tt>O(log n)</tt> time where
--   <tt>n</tt> is the number of nodes of the graph.
newtype Graph s t e
Graph :: Map s (Map t e) -> Graph s t e

-- | Forward edges.
graph :: Graph s t e -> Map s (Map t e)
data Edge s t e
Edge :: s -> t -> e -> Edge s t e

-- | Outgoing node.
source :: Edge s t e -> s

-- | Incoming node.
target :: Edge s t e -> t

-- | Edge label (weight).
label :: Edge s t e -> e

-- | Reverse an edge.
transposeEdge :: Edge s t e -> Edge t s e

-- | Turn a graph into a list of edges. <tt>O(n + e)</tt>
edges :: (Ord s, Ord t) => Graph s t e -> [Edge s t e]

-- | All edges originating in the given nodes. (I.e., all outgoing edges
--   for the given nodes.)
--   
--   Roughly linear in the length of the result list <tt>O(result)</tt>.
edgesFrom :: (Ord s, Ord t) => Graph s t e -> [s] -> [Edge s t e]

-- | All edges ending in the given nodes. (I.e., all incoming edges for the
--   given nodes.)
--   
--   Expensive: <tt>O(n * |ts| * log n)</tt>.
edgesTo :: (Ord s, Ord t) => Graph s t e -> [t] -> [Edge s t e]

-- | Get all self-loops.
diagonal :: Ord n => Graph n n e -> [Edge n n e]

-- | Lookup label of an edge.
lookup :: (Ord s, Ord t) => s -> t -> Graph s t e -> Maybe e

-- | Get a list of outgoing edges with target.
neighbours :: (Ord s, Ord t) => s -> Graph s t e -> [(t, e)]

-- | Returns all the nodes with outgoing edges. <tt>O(n)</tt>.
sourceNodes :: (Ord s, Ord t) => Graph s t e -> Set s

-- | Returns all the nodes with incoming edges. Expensive! <tt>O(e)</tt>.
targetNodes :: (Ord s, Ord t) => Graph s t e -> Set t

-- | For homogeneous graphs, <tt>(s = t)</tt> we can compute a set of all
--   nodes.
--   
--   Structure <tt>Nodes</tt> is for computing all nodes but also
--   remembering which were incoming and which outgoing. This is mostly for
--   efficiency reasons, to avoid recomputation when all three sets are
--   needed.
data Nodes n
Nodes :: Set n -> Set n -> Set n -> Nodes n
srcNodes :: Nodes n -> Set n
tgtNodes :: Nodes n -> Set n
allNodes :: Nodes n -> Set n
computeNodes :: Ord n => Graph n n e -> Nodes n

-- | The set of all nodes (outgoing and incoming).
nodes :: Ord n => Graph n n e -> Set n

-- | Constructs a completely disconnected graph containing the given nodes.
--   <tt>O(n)</tt>.
fromNodes :: Ord n => [n] -> Graph n n e

-- | Constructs a graph from a list of edges. O(e log n)
--   
--   Later edges overwrite earlier edges.
fromList :: (Ord s, Ord t) => [Edge s t e] -> Graph s t e

-- | Constructs a graph from a list of edges. O(e log n)
--   
--   Later edges are combined with earlier edges using the supplied
--   function.
fromListWith :: (Ord s, Ord t) => (e -> e -> e) -> [Edge s t e] -> Graph s t e

-- | Convert a graph into a list of edges. O(e)
toList :: (Ord s, Ord t) => Graph s t e -> [Edge s t e]

-- | Empty graph (no nodes, no edges).
empty :: Graph s t e

-- | A graph with two nodes and a single connecting edge.
singleton :: (Ord s, Ord t) => s -> t -> e -> Graph s t e

-- | Insert an edge into the graph.
insert :: (Ord s, Ord t) => s -> t -> e -> Graph s t e -> Graph s t e

-- | Insert an edge, possibly combining <tt>old</tt> edge weight with
--   <tt>new</tt> weight by given function <tt>f</tt> into <tt>f new
--   old</tt>.
insertWith :: (Ord s, Ord t) => (e -> e -> e) -> s -> t -> e -> Graph s t e -> Graph s t e
insertEdge :: (Ord s, Ord t) => Edge s t e -> Graph s t e -> Graph s t e
insertEdgeWith :: (Ord s, Ord t) => (e -> e -> e) -> Edge s t e -> Graph s t e -> Graph s t e

-- | Left-biased union.
union :: (Ord s, Ord t) => Graph s t e -> Graph s t e -> Graph s t e
unionWith :: (Ord s, Ord t) => (e -> e -> e) -> Graph s t e -> Graph s t e -> Graph s t e
unions :: (Ord s, Ord t) => [Graph s t e] -> Graph s t e
unionsWith :: (Ord s, Ord t) => (e -> e -> e) -> [Graph s t e] -> Graph s t e

-- | Removes the given node, be it source or target, and all corresponding
--   edges, from the graph.
--   
--   Expensive! <tt>O(n log n)</tt>.
removeNode :: Ord n => n -> Graph n n e -> Graph n n e

-- | <tt>removeEdge s t g</tt> removes the edge going from <tt>s</tt> to
--   <tt>t</tt>, if any.
--   
--   <tt>O((log n)^2)</tt>.
removeEdge :: (Ord s, Ord t) => s -> t -> Graph s t e -> Graph s t e

-- | Keep only the edges that satisfy the predicate. <tt>O(e).</tt>
filterEdges :: (Ord s, Ord t) => (e -> Bool) -> Graph s t e -> Graph s t e

-- | Unzipping a graph (naive implementation using fmap).
unzip :: Graph s t (e, e') -> (Graph s t e, Graph s t e')

-- | The graph's strongly connected components, in reverse topological
--   order.
sccs' :: Ord n => Graph n n e -> [SCC n]

-- | The graph's strongly connected components, in reverse topological
--   order.
sccs :: Ord n => Graph n n e -> [[n]]

-- | Returns <tt>True</tt> iff the graph is acyclic.
acyclic :: Ord n => Graph n n e -> Bool

-- | <tt>composeWith times plus g g'</tt> finds all edges <tt>s --c_i--&gt;
--   t_i --d_i--&gt; u</tt> and constructs the result graph from
--   <tt>edge(s,u) = sum_i (c_i times d_i)</tt>.
--   
--   Complexity: for each edge <tt>s --&gt; t</tt> in <tt>g</tt> we lookup
--   up all edges starting in with <tt>t</tt> in <tt>g'</tt>.
composeWith :: (Ord s, Ord t, Ord u) => (c -> d -> e) -> (e -> e -> e) -> Graph s t c -> Graph t u d -> Graph s u e

-- | Computes the transitive closure of the graph.
--   
--   Note that this algorithm is not guaranteed to be correct (or
--   terminate) for arbitrary semirings.
--   
--   This function operates on the entire graph at once.
transitiveClosure1 :: (Eq e, SemiRing e, Ord n) => Graph n n e -> Graph n n e

-- | Computes the transitive closure of the graph.
--   
--   Note that this algorithm is not guaranteed to be correct (or
--   terminate) for arbitrary semirings.
--   
--   This function operates on one strongly connected component (SCC) at a
--   time.
--   
--   For each SCC, it uses a saturation algorithm on state <tt>(g, es)</tt>
--   where initially <tt>es</tt> is the set of edges of the SCC and
--   <tt>g</tt> the graph. The algorithm finishes if <tt>es</tt> has not
--   changed in an iteration. At each step, all <tt>es</tt> are composed
--   with <tt>g</tt>, the resulting new graphs are unioned with <tt>g</tt>.
--   The new <tt>es</tt> is then computed as the edges of the SCC in the
--   new <tt>g</tt>.
transitiveClosure :: (Eq e, SemiRing e, Ord n) => Graph n n e -> Graph n n e

-- | Find a path from a source node to a target node.
--   
--   The path must satisfy the given predicate <tt>good :: e -&gt;
--   Bool</tt>.
findPath :: (SemiRing e, Ord n) => (e -> Bool) -> n -> n -> Graph n n e -> Maybe e

-- | <tt>allPaths classify a b g</tt> returns a list of pathes (accumulated
--   edge weights) from node <tt>a</tt> to node <tt>b</tt> in <tt>g</tt>.
--   Alternative intermediate pathes are only considered if they are
--   distinguished by the <tt>classify</tt> function.
allPaths :: (SemiRing e, Ord n, Ord c) => (e -> c) -> n -> n -> Graph n n e -> [e]

-- | Generates a node from the graph. (Unless the graph is empty.)
nodeIn :: (Ord n, Arbitrary n) => Graph n n e -> Gen n

-- | Generates an edge from the graph. (Unless the graph contains no
--   edges.)
edgeIn :: (Ord n, Arbitrary n, Arbitrary e) => Graph n n e -> Gen (Edge n n e)

-- | All tests.
tests :: IO Bool
instance (Eq s, Eq t, Eq e) => Eq (Graph s t e)
instance Functor (Graph s t)
instance (Show s, Show t, Show e) => Show (Graph s t e)
instance (Eq s, Eq t, Eq e) => Eq (Edge s t e)
instance (Ord s, Ord t, Ord e) => Ord (Edge s t e)
instance Functor (Edge s t)
instance (Show s, Show t, Show e) => Show (Edge s t e)
instance Arbitrary N
instance Eq N
instance Ord N
instance Arbitrary E
instance Eq E
instance Show E
instance SemiRing E
instance Show N
instance (Ord n, SemiRing e, Arbitrary n, Arbitrary e) => Arbitrary (Graph n n e)
instance (CoArbitrary s, CoArbitrary t, CoArbitrary e) => CoArbitrary (Edge s t e)
instance (Arbitrary s, Arbitrary t, Arbitrary e) => Arbitrary (Edge s t e)

module Agda.TypeChecking.SizedTypes.WarshallSolver
type Graph r f a = Graph (Node r f) (Node r f) a
type Edge' r f a = Edge (Node r f) (Node r f) a
type Key r f = Edge' r f ()
type Nodes r f = Nodes (Node r f)
type LabelledEdge r f = Edge' r f Label
src :: Edge s t e -> s
dest :: Edge s t e -> t
lookupEdge :: (Ord s, Ord t) => Graph s t e -> s -> t -> Maybe e
graphToList :: (Ord s, Ord t) => Graph s t e -> [Edge s t e]
graphFromList :: (Ord s, Ord t) => [Edge s t e] -> Graph s t e
insertEdge :: (Ord s, Ord t, MeetSemiLattice e, Top e) => Edge s t e -> Graph s t e -> Graph s t e

-- | Compute list of edges that start in a given node.
outgoing :: (Ord r, Ord f) => Graph r f a -> Node r f -> [Edge' r f a]

-- | Compute list of edges that target a given node.
--   
--   Note: expensive for unidirectional graph representations.
incoming :: (Ord r, Ord f) => Graph r f a -> Node r f -> [Edge' r f a]

-- | <tt>Set.foldl</tt> does not exist in legacy versions of the
--   <tt>containers</tt> package.
setFoldl :: (b -> a -> b) -> b -> Set a -> b

-- | Floyd-Warshall algorithm.
transClos :: (Ord n, Dioid a) => Graph n n a -> Graph n n a
data Weight
Offset :: Int -> Weight
Infinity :: Weight

-- | Partial implementation of <tt>Num</tt>.

-- | Test for negativity, used to detect negative cycles.
class Negative a
negative :: Negative a => a -> Bool

-- | Going from <tt>Lt</tt> to <tt>Le</tt> is <tt>pred</tt>, going from
--   <tt>Le</tt> to <tt>Lt</tt> is <tt>succ</tt>.
--   
--   <tt>X --(R,n)--&gt; Y</tt> means <tt>X (R) Y + n</tt>. [ ... if
--   <tt>n</tt> positive and <tt>X + (-n) (R) Y</tt> if <tt>n</tt>
--   negative. ]
data Label
Label :: Cmp -> Offset -> Label
lcmp :: Label -> Cmp
loffset :: Label -> Offset

-- | Nodes not connected.
LInf :: Label

-- | Convert a label to a weight, decrementing in case of <a>Lt</a>.
toWeight :: Label -> Weight
data Node rigid flex
NodeZero :: Node rigid flex
NodeInfty :: Node rigid flex
NodeRigid :: rigid -> Node rigid flex
NodeFlex :: flex -> Node rigid flex
isFlexNode :: Node rigid flex -> Maybe flex
isZeroNode :: Node rigid flex -> Bool
isInftyNode :: Node rigid flex -> Bool
nodeToSizeExpr :: Node rigid flex -> SizeExpr' rigid flex

-- | An edge is negative if its label is.

-- | A graph forest.
type Graphs r f a = [Graph r f a]
emptyGraphs :: Graphs r f a

-- | Split a list of graphs <tt>gs</tt> into those that mention node
--   <tt>n</tt> and those that do not. If <tt>n</tt> is zero or infinity,
--   we regard it as "not mentioned".
mentions :: (Ord r, Ord f) => Node r f -> Graphs r f a -> (Graphs r f a, Graphs r f a)

-- | Add an edge to a graph forest. Graphs that share a node with the edge
--   are joined.
addEdge :: (Ord r, Ord f, MeetSemiLattice a, Top a) => Edge' r f a -> Graphs r f a -> Graphs r f a

-- | Reflexive closure. Add edges <tt>0 -&gt; n -&gt; n -&gt; oo</tt> for
--   all nodes <tt>n</tt>.
reflClos :: (Ord r, Ord f, Show a, Dioid a) => Set (Node r f) -> Graph r f a -> Graph r f a

-- | A graph is <a>negative</a> if it contains a negative loop (diagonal
--   edge). Makes sense on transitive graphs.

-- | <tt>h <a>implies</a> g</tt> if any edge in <tt>g</tt> between rigids
--   and constants is implied by a corresponding edge in <tt>h</tt>, which
--   means that the edge in <tt>g</tt> carries at most the information of
--   the one in <tt>h</tt>.
--   
--   Application: Constraint implication: Constraints are compatible with
--   hypotheses.
implies :: (Ord r, Ord f, Show r, Show f, Show a, Top a, Ord a, Negative a) => Graph r f a -> Graph r f a -> Bool
nodeFromSizeExpr :: SizeExpr' rigid flex -> (Node rigid flex, Offset)
edgeFromConstraint :: Constraint' rigid flex -> LabelledEdge rigid flex

-- | Build a graph from list of simplified constraints.
graphFromConstraints :: (Ord rigid, Ord flex) => [Constraint' rigid flex] -> Graph rigid flex Label

-- | Build a graph from list of simplified constraints.
graphsFromConstraints :: (Ord rigid, Ord flex) => [Constraint' rigid flex] -> Graphs rigid flex Label
type Hyp = Constraint
type Hyp' = Constraint'
type HypGraph r f = Graph r f Label
hypGraph :: (Ord rigid, Ord flex) => Set rigid -> [Hyp' rigid flex] -> Maybe (HypGraph rigid flex)
hypConn :: (Ord r, Ord f) => HypGraph r f -> Node r f -> Node r f -> Label
simplifyWithHypotheses :: (Ord rigid, Ord flex) => HypGraph rigid flex -> [Constraint' rigid flex] -> Maybe [Constraint' rigid flex]
type ConGraph r f = Graph r f Label
constraintGraph :: (Ord r, Ord f, Show r, Show f) => [Constraint' r f] -> HypGraph r f -> Maybe (ConGraph r f)
type ConGraphs r f = Graphs r f Label
constraintGraphs :: (Ord r, Ord f, Show r, Show f) => [Constraint' r f] -> HypGraph r f -> Maybe ([f], ConGraphs r f)

-- | If we have an edge <tt>X + n &lt;= X</tt> (with n &gt;= 0), we must
--   set <tt>X = oo</tt>.
infinityFlexs :: (Ord r, Ord f) => ConGraph r f -> ([f], ConGraph r f)
class SetToInfty f a
setToInfty :: SetToInfty f a => [f] -> a -> a

-- | Lower or upper bound for a flexible variable
type Bound r f = Map f (Set (SizeExpr' r f))
emptyBound :: Bound r f
data Bounds r f
Bounds :: Bound r f -> Bound r f -> Set f -> Bounds r f
lowerBounds :: Bounds r f -> Bound r f
upperBounds :: Bounds r f -> Bound r f
mustBeFinite :: Bounds r f -> Set f

-- | Compute a lower bound for a flexible from an edge.
edgeToLowerBound :: (Ord r, Ord f) => LabelledEdge r f -> Maybe (f, SizeExpr' r f)

-- | Compute an upper bound for a flexible from an edge.
edgeToUpperBound :: (Ord r, Ord f) => LabelledEdge r f -> Maybe (f, Cmp, SizeExpr' r f)

-- | Compute the lower bounds for all flexibles in a graph.
graphToLowerBounds :: (Ord r, Ord f) => [LabelledEdge r f] -> Bound r f

-- | Compute the upper bounds for all flexibles in a graph.
graphToUpperBounds :: (Ord r, Ord f) => [LabelledEdge r f] -> (Bound r f, Set f)

-- | Compute the bounds for all flexibles in a graph.
bounds :: (Ord r, Ord f) => ConGraph r f -> Bounds r f

-- | Compute the relative minima in a set of nodes (those that do not have
--   a predecessor in the set).
smallest :: (Ord r, Ord f) => HypGraph r f -> [Node r f] -> [Node r f]

-- | Compute the relative maxima in a set of nodes (those that do not have
--   a successor in the set).
largest :: (Ord r, Ord f) => HypGraph r f -> [Node r f] -> [Node r f]

-- | Given source nodes n1,n2,... find all target nodes m1,m2, such that
--   for all j, there are edges n_i --l_ij--&gt; m_j for all i. Return
--   these edges as a map from target notes to a list of edges. We assume
--   the graph is reflexive-transitive.
commonSuccs :: (Ord r, Ord f, Dioid a) => Graph r f a -> [Node r f] -> Map (Node r f) [Edge' r f a]

-- | Given target nodes m1,m2,... find all source nodes n1,n2, such that
--   for all j, there are edges n_i --l_ij--&gt; m_j for all i. Return
--   these edges as a map from target notes to a list of edges. We assume
--   the graph is reflexive-transitive.
commonPreds :: (Ord r, Ord f, Dioid a) => Graph r f a -> [Node r f] -> Map (Node r f) [Edge' r f a]

-- | Compute the sup of two different rigids or a rigid and a constant.
lub' :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> (Node r f, Offset) -> (Node r f, Offset) -> Maybe (SizeExpr' r f)

-- | Compute the inf of two different rigids or a rigid and a constant.
glb' :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> (Node r f, Offset) -> (Node r f, Offset) -> Maybe (SizeExpr' r f)

-- | Compute the least upper bound (sup).
lub :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> (SizeExpr' r f) -> (SizeExpr' r f) -> Maybe (SizeExpr' r f)

-- | Compute the greatest lower bound (inf) of size expressions relative to
--   a hypotheses graph.
glb :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> (SizeExpr' r f) -> (SizeExpr' r f) -> Maybe (SizeExpr' r f)
findRigidBelow :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> (SizeExpr' r f) -> Maybe (SizeExpr' r f)
solveGraph :: (Ord r, Ord f, Show r, Show f) => Polarities f -> HypGraph r f -> ConGraph r f -> Either String (Solution r f)

-- | Solve a forest of constraint graphs relative to a hypotheses graph.
--   Concatenate individual solutions.
solveGraphs :: (Ord r, Ord f, Show r, Show f) => Polarities f -> HypGraph r f -> ConGraphs r f -> Either String (Solution r f)

-- | Check that after substitution of the solution, constraints are implied
--   by hypotheses.
verifySolution :: (Ord r, Ord f, Show r, Show f) => HypGraph r f -> [Constraint' r f] -> Solution r f -> Either String ()
testSuccs :: Ord f => Map (Node [Char] f) [Edge' [Char] f Label]
testLub :: (Show f, Ord f) => Maybe (SizeExpr' [Char] f)
instance Eq Weight
instance (Eq rigid, Eq flex) => Eq (Node rigid flex)
instance (Ord rigid, Ord flex) => Ord (Node rigid flex)
instance Plus (SizeExpr' r f) Label (SizeExpr' r f)
instance Plus (SizeExpr' r f) Weight (SizeExpr' r f)
instance Plus Offset Weight Weight
instance Plus Int Int Int
instance (Ord r, Ord f) => SetToInfty f (ConGraph r f)
instance Eq f => SetToInfty f (Edge' r f a)
instance Eq f => SetToInfty f (Node r f)
instance (Ord r, Ord f, Negative a) => Negative (Graphs r f a)
instance (Ord r, Ord f, Negative a) => Negative (Graph r f a)
instance (Show r, Show f, Show a, Ord r, Ord f, Dioid a) => Dioid (Edge' r f a)
instance (Ord r, Ord f, Top a) => Top (Edge' r f a)
instance (Show r, Show f, Show a, Ord r, Ord f, MeetSemiLattice a) => MeetSemiLattice (Edge' r f a)
instance Negative a => Negative (Edge' r f a)
instance (Show rigid, Show flex) => Show (Node rigid flex)
instance Dioid Label
instance Dioid Cmp
instance Dioid Weight
instance Top Label
instance MeetSemiLattice Label
instance Show Label
instance Ord Label
instance Eq Label
instance Negative Label
instance Negative Weight
instance Negative Int
instance Plus Weight Offset Weight
instance Num Weight
instance Enum Weight
instance Top Weight
instance MeetSemiLattice Weight
instance Ord Weight
instance Show Weight
instance MeetSemiLattice Offset

module Agda.TypeChecking.SizedTypes.Tests
type Relation a = a -> a -> Bool
class AsWeightRelation b
eval :: AsWeightRelation b => b -> Relation Weight
prop_MeetSound :: Label -> Label -> Weight -> Weight -> Property
prop_MeetComplete :: Label -> Label -> Weight -> Weight -> Property
prop_ComposeSound :: Label -> Label -> Weight -> Weight -> Weight -> Property
prop_ComposeComplete :: Label -> Label -> Int -> Weight -> Property
propCommutative :: Eq b => (a -> a -> b) -> a -> a -> Bool
propAssociative :: Eq a => (a -> a -> a) -> a -> a -> a -> Bool
propIdempotent :: Eq a => (a -> a -> a) -> a -> Bool
propUnit :: Eq a => (a -> a -> a) -> a -> a -> Bool
propZero :: Eq a => (a -> a -> a) -> a -> a -> Bool
propDistL :: Eq b => (a -> b -> b) -> (b -> b -> b) -> a -> b -> b -> Bool
propDistR :: Eq a => (a -> b -> a) -> (a -> a -> a) -> a -> a -> b -> Bool
propDistributive :: Eq a => (a -> a -> a) -> (a -> a -> a) -> a -> a -> a -> Bool
propSemiLattice :: Eq a => (a -> a -> a) -> a -> a -> a -> Bool
propBoundedSemiLattice :: Eq a => (a -> a -> a) -> a -> a -> a -> a -> Bool
propMonoid :: Eq a => (a -> a -> a) -> a -> a -> a -> a -> Bool
propDioid :: Eq a => (a -> a -> a) -> a -> (a -> a -> a) -> a -> a -> a -> a -> Bool

-- | Properties of <a>Dioid</a> class.
propDioid_Gen :: Dioid a => a -> a -> a -> Bool

-- | <tt>Weight</tt> instance.
prop_Dioid_Weight :: Weight -> Weight -> Weight -> Bool

-- | <tt>Label</tt> instance.
prop_SemiLattice_Label :: Label -> Label -> Label -> Bool
prop_Unit_Label :: Label -> Bool
prop_BoundedSemiLattice_Label :: Label -> Label -> Label -> Bool
prop_Monoid_Label :: Label -> Label -> Label -> Bool
prop_DistL_Label :: Label -> Label -> Label -> Bool
prop_DistR_Label :: Label -> Label -> Label -> Bool
prop_Dist_Label :: Label -> Label -> Label -> Bool
prop_Zero_Label :: Label -> Bool
prop_Dioid_Label :: Label -> Label -> Label -> Bool

-- | Runs all tests starting with "prop_" in this file.
tests :: IO Bool
instance AsWeightRelation Label
instance AsWeightRelation Cmp
instance Arbitrary Label
instance Arbitrary Weight
instance Arbitrary Cmp

module Agda.Auto.NarrowingSearch
type Prio = Int
class Trav a blk | a -> blk
traverse :: (Trav a blk, Monad m) => (forall b. Trav b blk => MM b blk -> m ()) -> a -> m ()
data Term blk
Term :: a -> Term blk

-- | Result of type-checking.
data Prop blk

-- | Success.
OK :: Prop blk

-- | Definite failure.
Error :: String -> Prop blk

-- | Experimental.
AddExtraRef :: String -> (Metavar a blk) -> (Int, RefCreateEnv blk a) -> Prop blk

-- | Parallel conjunction of constraints.
And :: (Maybe [Term blk]) -> (MetaEnv (PB blk)) -> (MetaEnv (PB blk)) -> Prop blk

-- | Experimental, related to <a>mcompoint</a>. First arg is sidecondition.
Sidecondition :: (MetaEnv (PB blk)) -> (MetaEnv (PB blk)) -> Prop blk

-- | Forking proof on something that is not part of the term language. E.g.
--   whether a term will reduce or not.
Or :: Prio -> (MetaEnv (PB blk)) -> (MetaEnv (PB blk)) -> Prop blk

-- | Obsolete.
ConnectHandle :: (OKHandle blk) -> (MetaEnv (PB blk)) -> Prop blk
data OKVal
OKVal :: OKVal
type OKHandle blk = MM OKVal blk
type OKMeta blk = Metavar OKVal blk

-- | Agsy's meta variables.
--   
--   <tt>a</tt> the type of the metavariable (what it can be instantiated
--   with). <tt>blk</tt> the search control information (e.g. the scope of
--   the meta).
data Metavar a blk
Metavar :: IORef (Maybe a) -> IORef Bool -> IORef [(QPB a blk, Maybe (CTree blk))] -> IORef [SubConstraints blk] -> IORef [(Int, RefCreateEnv blk a)] -> Metavar a blk

-- | Maybe an instantiation (refinement). It is usually shallow, i.e., just
--   one construct(or) with arguments again being metas.
mbind :: Metavar a blk -> IORef (Maybe a)

-- | Does this meta block a principal constraint (i.e., a type-checking
--   constraint).
mprincipalpresent :: Metavar a blk -> IORef Bool

-- | List of observers, i.e., constraints blocked by this meta.
mobs :: Metavar a blk -> IORef [(QPB a blk, Maybe (CTree blk))]

-- | Used for experiments with independence of subproofs.
mcompoint :: Metavar a blk -> IORef [SubConstraints blk]

-- | Experimental.
mextrarefs :: Metavar a blk -> IORef [(Int, RefCreateEnv blk a)]
hequalMetavar :: Metavar a1 blk1 -> Metavar a2 bkl2 -> Bool
newMeta :: IORef [SubConstraints blk] -> IO (Metavar a blk)
initMeta :: IO (Metavar a blk)
data CTree blk
CTree :: IORef (PrioMeta blk) -> IORef (Maybe (SubConstraints blk)) -> IORef (Maybe (CTree blk)) -> IORef [OKMeta blk] -> CTree blk
ctpriometa :: CTree blk -> IORef (PrioMeta blk)
ctsub :: CTree blk -> IORef (Maybe (SubConstraints blk))
ctparent :: CTree blk -> IORef (Maybe (CTree blk))
cthandles :: CTree blk -> IORef [OKMeta blk]
data SubConstraints blk
SubConstraints :: IORef Bool -> IORef Int -> CTree blk -> CTree blk -> SubConstraints blk
scflip :: SubConstraints blk -> IORef Bool
sccomcount :: SubConstraints blk -> IORef Int
scsub1 :: SubConstraints blk -> CTree blk
scsub2 :: SubConstraints blk -> CTree blk
newCTree :: Maybe (CTree blk) -> IO (CTree blk)
newSubConstraints :: CTree blk -> IO (SubConstraints blk)
data PrioMeta blk
PrioMeta :: Prio -> (Metavar a blk) -> PrioMeta blk
NoPrio :: Bool -> PrioMeta blk
data Restore
Restore :: (IORef a) -> a -> Restore
type Undo = StateT [Restore] IO
ureadIORef :: IORef a -> Undo a
uwriteIORef :: IORef a -> a -> Undo ()
umodifyIORef :: IORef a -> (a -> a) -> Undo ()
ureadmodifyIORef :: IORef a -> (a -> a) -> Undo a
runUndo :: Undo a -> IO a
type RefCreateEnv blk = StateT (IORef [SubConstraints blk], Int) IO
data Pair a b
Pair :: a -> b -> Pair a b
class Refinable a blk
refinements :: Refinable a blk => blk -> [blk] -> Metavar a blk -> IO [(Int, RefCreateEnv blk a)]
newPlaceholder :: RefCreateEnv blk (MM a blk)
newOKHandle :: RefCreateEnv blk (OKHandle blk)
dryInstantiate :: RefCreateEnv blk a -> IO a
type BlkInfo blk = (Bool, Prio, Maybe blk)
data MM a blk
NotM :: a -> MM a blk
Meta :: (Metavar a blk) -> MM a blk
type MetaEnv = IO
data MB a blk
NotB :: a -> MB a blk
Blocked :: (Metavar b blk) -> (MetaEnv (MB a blk)) -> MB a blk
Failed :: String -> MB a blk
data PB blk
NotPB :: (Prop blk) -> PB blk
PBlocked :: (Metavar b blk) -> (BlkInfo blk) -> (MetaEnv (PB blk)) -> PB blk
PDoubleBlocked :: (Metavar b1 blk) -> (Metavar b2 blk) -> (MetaEnv (PB blk)) -> PB blk
data QPB b blk
QPBlocked :: (BlkInfo blk) -> (MetaEnv (PB blk)) -> QPB b blk
QPDoubleBlocked :: (IORef Bool) -> (MetaEnv (PB blk)) -> QPB b blk
mmcase :: Refinable a blk => MM a blk -> (a -> MetaEnv (MB b blk)) -> MetaEnv (MB b blk)
mmmcase :: Refinable a blk => MM a blk -> MetaEnv (MB b blk) -> (a -> MetaEnv (MB b blk)) -> MetaEnv (MB b blk)
mmpcase :: Refinable a blk => BlkInfo blk -> MM a blk -> (a -> MetaEnv (PB blk)) -> MetaEnv (PB blk)
doubleblock :: (Refinable a blk, Refinable b blk) => MM a blk -> MM b blk -> MetaEnv (PB blk) -> MetaEnv (PB blk)
mbcase :: MetaEnv (MB a blk) -> (a -> MetaEnv (MB b blk)) -> MetaEnv (MB b blk)
mbpcase :: Prio -> Maybe blk -> MetaEnv (MB a blk) -> (a -> MetaEnv (PB blk)) -> MetaEnv (PB blk)
mmbpcase :: MetaEnv (MB a blk) -> (forall b. Refinable b blk => MM b blk -> MetaEnv (PB blk)) -> (a -> MetaEnv (PB blk)) -> MetaEnv (PB blk)
waitok :: OKHandle blk -> MetaEnv (MB b blk) -> MetaEnv (MB b blk)
mbret :: a -> MetaEnv (MB a blk)
mbfailed :: String -> MetaEnv (MB a blk)
mpret :: Prop blk -> MetaEnv (PB blk)
expandbind :: MM a blk -> MetaEnv (MM a blk)
type HandleSol = IO ()
type SRes = Either Bool Int
topSearch :: IORef Int -> IORef Int -> HandleSol -> blk -> MetaEnv (PB blk) -> Int -> Int -> IO Bool
extractblkinfos :: Metavar a blk -> IO [blk]
recalcs :: [(QPB a blk, Maybe (CTree blk))] -> Undo Bool
seqc :: Undo Bool -> Undo Bool -> Undo Bool
recalc :: (QPB a blk, Maybe (CTree blk)) -> Undo Bool
reccalc :: MetaEnv (PB blk) -> Maybe (CTree blk) -> Undo Bool
calc :: MetaEnv (PB blk) -> Maybe (CTree blk) -> Undo (Maybe [OKMeta blk])
choosePrioMeta :: Bool -> PrioMeta blk -> PrioMeta blk -> PrioMeta blk
propagatePrio :: CTree blk -> Undo [OKMeta blk]
data Choice
LeftDisjunct :: Choice
RightDisjunct :: Choice
choose :: MM Choice blk -> Prio -> MetaEnv (PB blk) -> MetaEnv (PB blk) -> MetaEnv (PB blk)
instance Refinable OKVal blk
instance Refinable Choice blk
instance Eq (PrioMeta blk)
instance Eq (Metavar a blk)
instance Trav a blk => Trav (MM a blk) blk

module Agda.Auto.Syntax

-- | Unique identifiers for variable occurrences in unification.
type UId o = Metavar (Exp o) (RefInfo o)
data HintMode
HMNormal :: HintMode
HMRecCall :: HintMode
data EqReasoningConsts o
EqReasoningConsts :: ConstRef o -> ConstRef o -> ConstRef o -> ConstRef o -> ConstRef o -> ConstRef o -> EqReasoningConsts o
eqrcId :: EqReasoningConsts o -> ConstRef o
eqrcBegin :: EqReasoningConsts o -> ConstRef o
eqrcStep :: EqReasoningConsts o -> ConstRef o
eqrcEnd :: EqReasoningConsts o -> ConstRef o
eqrcSym :: EqReasoningConsts o -> ConstRef o
eqrcCong :: EqReasoningConsts o -> ConstRef o
data EqReasoningState
EqRSNone :: EqReasoningState
EqRSChain :: EqReasoningState
EqRSPrf1 :: EqReasoningState
EqRSPrf2 :: EqReasoningState
EqRSPrf3 :: EqReasoningState

-- | The concrete instance of the <tt>blk</tt> parameter in <a>Metavar</a>.
--   I.e., the information passed to the search control.
data RefInfo o
RIEnv :: [(ConstRef o, HintMode)] -> Nat -> Maybe (EqReasoningConsts o) -> RefInfo o
rieHints :: RefInfo o -> [(ConstRef o, HintMode)]

-- | Nat - deffreevars (to make cost of using module parameters correspond
--   to that of hints).
rieDefFreeVars :: RefInfo o -> Nat
rieEqReasoningConsts :: RefInfo o -> Maybe (EqReasoningConsts o)
RIMainInfo :: Nat -> HNExp o -> Bool -> RefInfo o

-- | Size of typing context in which meta was created.
riMainCxtLength :: RefInfo o -> Nat

-- | Head normal form of type of meta.
riMainType :: RefInfo o -> HNExp o

-- | True if iota steps performed when normalising target type (used to put
--   cost when traversing a definition by construction instantiation).
riMainIota :: RefInfo o -> Bool
RIUnifInfo :: [CAction o] -> (HNExp o) -> RefInfo o
RICopyInfo :: (ICExp o) -> RefInfo o
RIIotaStep :: Bool -> RefInfo o
RIInferredTypeUnknown :: RefInfo o
RINotConstructor :: RefInfo o
RIUsedVars :: [UId o] -> [Elr o] -> RefInfo o
RIPickSubsvar :: RefInfo o
RIEqRState :: EqReasoningState -> RefInfo o
RICheckElim :: Bool -> RefInfo o
RICheckProjIndex :: [ConstRef o] -> RefInfo o
type MyPB o = PB (RefInfo o)
type MyMB a o = MB a (RefInfo o)
type Nat = Int

-- | <tt>Hiding</tt> in Agda.
data FMode
Hidden :: FMode
Instance :: FMode
NotHidden :: FMode
data MId
Id :: String -> MId
NoId :: MId
stringToMyId :: String -> MId

-- | Abstraction with maybe a name.
--   
--   Different from Agda, where there is also info whether function is
--   constant.
data Abs a
Abs :: MId -> a -> Abs a

-- | Constant signatures.
data ConstDef o
ConstDef :: String -> o -> MExp o -> DeclCont o -> Nat -> ConstDef o

-- | For debug printing.
cdname :: ConstDef o -> String

-- | Reference to the Agda constant.
cdorigin :: ConstDef o -> o

-- | Type of constant.
cdtype :: ConstDef o -> MExp o

-- | Constant definition.
cdcont :: ConstDef o -> DeclCont o

-- | Free vars of the module where the constant is defined..
cddeffreevars :: ConstDef o -> Nat

-- | Constant definitions.
data DeclCont o
Def :: Nat -> [Clause o] -> (Maybe Nat) -> (Maybe Nat) -> DeclCont o
Datatype :: [ConstRef o] -> [ConstRef o] -> DeclCont o
Constructor :: Nat -> DeclCont o
Postulate :: DeclCont o
type Clause o = ([Pat o], MExp o)
data Pat o
PatConApp :: (ConstRef o) -> [Pat o] -> Pat o
PatVar :: String -> Pat o

-- | Dot pattern.
PatExp :: Pat o
type ConstRef o = IORef (ConstDef o)

-- | Head of application (elimination).
data Elr o
Var :: Nat -> Elr o
Const :: (ConstRef o) -> Elr o
data Sort
Set :: Nat -> Sort
UnknownSort :: Sort
Type :: Sort

-- | Agsy's internal syntax.
data Exp o
App :: Maybe (UId o) -> OKHandle (RefInfo o) -> Elr o -> MArgList o -> Exp o

-- | Unique identifier of the head.
appUId :: Exp o -> Maybe (UId o)

-- | This application has been type-checked.
appOK :: Exp o -> OKHandle (RefInfo o)

-- | Head.
appHead :: Exp o -> Elr o

-- | Arguments.
appElims :: Exp o -> MArgList o

-- | Lambda with hiding information.
Lam :: FMode -> (Abs (MExp o)) -> Exp o

-- | <tt>True</tt> if possibly dependent (var not known to not occur).
--   <tt>False</tt> if non-dependent.
Pi :: (Maybe (UId o)) -> FMode -> Bool -> (MExp o) -> (Abs (MExp o)) -> Exp o
Sort :: Sort -> Exp o

-- | Absurd lambda with hiding information.
AbsurdLambda :: FMode -> Exp o
dontCare :: Exp o

-- | "Maybe expression": Expression or reference to meta variable.
type MExp o = MM (Exp o) (RefInfo o)
data ArgList o

-- | No more eliminations.
ALNil :: ArgList o

-- | Application and tail.
ALCons :: FMode -> (MExp o) -> (MArgList o) -> ArgList o

-- | proj pre args, projfcn idx, tail
ALProj :: (MArgList o) -> (MM (ConstRef o) (RefInfo o)) -> FMode -> (MArgList o) -> ArgList o

-- | Constructor parameter (missing in Agda). Agsy has monomorphic
--   constructors. Inserted to cover glitch of polymorphic constructor
--   applications coming from Agda
ALConPar :: (MArgList o) -> ArgList o
type MArgList o = MM (ArgList o) (RefInfo o)
data HNExp o
HNApp :: [Maybe (UId o)] -> (Elr o) -> (ICArgList o) -> HNExp o
HNLam :: [Maybe (UId o)] -> FMode -> (Abs (ICExp o)) -> HNExp o
HNPi :: [Maybe (UId o)] -> FMode -> Bool -> (ICExp o) -> (Abs (ICExp o)) -> HNExp o
HNSort :: Sort -> HNExp o

-- | Head-normal form of <a>ICArgList</a>. First entry is exposed.
--   
--   Q: Why are there no projection eliminations?
data HNArgList o
HNALNil :: HNArgList o
HNALCons :: FMode -> (ICExp o) -> (ICArgList o) -> HNArgList o
HNALConPar :: (ICArgList o) -> HNArgList o

-- | Lazy concatenation of argument lists under explicit substitutions.
data ICArgList o
CALNil :: ICArgList o
CALConcat :: (Clos (MArgList o) o) -> (ICArgList o) -> ICArgList o

-- | An expression <tt>a</tt> in an explicit substitution <tt>[CAction
--   a]</tt>.
type ICExp o = Clos (MExp o) o
data Clos a o
Clos :: [CAction o] -> a -> Clos a o
type CExp o = TrBr (ICExp o) o
data TrBr a o
TrBr :: [MExp o] -> a -> TrBr a o

-- | Entry of an explicit substitution.
--   
--   An explicit substitution is a list of <tt>CAction</tt>s. This is
--   isomorphic to the usual presentation where <tt>Skip</tt> and
--   <tt>Weak</tt> would be constructors of exp. substs.
data CAction o

-- | Instantation of variable.
Sub :: (ICExp o) -> CAction o

-- | For going under a binder, often called <a>Lift</a>.
Skip :: CAction o

-- | Shifting substitution (going to a larger context).
Weak :: Nat -> CAction o
type Ctx o = [(MId, CExp o)]
type EE = IO
detecteliminand :: [Clause o] -> Maybe Nat
detectsemiflex :: ConstRef o -> [Clause o] -> IO Bool
categorizedecl :: ConstRef o -> IO ()
metaliseokh :: MExp o -> IO (MExp o)
expandExp :: MExp o -> IO (MExp o)
addtrailingargs :: Clos (MArgList o) o -> ICArgList o -> ICArgList o
closify :: MExp o -> CExp o
sub :: MExp o -> CExp o -> CExp o
subi :: MExp o -> ICExp o -> ICExp o
weak :: Nat -> CExp o -> CExp o
weaki :: Nat -> Clos a o -> Clos a o
weakarglist :: Nat -> ICArgList o -> ICArgList o
weakelr :: Nat -> Elr o -> Elr o

-- | Substituting for a variable.
doclos :: [CAction o] -> Nat -> Either Nat (ICExp o)
instance Eq EqReasoningState
instance Show EqReasoningState
instance Eq FMode

module Agda.Auto.SearchControl
data ExpRefInfo o
ExpRefInfo :: Maybe (RefInfo o) -> [RefInfo o] -> Bool -> Bool -> Maybe ([UId o], [Elr o]) -> Maybe Bool -> Bool -> Maybe EqReasoningState -> ExpRefInfo o
eriMain :: ExpRefInfo o -> Maybe (RefInfo o)
eriUnifs :: ExpRefInfo o -> [RefInfo o]
eriInfTypeUnknown :: ExpRefInfo o -> Bool
eriIsEliminand :: ExpRefInfo o -> Bool
eriUsedVars :: ExpRefInfo o -> Maybe ([UId o], [Elr o])
eriIotaStep :: ExpRefInfo o -> Maybe Bool
eriPickSubsVar :: ExpRefInfo o -> Bool
eriEqRState :: ExpRefInfo o -> Maybe EqReasoningState
getinfo :: [RefInfo o] -> ExpRefInfo o
univar :: [CAction o] -> Nat -> Maybe Nat
subsvars :: [CAction o] -> [Nat]
extraref :: UId o -> [Maybe (UId o)] -> ConstRef o -> (Int, StateT (IORef [SubConstraints (RefInfo o)], Int) IO (Exp o))
costIncrease :: Int
costAbsurdLam :: Int
costInferredTypeUnkown :: Int
costIotaStep :: Int
costSort :: Int
costPi :: Int
costLamUnfold :: Int
costLam :: Int
costAppExtraRef :: Int
costAppConstructorSingle :: Int
costAppConstructor :: Int
costAppRecCallUsed :: Int
costAppRecCall :: Int
costAppHintUsed :: Int
costAppHint :: Int
costAppVarUsed :: Int
costAppVar :: Int
costUnification :: Int
costUnificationOccurs :: Int
costEqStep :: Int
costEqCong :: Int
costEqSym :: Int
costEqEnd :: Int
prioNo :: Int
prioProjIndex :: Int
prioAbsurdLambda :: Int
prioNoIota :: Int
prioCompCopy :: Int
prioCompUnif :: Int
prioCompChoice :: Int
prioCompIota :: Int
prioCompareArgList :: Int
prioCompBetaStructured :: Int
prioCompBeta :: Int
prioInferredTypeUnknown :: Int
prioTypecheckArgList :: Int
prioTypeUnknown :: Int
prioTypecheck :: Bool -> Int
instance Trav (ArgList o) (RefInfo o)
instance Trav (Exp o) (RefInfo o)
instance Trav (TrBr a o) (RefInfo o)
instance Trav (MId, CExp o) (RefInfo o)
instance Trav a blk => Trav [a] blk
instance Refinable (ConstRef o) (RefInfo o)
instance Refinable (ICExp o) (RefInfo o)
instance Refinable (Exp o) (RefInfo o)
instance Refinable (ArgList o) (RefInfo o)

module Agda.Auto.Typecheck

-- | Typechecker drives the solution of metas.
tcExp :: Bool -> Ctx o -> CExp o -> MExp o -> EE (MyPB o)
getDatatype :: ICExp o -> EE (MyMB (Maybe (ICArgList o, [ConstRef o])) o)
constructorImpossible :: ICArgList o -> ConstRef o -> EE (MyPB o)
unequals :: ICArgList o -> ICArgList o -> ([(Nat, HNExp o)] -> EE (MyPB o)) -> [(Nat, HNExp o)] -> EE (MyPB o)
unequal :: ICExp o -> ICExp o -> ([(Nat, HNExp o)] -> EE (MyPB o)) -> [(Nat, HNExp o)] -> EE (MyPB o)
traversePi :: Int -> ICExp o -> EE (MyMB (HNExp o) o)
tcargs :: Nat -> Bool -> Ctx o -> CExp o -> MArgList o -> MExp o -> Bool -> (CExp o -> MExp o -> EE (MyPB o)) -> EE (MyPB o)
addend :: FMode -> MExp o -> MM (Exp o) blk -> MM (Exp o) blk
copyarg :: MExp o -> Bool
type HNNBlks o = [HNExp o]
noblks :: HNNBlks o
addblk :: HNExp o -> HNNBlks o -> HNNBlks o
hnn :: ICExp o -> EE (MyMB (HNExp o) o)
hnn_blks :: ICExp o -> EE (MyMB (HNExp o, HNNBlks o) o)
hnn_checkstep :: ICExp o -> EE (MyMB (HNExp o, Bool) o)
hnn' :: ICExp o -> ICArgList o -> EE (MyMB (HNExp o, HNNBlks o) o)
hnb :: ICExp o -> ICArgList o -> EE (MyMB (HNExp o) o)
data HNRes o
HNDone :: (Maybe (Metavar (Exp o) (RefInfo o))) -> (HNExp o) -> HNRes o
HNMeta :: (ICExp o) -> (ICArgList o) -> [Maybe (UId o)] -> HNRes o
hnc :: Bool -> ICExp o -> ICArgList o -> [Maybe (UId o)] -> EE (MyMB (HNRes o) o)
hnarglist :: ICArgList o -> EE (MyMB (HNArgList o) o)
getNArgs :: Nat -> ICArgList o -> EE (MyMB (Maybe ([ICExp o], ICArgList o)) o)
getAllArgs :: ICArgList o -> EE (MyMB [ICExp o] o)
data PEval o
PENo :: (ICExp o) -> PEval o
PEConApp :: (ICExp o) -> (ConstRef o) -> [PEval o] -> PEval o
iotastep :: Bool -> HNExp o -> EE (MyMB (Either (ICExp o, ICArgList o) (HNNBlks o)) o)
noiotastep :: HNExp o -> EE (MyPB o)
noiotastep_term :: ConstRef o -> MArgList o -> EE (MyPB o)
data CMode o
CMRigid :: (Maybe (Metavar (Exp o) (RefInfo o))) -> (HNExp o) -> CMode o
CMFlex :: (MM b (RefInfo o)) -> (CMFlex o) -> CMode o
data CMFlex o
CMFFlex :: (ICExp o) -> (ICArgList o) -> [Maybe (UId o)] -> CMFlex o
CMFSemi :: (Maybe (Metavar (Exp o) (RefInfo o))) -> (HNExp o) -> CMFlex o
CMFBlocked :: (Maybe (Metavar (Exp o) (RefInfo o))) -> (HNExp o) -> CMFlex o
comp' :: Bool -> CExp o -> CExp o -> EE (MyPB o)
checkeliminand :: MExp o -> EE (MyPB o)
maybeor :: Bool -> Int -> IO (PB (RefInfo o)) -> IO (PB (RefInfo o)) -> IO (PB (RefInfo o))
iotapossmeta :: ICExp o -> ICArgList o -> EE Bool
meta_not_constructor :: ICExp o -> EE (MB Bool (RefInfo o))
calcEqRState :: EqReasoningConsts o -> MExp o -> EE (MyPB o)
pickid :: MId -> MId -> MId
tcSearch :: Bool -> Ctx o -> CExp o -> MExp o -> EE (MyPB o)

module Agda.Auto.CaseSplit
abspatvarname :: String
costCaseSplitVeryHigh :: Nat
costAddVarDepth :: Nat
costCaseSplitLow :: Nat
costCaseSplitHigh :: Nat
data HI a
HI :: FMode -> a -> HI a
drophid :: [HI a] -> [a]
type CSPat o = HI (CSPatI o)
type CSCtx o = [HI (MId, MExp o)]
data CSPatI o
CSPatConApp :: (ConstRef o) -> [CSPat o] -> CSPatI o
CSPatVar :: Nat -> CSPatI o
CSPatExp :: (MExp o) -> CSPatI o
CSWith :: (MExp o) -> CSPatI o
CSAbsurd :: CSPatI o
CSOmittedArg :: CSPatI o
type Sol o = [(CSCtx o, [CSPat o], Maybe (MExp o))]
caseSplitSearch :: IORef Int -> Int -> [ConstRef o] -> Maybe (EqReasoningConsts o) -> Int -> Int -> ConstRef o -> CSCtx o -> MExp o -> [CSPat o] -> IO [Sol o]
caseSplitSearch' :: (Int -> CSCtx o -> MExp o -> ([Nat], Nat, [Nat]) -> IO (Maybe (MExp o))) -> Int -> Int -> ConstRef o -> CSCtx o -> MExp o -> [CSPat o] -> IO [Sol o]
infertypevar :: CSCtx o -> Nat -> MExp o
replace :: Nat -> Nat -> MExp o -> MExp o -> MExp o
betareduce :: MExp o -> MArgList o -> MExp o
concatargs :: MM (ArgList o) (RefInfo o) -> MArgList o -> MArgList o
eqelr :: Elr o -> Elr o -> Bool
replacep :: Nat -> Nat -> CSPatI o -> MExp o -> CSPat o -> CSPat o
rm :: MM a b -> a
mm :: a -> MM a b
unifyexp :: MExp o -> MExp o -> Maybe [(Nat, MExp o)]
lift :: Nat -> MExp o -> MExp o
removevar :: CSCtx o -> MExp o -> [CSPat o] -> [(Nat, MExp o)] -> (CSCtx o, MExp o, [CSPat o])
notequal :: Nat -> Nat -> MExp o -> MExp o -> IO Bool
findperm :: [MExp o] -> Maybe [Nat]
freevars :: MExp o -> [Nat]
applyperm :: [Nat] -> CSCtx o -> MExp o -> [CSPat o] -> (CSCtx o, MExp o, [CSPat o])
ren :: [Nat] -> Nat -> Int
rename :: (Nat -> Nat) -> MExp o -> MExp o
renamep :: (Nat -> Nat) -> CSPat o -> CSPat o
seqctx :: CSCtx o -> CSCtx o
depthofvar :: Nat -> [CSPat o] -> Nat
localTerminationEnv :: [CSPat o] -> ([Nat], Nat, [Nat])
localTerminationSidecond :: ([Nat], Nat, [Nat]) -> ConstRef o -> MExp o -> EE (MyPB o)
getblks :: MExp o -> IO [Nat]


-- | Wrapper for Control.Monad.Except from the mtl package
module Agda.Utils.Except

-- | An exception to be thrown.
--   
--   Minimal complete definition: <a>noMsg</a> or <a>strMsg</a>.
class Error a
noMsg :: Error a => a
strMsg :: Error a => String -> a
type ExceptT = ErrorT

-- | We cannot define data constructors synonymous, so we define the
--   <tt>mkExceptT</tt> function to be used instead of the data constructor
--   <tt>ErrorT</tt>.
mkExceptT :: m (Either e a) -> ExceptT e m a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>Error</a> and/or <a>MonadError</a> classes.
class Monad m => MonadError e (m :: * -> *) | m -> e
throwError :: MonadError e m => e -> m a
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | <tt>runExcept</tt> function using mtl 2.1.*.
runExceptT :: ExceptT e m a -> m (Either e a)

module Agda.Version

-- | The version of Agda.
version :: String


-- | Strict tries (based on <a>Strict</a> and <a>Strict</a>).
module Agda.Utils.Trie

-- | Finite map from <tt>[k]</tt> to <tt>v</tt>.
--   
--   With the strict <a>Maybe</a> type, <a>Trie</a> is also strict in
--   <tt>v</tt>.
data Trie k v

-- | Empty trie.
empty :: Trie k v

-- | Singleton trie.
singleton :: [k] -> v -> Trie k v

-- | Insert. Overwrites existing value if present.
--   
--   <pre>
--   insert = insertWith ( new old -&gt; new)
--   </pre>
insert :: Ord k => [k] -> v -> Trie k v -> Trie k v

-- | Insert with function merging new value with old value.
insertWith :: Ord k => (v -> v -> v) -> [k] -> v -> Trie k v -> Trie k v

-- | Left biased union.
--   
--   <tt>union = unionWith ( new old -&gt; new)</tt>.
union :: Ord k => Trie k v -> Trie k v -> Trie k v

-- | Pointwise union with merge function for values.
unionWith :: Ord k => (v -> v -> v) -> Trie k v -> Trie k v -> Trie k v

-- | Adjust value at key, leave subtree intact.
adjust :: Ord k => [k] -> (Maybe v -> Maybe v) -> Trie k v -> Trie k v

-- | Delete value at key, but leave subtree intact.
delete :: Ord k => [k] -> Trie k v -> Trie k v

-- | Convert to ascending list.
toList :: Ord k => Trie k v -> [([k], v)]

-- | Convert to ascending list.
toAscList :: Ord k => Trie k v -> [([k], v)]

-- | Collect all values along a given path.
lookupPath :: Ord k => [k] -> Trie k v -> [v]
instance (Show k, Show v) => Show (Trie k v)
instance Eq Key
instance Ord Key
instance Eq Val
instance Eq Model
instance Show Model
instance Arbitrary Model
instance Arbitrary Val
instance Arbitrary Key
instance Show Val
instance Show Key

module Agda.Utils.String

-- | <a>quote</a> adds double quotes around the string, replaces newline
--   characters with <tt>n</tt>, and escapes double quotes and backslashes
--   within the string. This is different from the behaviour of
--   <a>show</a>:
--   
--   <pre>
--   &gt; <a>putStrLn</a> $ <a>show</a> "\x2200"
--   "\8704"
--   &gt; <a>putStrLn</a> $ <a>quote</a> "\x2200"
--   "∀"
--   </pre>
--   
--   (The code examples above have been tested using version 4.2.0.0 of the
--   base library.)
quote :: String -> String

-- | Shows a non-negative integer using the characters ₀-₉ instead of 0-9.
showIndex :: (Show i, Integral i) => i -> String

-- | Adds a final newline if there is not already one.
addFinalNewLine :: String -> String

-- | Indents every line the given number of steps.
indent :: Integral i => i -> String -> String
newtype Str
Str :: String -> Str
unStr :: Str -> String

-- | Show a number using comma to separate powers of 1,000.
showThousandSep :: Show a => a -> String
instance Eq Str
instance Show Str


-- | Pretty printing functions.
module Agda.Utils.Pretty

-- | While <a>Show</a> is for rendering data in Haskell syntax,
--   <a>Pretty</a> is for displaying data to the world, i.e., the user and
--   the environment.
--   
--   Atomic data has no inner document structure, so just implement
--   <a>pretty</a> as <tt>pretty a = text $ ... a ...</tt>.
class Pretty a where pretty = prettyPrec 0 prettyPrec = const pretty
pretty :: Pretty a => a -> Doc
prettyPrec :: Pretty a => Int -> a -> Doc

-- | Use instead of <a>show</a> when printing to world.
prettyShow :: Pretty a => a -> String
pwords :: String -> [Doc]
fwords :: String -> Doc
mparens :: Bool -> Doc -> Doc

-- | <tt>align max rows</tt> lays out the elements of <tt>rows</tt> in two
--   columns, with the second components aligned. The alignment column of
--   the second components is at most <tt>max</tt> characters to the right
--   of the left-most column.
--   
--   Precondition: <tt>max &gt; 0</tt>.
align :: Int -> [(String, Doc)] -> Doc
instance Eq Doc
instance Pretty Doc
instance Pretty String
instance Pretty Char
instance Pretty Integer
instance Pretty Int32
instance Pretty Int


-- | Code for instructing Emacs to do things
module Agda.Interaction.EmacsCommand

-- | Simple Emacs Lisp expressions.
data Lisp a

-- | Atom.
A :: a -> Lisp a
Cons :: (Lisp a) -> (Lisp a) -> Lisp a

-- | List.
L :: [Lisp a] -> Lisp a
Q :: (Lisp a) -> Lisp a

-- | Formats a response command.
--   
--   Replaces <tt>'\n'</tt> with spaces to ensure that each command is a
--   single line.
response :: Lisp String -> String

-- | Writes a response command to standard output.
putResponse :: Lisp String -> IO ()

-- | <tt>display_info' append header content</tt> displays <tt>content</tt>
--   (with header <tt>header</tt>) in some suitable way. If <tt>append</tt>
--   is <tt>True</tt>, then the content is appended to previous content (if
--   any), otherwise any previous content is deleted.
display_info' :: Bool -> String -> String -> Lisp String

-- | Clear the running info buffer.
clearRunningInfo :: Lisp String

-- | Display running information about what the type-checker is up to.
displayRunningInfo :: String -> Lisp String
instance Pretty a => Show (Lisp a)
instance Pretty a => Pretty (Lisp a)


-- | Time-related utilities.
module Agda.Utils.Time

-- | Timestamps.
type ClockTime = UTCTime

-- | The current time.
getClockTime :: IO ClockTime

-- | Measure the time of a computation. Returns the
measureTime :: MonadIO m => m a -> m (a, CPUTime)

-- | CPU time in pico (10^-12) seconds.
newtype CPUTime
CPUTime :: Integer -> CPUTime
instance Eq CPUTime
instance Show CPUTime
instance Ord CPUTime
instance Num CPUTime
instance Real CPUTime
instance Enum CPUTime
instance Integral CPUTime
instance Pretty CPUTime


-- | Data structures for collecting CPU usage.
module Agda.TypeChecking.Monad.Base.Benchmark

-- | Phases to allocate CPU time to.
data Phase

-- | Happy parsing and operator parsing.
Parsing :: Phase

-- | Import chasing.
Import :: Phase

-- | Reading interface files.
Deserialization :: Phase

-- | Scope checking and translation to abstract syntax.
Scoping :: Phase

-- | Type checking and translation to internal syntax.
Typing :: Phase

-- | Termination checking.
Termination :: Phase

-- | Positivity checking and polarity computation.
Positivity :: Phase

-- | Injectivity checking.
Injectivity :: Phase

-- | Checking for projection likeness.
ProjectionLikeness :: Phase

-- | Coverage checking and compilation to case trees.
Coverage :: Phase

-- | Generating highlighting info.
Highlighting :: Phase

-- | Writing interface files.
Serialization :: Phase

-- | Subphase for <a>Termination</a>.
Graph :: Phase

-- | Subphase for <a>Termination</a>.
RecCheck :: Phase

-- | Subphase for <a>Termination</a>.
Reduce :: Phase

-- | Subphase for <a>Termination</a>.
Level :: Phase

-- | Subphase for <a>Termination</a>.
Compare :: Phase

-- | Subphase for <a>Termination</a>.
With :: Phase

-- | Subphase for <a>Import</a>.
ModuleName :: Phase

-- | Subphase for <tt>Serialize</tt>.
Sort :: Phase

-- | Subphase for <tt>Serialize</tt>.
BinaryEncode :: Phase

-- | Subphase for <tt>Serialize</tt>.
Compress :: Phase

-- | Subphase for <a>Parsing</a>.
Operators :: Phase

-- | Subphase for <a>Operators</a>.
BuildParser :: Phase

-- | Account we can bill computation time to. A word of <a>Phase</a>s.
type Account = [Phase]

-- | Benchmark structure is a trie, mapping accounts (phases and subphases)
--   to CPU time spent on their performance.
type Benchmark = Trie Phase CPUTime

-- | Initial benchmark structure (empty).
empty :: Benchmark

-- | Add to specified CPU time account.
addCPUTime :: Account -> CPUTime -> Benchmark -> Benchmark
instance Eq Phase
instance Ord Phase
instance Show Phase
instance Enum Phase
instance Bounded Phase

module Agda.Utils.Monad

-- | <tt>when_</tt> is just <tt>Control.Monad.when</tt> with a more general
--   type.
when_ :: Monad m => Bool -> m a -> m ()

-- | <tt>unless_</tt> is just <tt>Control.Monad.unless</tt> with a more
--   general type.
unless_ :: Monad m => Bool -> m a -> m ()
whenM :: Monad m => m Bool -> m a -> m ()
unlessM :: Monad m => m Bool -> m a -> m ()

-- | Monadic if-then-else.
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | <pre>
--   ifNotM mc = ifM (not <a>$</a> mc)
--   </pre>
ifNotM :: Monad m => m Bool -> m a -> m a -> m a

-- | Lazy monadic conjunction.
and2M :: Monad m => m Bool -> m Bool -> m Bool
andM :: Monad m => [m Bool] -> m Bool

-- | Lazy monadic disjunction.
or2M :: Monad m => m Bool -> m Bool -> m Bool
orM :: Monad m => [m Bool] -> m Bool

-- | Lazy monadic disjunction with <tt>Either</tt> truth values.
altM1 :: Monad m => (a -> m (Either err b)) -> [a] -> m (Either err b)

-- | Generalized version of <tt>mapM_ :: Monad m =&gt; (a -&gt; m ()) -&gt;
--   [a] -&gt; m ()</tt> Executes effects and collects results in
--   left-to-right order. Works best with left-associative monoids.
--   
--   Note that there is an alternative
--   
--   <pre>
--   mapM' f t = foldr mappend mempty <a>$</a> mapM f t
--   </pre>
--   
--   that collects results in right-to-left order (effects still
--   left-to-right). It might be preferable for right associative monoids.
mapM' :: (Foldable t, Monad m, Monoid b) => (a -> m b) -> t a -> m b

-- | Generalized version of <tt>forM_ :: Monad m =&gt; [a] -&gt; (a -&gt; m
--   ()) -&gt; m ()</tt>
forM' :: (Foldable t, Monad m, Monoid b) => t a -> (a -> m b) -> m b
type Cont r a = (a -> r) -> r

-- | <a>mapM</a> for the continuation monad. Terribly useful.
thread :: (a -> Cont r b) -> [a] -> Cont r [b]

-- | Requires both lists to have the same lengths.
zipWithM' :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | A monadic version of <tt><a>mapMaybe</a> :: (a -&gt; Maybe b) -&gt;
--   [a] -&gt; [b]</tt>.
mapMaybeM :: (Monad m, Functor m) => (a -> m (Maybe b)) -> [a] -> m [b]

-- | A monadic version of <tt><a>dropWhile</a> :: (a -&gt; Bool) -&gt; [a]
--   -&gt; [a]</tt>.
dropWhileM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | To simulate <tt>MaybeT</tt> by <tt>ExceptT</tt>.

-- | Finally for the <a>Error</a> class. Errors in the finally part take
--   precedence over prior errors.
finally :: (Error e, MonadError e m) => m a -> m b -> m a

-- | Bracket without failure. Typically used to preserve state.
bracket_ :: Monad m => m a -> (a -> m c) -> m b -> m b

-- | Restore state after computation.
localState :: MonadState s m => m a -> m a
readM :: (Error e, MonadError e m, Read a) => String -> m a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Sequential application.
(<*>) :: Applicative f => forall a b. f (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => forall a b. a -> f b -> f a
instance Error ()


-- | Overloaded <tt>null</tt> and <tt>empty</tt> for collections and
--   sequences.
module Agda.Utils.Null
class Null a
empty :: Null a => a
null :: Null a => a -> Bool
ifNull :: Null a => a -> b -> (a -> b) -> b
ifNullM :: (Monad m, Null a) => m a -> m b -> (a -> m b) -> m b
whenNull :: (Monad m, Null a) => a -> m () -> m ()
unlessNull :: (Monad m, Null a) => a -> (a -> m ()) -> m ()
whenNullM :: (Monad m, Null a) => m a -> m () -> m ()
unlessNullM :: (Monad m, Null a) => m a -> (a -> m ()) -> m ()
instance Null (Set a)
instance Null (Seq a)
instance Null (Map k a)
instance Null (IntMap a)
instance Null (Bag a)
instance Null [a]
instance Null ByteString
instance (Null a, Null b) => Null (a, b)
instance Null ()


-- | Position information for syntax. Crucial for giving good error
--   messages.
module Agda.Syntax.Position
type Position = Position' SrcFile

-- | Represents a point in the input.
--   
--   If two positions have the same <a>srcFile</a> and <a>posPos</a>
--   components, then the final two components should be the same as well,
--   but since this can be hard to enforce the program should not rely too
--   much on the last two components; they are mainly there to improve
--   error messages for the user.
--   
--   Note the invariant which positions have to satisfy:
--   <a>positionInvariant</a>.
data Position' a
Pn :: a -> !Int32 -> !Int32 -> !Int32 -> Position' a

-- | File.
srcFile :: Position' a -> a

-- | Position, counting from 1.
posPos :: Position' a -> !Int32

-- | Line number, counting from 1.
posLine :: Position' a -> !Int32

-- | Column number, counting from 1.
posCol :: Position' a -> !Int32
positionInvariant :: Position' a -> Bool

-- | The first position in a file: position 1, line 1, column 1.
startPos :: Maybe AbsolutePath -> Position

-- | Advance the position by one character. A newline character
--   (<tt>'\n'</tt>) moves the position to the first character in the next
--   line. Any other character moves the position to the next column.
movePos :: Position' a -> Char -> Position' a

-- | Advance the position by a string.
--   
--   <pre>
--   movePosByString = foldl' movePos
--   </pre>
movePosByString :: Position' a -> String -> Position' a

-- | Backup the position by one character.
--   
--   Precondition: The character must not be <tt>'\n'</tt>.
backupPos :: Position' a -> Position' a
type Interval = Interval' SrcFile

-- | An interval. The <tt>iEnd</tt> position is not included in the
--   interval.
--   
--   Note the invariant which intervals have to satisfy:
--   <a>intervalInvariant</a>.
data Interval' a
Interval :: !(Position' a) -> !(Position' a) -> Interval' a
iStart :: Interval' a -> !(Position' a)
iEnd :: Interval' a -> !(Position' a)
intervalInvariant :: Ord a => Interval' a -> Bool

-- | Extracts the interval corresponding to the given string, assuming that
--   the string starts at the beginning of the given interval.
--   
--   Precondition: The string must not be too long for the interval.
takeI :: String -> Interval' a -> Interval' a

-- | Removes the interval corresponding to the given string from the given
--   interval, assuming that the string starts at the beginning of the
--   interval.
--   
--   Precondition: The string must not be too long for the interval.
dropI :: String -> Interval' a -> Interval' a
type Range = Range' SrcFile

-- | A range is a list of intervals. The intervals should be consecutive
--   and separated.
--   
--   Note the invariant which ranges have to satisfy:
--   <a>rangeInvariant</a>.
newtype Range' a
Range :: [Interval' a] -> Range' a
rangeInvariant :: Range -> Bool

-- | Conflate a range to its right margin.
rightMargin :: Range -> Range

-- | Ranges between two unknown positions
noRange :: Range' a

-- | Converts two positions to a range.
posToRange :: Ord a => Position' a -> Position' a -> Range' a

-- | The initial position in the range, if any.
rStart :: Range' a -> Maybe (Position' a)

-- | The position after the final position in the range, if any.
rEnd :: Range' a -> Maybe (Position' a)

-- | Converts a range to an interval, if possible.
rangeToInterval :: Range' a -> Maybe (Interval' a)

-- | Returns the shortest continuous range containing the given one.
continuous :: Range' a -> Range' a

-- | Removes gaps between intervals on the same line.
continuousPerLine :: Ord a => Range' a -> Range' a

-- | Things that have a range are instances of this class.
class HasRange t
getRange :: HasRange t => t -> Range

-- | If it is also possible to set the range, this is the class.
--   
--   Instances should satisfy <tt><a>getRange</a> (<a>setRange</a> r x) ==
--   r</tt>.
class HasRange t => SetRange t
setRange :: SetRange t => Range -> t -> t

-- | Killing the range of an object sets all range information to
--   <a>noRange</a>.
class KillRange a
killRange :: KillRange a => KillRangeT a
type KillRangeT a = a -> a
killRange1 :: KillRange a => (a -> b) -> a -> b
killRange2 :: (KillRange a, KillRange b) => (a -> b -> c) -> a -> b -> c
killRange3 :: (KillRange a, KillRange b, KillRange c) => (a -> b -> c -> d) -> a -> b -> c -> d
killRange4 :: (KillRange a, KillRange b, KillRange c, KillRange d) => (a -> b -> c -> d -> e) -> a -> b -> c -> d -> e
killRange5 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e) => (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> f
killRange6 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f) => (a -> b -> c -> d -> e -> f -> g) -> a -> b -> c -> d -> e -> f -> g
killRange7 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g) => (a -> b -> c -> d -> e -> f -> g -> h) -> a -> b -> c -> d -> e -> f -> g -> h
killRange8 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> a -> b -> c -> d -> e -> f -> g -> h -> i
killRange9 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j
killRange10 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k
killRange11 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l
killRange12 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m
killRange13 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n
killRange14 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o
killRange15 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n, KillRange o) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p
killRange16 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n, KillRange o, KillRange p) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q
killRange17 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n, KillRange o, KillRange p, KillRange q) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r
killRange18 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n, KillRange o, KillRange p, KillRange q, KillRange r) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s
killRange19 :: (KillRange a, KillRange b, KillRange c, KillRange d, KillRange e, KillRange f, KillRange g, KillRange h, KillRange i, KillRange j, KillRange k, KillRange l, KillRange m, KillRange n, KillRange o, KillRange p, KillRange q, KillRange r, KillRange s) => (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t) -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t

-- | <tt>x `withRangeOf` y</tt> sets the range of <tt>x</tt> to the range
--   of <tt>y</tt>.
withRangeOf :: (SetRange t, HasRange u) => t -> u -> t
fuseRange :: (HasRange u, HasRange t) => u -> t -> Range

-- | <tt>fuseRanges r r'</tt> unions the ranges <tt>r</tt> and <tt>r'</tt>.
--   
--   Meaning it finds the least range <tt>r0</tt> that covers <tt>r</tt>
--   and <tt>r'</tt>.
fuseRanges :: Ord a => Range' a -> Range' a -> Range' a

-- | <tt>beginningOf r</tt> is an empty range (a single, empty interval)
--   positioned at the beginning of <tt>r</tt>. If <tt>r</tt> does not have
--   a beginning, then <a>noRange</a> is returned.
beginningOf :: Range -> Range

-- | <tt>beginningOfFile r</tt> is an empty range (a single, empty
--   interval) at the beginning of <tt>r</tt>'s starting position's file.
--   If there is no such position, then an empty range is returned.
beginningOfFile :: Range -> Range

-- | Test suite.
tests :: IO Bool
instance Typeable Position'
instance Typeable Interval'
instance Typeable Range'
instance Functor Position'
instance Foldable Position'
instance Traversable Position'
instance Eq a => Eq (Interval' a)
instance Ord a => Ord (Interval' a)
instance Functor Interval'
instance Foldable Interval'
instance Traversable Interval'
instance Eq a => Eq (Range' a)
instance Ord a => Ord (Range' a)
instance Functor Range'
instance Foldable Range'
instance Traversable Range'
instance Null (Range' a)
instance Show (Range' Integer)
instance Show (Interval' Integer)
instance Show (Position' Integer)
instance (Ord a, Arbitrary a) => Arbitrary (Range' a)
instance (Arbitrary a, Ord a) => Arbitrary (Interval' a)
instance Arbitrary a => Arbitrary (Position' a)
instance Pretty a => Pretty (Position' (Maybe a))
instance Show a => Show (Range' (Maybe a))
instance Show a => Show (Interval' (Maybe a))
instance Show a => Show (Position' (Maybe a))
instance (KillRange a, KillRange b) => KillRange (Either a b)
instance KillRange a => KillRange (Maybe a)
instance (KillRange a, KillRange b, KillRange c) => KillRange (a, b, c)
instance (KillRange a, KillRange b) => KillRange (a, b)
instance KillRange a => KillRange [a]
instance KillRange Int
instance KillRange Bool
instance KillRange ()
instance KillRange Range
instance SetRange Range
instance HasRange a => HasRange (Maybe a)
instance (HasRange a, HasRange b, HasRange c, HasRange d, HasRange e, HasRange f, HasRange g) => HasRange (a, b, c, d, e, f, g)
instance (HasRange a, HasRange b, HasRange c, HasRange d, HasRange e, HasRange f) => HasRange (a, b, c, d, e, f)
instance (HasRange a, HasRange b, HasRange c, HasRange d, HasRange e) => HasRange (a, b, c, d, e)
instance (HasRange a, HasRange b, HasRange c, HasRange d) => HasRange (a, b, c, d)
instance (HasRange a, HasRange b, HasRange c) => HasRange (a, b, c)
instance (HasRange a, HasRange b) => HasRange (a, b)
instance HasRange a => HasRange [a]
instance HasRange Range
instance HasRange Interval
instance Ord a => Ord (Position' a)
instance Eq a => Eq (Position' a)


-- | Ranges.
module Agda.Interaction.Highlighting.Range

-- | Character ranges. The first character in the file has position 1. Note
--   that the <a>to</a> position is considered to be outside of the range.
--   
--   Invariant: <tt><a>from</a> <a>&lt;=</a> <a>to</a></tt>.
data Range
Range :: Int -> Int -> Range
from :: Range -> Int
to :: Range -> Int

-- | The <a>Range</a> invariant.
rangeInvariant :: Range -> Bool

-- | Zero or more consecutive and separated ranges.
newtype Ranges
Ranges :: [Range] -> Ranges

-- | The <a>Ranges</a> invariant.
rangesInvariant :: Ranges -> Bool

-- | <a>True</a> iff the ranges overlap.
--   
--   The ranges are assumed to be well-formed.
overlapping :: Range -> Range -> Bool

-- | <a>True</a> iff the range is empty.
empty :: Range -> Bool

-- | Converts a range to a list of positions.
rangeToPositions :: Range -> [Int]

-- | Converts several ranges to a list of positions.
rangesToPositions :: Ranges -> [Int]

-- | Converts a <a>Range</a> to a <a>Ranges</a>.
rToR :: Range -> Ranges

-- | <tt>minus xs ys</tt> computes the difference between <tt>xs</tt> and
--   <tt>ys</tt>: the result contains those positions which are present in
--   <tt>xs</tt> but not in <tt>ys</tt>.
--   
--   Linear in the lengths of the input ranges.
minus :: Ranges -> Ranges -> Ranges

-- | All the properties.
tests :: IO Bool
instance Typeable Range
instance Eq Range
instance Ord Range
instance Show Range
instance Eq Ranges
instance Show Ranges
instance Arbitrary Ranges
instance CoArbitrary Range
instance Arbitrary Range

module Agda.Syntax.Parser.Monad

-- | The parse monad. Equivalent to <tt>StateT <a>ParseState</a> (Either
--   <a>ParseError</a>)</tt> except for the definition of <tt>fail</tt>,
--   which builds a suitable <a>ParseError</a> object.
data Parser a

-- | The result of parsing something.
data ParseResult a
ParseOk :: ParseState -> a -> ParseResult a
ParseFailed :: ParseError -> ParseResult a

-- | The parser state. Contains everything the parser and the lexer could
--   ever need.
data ParseState
PState :: !Position -> !Position -> String -> !Char -> String -> [LayoutContext] -> [LexState] -> ParseFlags -> ParseState

-- | position at current input location
parsePos :: ParseState -> !Position

-- | position of last token
parseLastPos :: ParseState -> !Position

-- | the current input
parseInp :: ParseState -> String

-- | the character before the input
parsePrevChar :: ParseState -> !Char

-- | the previous token
parsePrevToken :: ParseState -> String

-- | the stack of layout contexts
parseLayout :: ParseState -> [LayoutContext]

-- | the state of the lexer (states can be nested so we need a stack)
parseLexState :: ParseState -> [LexState]

-- | currently there are no flags
parseFlags :: ParseState -> ParseFlags

-- | What you get if parsing fails.
data ParseError
ParseError :: Position -> String -> String -> String -> ParseError

-- | where the error occured
errPos :: ParseError -> Position

-- | the remaining input
errInput :: ParseError -> String

-- | the previous token
errPrevToken :: ParseError -> String

-- | hopefully an explanation of what happened
errMsg :: ParseError -> String

-- | To do context sensitive lexing alex provides what is called <i>start
--   codes</i> in the Alex documentation. It is really an integer
--   representing the state of the lexer, so we call it <tt>LexState</tt>
--   instead.
type LexState = Int

-- | We need to keep track of the context to do layout. The context
--   specifies the indentation (if any) of a layout block. See
--   <a>Agda.Syntax.Parser.Layout</a> for more informaton.
data LayoutContext

-- | no layout
NoLayout :: LayoutContext

-- | layout at specified column
Layout :: Int32 -> LayoutContext

-- | There aren't any parser flags at the moment.
data ParseFlags
ParseFlags :: Bool -> ParseFlags

-- | Should comment tokens be returned by the lexer?
parseKeepComments :: ParseFlags -> Bool

-- | Constructs the initial state of the parser. The string argument is the
--   input string, the file path is only there because it's part of a
--   position.
initState :: Maybe AbsolutePath -> ParseFlags -> String -> [LexState] -> ParseState

-- | The default flags.
defaultParseFlags :: ParseFlags

-- | The most general way of parsing a string. The
--   <a>Agda.Syntax.Parser</a> will define more specialised functions that
--   supply the <a>ParseFlags</a> and the <a>LexState</a>.
parse :: ParseFlags -> [LexState] -> Parser a -> String -> ParseResult a

-- | The even more general way of parsing a string.
parsePosString :: Position -> ParseFlags -> [LexState] -> Parser a -> String -> ParseResult a

-- | The most general way of parsing a file. The <a>Agda.Syntax.Parser</a>
--   will define more specialised functions that supply the
--   <a>ParseFlags</a> and the <a>LexState</a>.
--   
--   Note that Agda source files always use the UTF-8 character encoding.
parseFile :: ParseFlags -> [LexState] -> Parser a -> AbsolutePath -> IO (ParseResult a)
setParsePos :: Position -> Parser ()
setLastPos :: Position -> Parser ()

-- | The parse interval is between the last position and the current
--   position.
getParseInterval :: Parser Interval
setPrevToken :: String -> Parser ()
getParseFlags :: Parser ParseFlags
getLexState :: Parser [LexState]
pushLexState :: LexState -> Parser ()
popLexState :: Parser ()

-- | Return the current layout context.
topContext :: Parser LayoutContext
popContext :: Parser ()
pushContext :: LayoutContext -> Parser ()

-- | Should only be used at the beginning of a file. When we start parsing
--   we should be in layout mode. Instead of forcing zero indentation we
--   use the indentation of the first token.
pushCurrentContext :: Parser ()

-- | <pre>
--   parseError = fail
--   </pre>
parseError :: String -> Parser a

-- | Fake a parse error at the specified position. Used, for instance, when
--   lexing nested comments, which when failing will always fail at the end
--   of the file. A more informative position is the beginning of the
--   failing comment.
parseErrorAt :: Position -> String -> Parser a

-- | Use <a>parseErrorAt</a> or <a>parseError</a> as appropriate.
parseError' :: Maybe Position -> String -> Parser a

-- | For lexical errors we want to report the current position as the site
--   of the error, whereas for parse errors the previous position is the
--   one we're interested in (since this will be the position of the token
--   we just lexed). This function does <a>parseErrorAt</a> the current
--   position.
lexError :: String -> Parser a
instance Typeable ParseError
instance Show LayoutContext
instance Show ParseFlags
instance Show ParseState
instance HasRange ParseError
instance Show ParseError
instance MonadState ParseState Parser
instance MonadError ParseError Parser
instance Applicative Parser
instance Functor Parser
instance Monad Parser
instance Exception ParseError

module Agda.Utils.Size

-- | The size of an object.
--   
--   For collections, it returns the length of the collection, not the
--   overall size including the elements.
class Sized a
size :: (Sized a, Integral n) => a -> n

-- | Thing decorated with its size. The thing should fit into main memory,
--   thus, the size is an <tt>Int</tt>.
data SizedThing a
SizedThing :: !Int -> a -> SizedThing a
theSize :: SizedThing a -> !Int
sizedThing :: SizedThing a -> a

-- | Cache the size of an object.
sizeThing :: Sized a => a -> SizedThing a
instance Null a => Null (SizedThing a)
instance Sized (SizedThing a)
instance Sized (Seq a)
instance Sized (Set a)
instance Sized (Map k a)
instance Sized IntSet
instance Sized (IntMap a)
instance Sized [a]


-- | Some common syntactic entities are defined in this module.
module Agda.Syntax.Common

-- | Used to specify whether something should be delayed.
data Delayed
Delayed :: Delayed
NotDelayed :: Delayed
data Induction
Inductive :: Induction
CoInductive :: Induction
data Hiding
Hidden :: Hiding
Instance :: Hiding
NotHidden :: Hiding

-- | A lens to access the <a>Hiding</a> attribute in data structures.
--   Minimal implementation: <tt>getHiding</tt> and one of
--   <tt>setHiding</tt> or <tt>mapHiding</tt>.
class LensHiding a where setHiding h = mapHiding (const h) mapHiding f a = setHiding (f $ getHiding a) a
getHiding :: LensHiding a => a -> Hiding
setHiding :: LensHiding a => Hiding -> a -> a
mapHiding :: LensHiding a => (Hiding -> Hiding) -> a -> a

-- | <tt>isHidden</tt> does not apply to <a>Instance</a>, only to
--   <a>Hidden</a>.
isHidden :: LensHiding a => a -> Bool

-- | Visible (<a>NotHidden</a>) arguments are <tt>notHidden</tt>.
--   (DEPRECATED, use <a>visible</a>.)
notHidden :: LensHiding a => a -> Bool

-- | <a>NotHidden</a> arguments are <tt>visible</tt>.
visible :: LensHiding a => a -> Bool

-- | <a>Instance</a> and <a>Hidden</a> arguments are <tt>notVisible</tt>.
notVisible :: LensHiding a => a -> Bool
hide :: LensHiding a => a -> a
makeInstance :: LensHiding a => a -> a

-- | A function argument can be relevant or irrelevant. See
--   <a>Irrelevance</a>.
data Relevance

-- | The argument is (possibly) relevant at compile-time.
Relevant :: Relevance

-- | The argument may never flow into evaluation position. Therefore, it is
--   irrelevant at run-time. It is treated relevantly during equality
--   checking.
NonStrict :: Relevance

-- | The argument is irrelevant at compile- and runtime.
Irrelevant :: Relevance

-- | The argument can be skipped during equality checking because its value
--   is already determined by the type.
Forced :: Relevance

-- | The polarity checker has determined that this argument is unused in
--   the definition. It can be skipped during equality checking but should
--   be mined for solutions of meta-variables with relevance
--   <a>UnusedArg</a>
UnusedArg :: Relevance

-- | A lens to access the <a>Relevance</a> attribute in data structures.
--   Minimal implementation: <tt>getRelevance</tt> and one of
--   <tt>setRelevance</tt> or <tt>mapRelevance</tt>.
class LensRelevance a where setRelevance h = mapRelevance (const h) mapRelevance f a = setRelevance (f $ getRelevance a) a
getRelevance :: LensRelevance a => a -> Relevance
setRelevance :: LensRelevance a => Relevance -> a -> a
mapRelevance :: LensRelevance a => (Relevance -> Relevance) -> a -> a
isRelevant :: LensRelevance a => a -> Bool
isIrrelevant :: LensRelevance a => a -> Bool

-- | Information ordering. <tt>Relevant `moreRelevant` UnusedArg
--   `moreRelevant` Forced `moreRelevant` NonStrict `moreRelevant`
--   Irrelevant</tt>
moreRelevant :: Relevance -> Relevance -> Bool

-- | A function argument can be hidden and/or irrelevant.
data ArgInfo c
ArgInfo :: Hiding -> Relevance -> [c] -> ArgInfo c
argInfoHiding :: ArgInfo c -> Hiding
argInfoRelevance :: ArgInfo c -> Relevance
argInfoColors :: ArgInfo c -> [c]
mapArgInfoColors :: ([c] -> [c']) -> ArgInfo c -> ArgInfo c'
defaultArgInfo :: ArgInfo c
data Arg c e
Arg :: ArgInfo c -> e -> Arg c e
argInfo :: Arg c e -> ArgInfo c
unArg :: Arg c e -> e
mapArgInfo :: (ArgInfo c -> ArgInfo c') -> Arg c a -> Arg c' a
argColors :: Arg c a -> [c]
mapArgColors :: ([c] -> [c']) -> Arg c a -> Arg c' a
setArgColors :: [c] -> Arg c' a -> Arg c a
defaultArg :: a -> Arg c a
defaultColoredArg :: ([c], a) -> Arg c a
noColorArg :: Hiding -> Relevance -> a -> Arg c a

-- | <tt>xs `withArgsFrom` args</tt> translates <tt>xs</tt> into a list of
--   <a>Arg</a>s, using the elements in <tt>args</tt> to fill in the
--   non-<a>unArg</a> fields.
--   
--   Precondition: The two lists should have equal length.
withArgsFrom :: [a] -> [Arg c b] -> [Arg c a]
withNamedArgsFrom :: [a] -> [NamedArg c b] -> [NamedArg c a]
class Eq a => Underscore a where isUnderscore = (== underscore)
underscore :: Underscore a => a
isUnderscore :: Underscore a => a -> Bool

-- | Similar to <a>Arg</a>, but we need to distinguish an irrelevance
--   annotation in a function domain (the domain itself is not irrelevant!)
--   from an irrelevant argument.
--   
--   <tt>Dom</tt> is used in <tt>Pi</tt> of internal syntax, in
--   <tt>Context</tt> and <tt>Telescope</tt>. <a>Arg</a> is used for actual
--   arguments (<tt>Var</tt>, <tt>Con</tt>, <tt>Def</tt> etc.) and in
--   <tt>Abstract</tt> syntax and other situations.
data Dom c e
Dom :: ArgInfo c -> e -> Dom c e
domInfo :: Dom c e -> ArgInfo c
unDom :: Dom c e -> e
mapDomInfo :: (ArgInfo c -> ArgInfo c') -> Dom c a -> Dom c' a
domColors :: Dom c a -> [c]
argFromDom :: Dom c a -> Arg c a
domFromArg :: Arg c a -> Dom c a
defaultDom :: a -> Dom c a

-- | Something potentially carrying a name.
data Named name a
Named :: Maybe name -> a -> Named name a
nameOf :: Named name a -> Maybe name
namedThing :: Named name a -> a

-- | Standard naming.
type Named_ = Named RString
unnamed :: a -> Named name a
named :: name -> a -> Named name a

-- | Only <a>Hidden</a> arguments can have names.
type NamedArg c a = Arg c (Named_ a)

-- | Get the content of a <a>NamedArg</a>.
namedArg :: NamedArg c a -> a
defaultNamedArg :: a -> NamedArg c a

-- | The functor instance for <a>NamedArg</a> would be ambiguous, so we
--   give it another name here.
updateNamedArg :: (a -> b) -> NamedArg c a -> NamedArg c b

-- | Thing with range info.
data Ranged a
Ranged :: Range -> a -> Ranged a
rangeOf :: Ranged a -> Range
rangedThing :: Ranged a -> a

-- | Thing with no range info.
unranged :: a -> Ranged a

-- | A <tt>RawName</tt> is some sort of string.
type RawName = String
rawNameToString :: RawName -> String
stringToRawName :: String -> RawName

-- | String with range info.
type RString = Ranged RawName

-- | Functions can be defined in both infix and prefix style. See
--   <a>LHS</a>.
data IsInfix
InfixDef :: IsInfix
PrefixDef :: IsInfix

-- | Access modifier.
data Access
PrivateAccess :: Access
PublicAccess :: Access

-- | Visible from outside, but not exported when opening the module Used
--   for qualified constructors.
OnlyQualified :: Access

-- | Abstract or concrete
data IsAbstract
AbstractDef :: IsAbstract
ConcreteDef :: IsAbstract

-- | Is this definition eligible for instance search?
data IsInstance
InstanceDef :: IsInstance
NotInstanceDef :: IsInstance
type Nat = Int
type Arity = Nat

-- | The unique identifier of a name. Second argument is the top-level
--   module identifier.
data NameId
NameId :: Integer -> Integer -> NameId
newtype Constr a
Constr :: a -> Constr a
newtype InteractionId
InteractionId :: Nat -> InteractionId
interactionId :: InteractionId -> Nat

-- | Termination check? (Default = True).
data TerminationCheck m

-- | Run the termination checker.
TerminationCheck :: TerminationCheck m

-- | Skip termination checking (unsafe).
NoTerminationCheck :: TerminationCheck m

-- | Treat as non-terminating.
NonTerminating :: TerminationCheck m

-- | Treat as terminating (unsafe). Same effect as
--   <a>NoTerminationCheck</a>.
Terminating :: TerminationCheck m

-- | Skip termination checking but use measure instead.
TerminationMeasure :: !Range -> m -> TerminationCheck m
instance Typeable Delayed
instance Typeable Induction
instance Typeable Hiding
instance Typeable Relevance
instance Typeable ArgInfo
instance Typeable Arg
instance Typeable Dom
instance Typeable Named
instance Typeable Ranged
instance Typeable IsInfix
instance Typeable Access
instance Typeable IsAbstract
instance Typeable IsInstance
instance Typeable NameId
instance Typeable TerminationCheck
instance Show Delayed
instance Eq Delayed
instance Ord Delayed
instance Eq Induction
instance Ord Induction
instance Show Hiding
instance Eq Hiding
instance Ord Hiding
instance Show Relevance
instance Eq Relevance
instance Enum Relevance
instance Bounded Relevance
instance Eq c => Eq (ArgInfo c)
instance Ord c => Ord (ArgInfo c)
instance Functor ArgInfo
instance Foldable ArgInfo
instance Traversable ArgInfo
instance Show c => Show (ArgInfo c)
instance (Ord c, Ord e) => Ord (Arg c e)
instance Functor (Arg c)
instance Foldable (Arg c)
instance Traversable (Arg c)
instance (Eq c, Eq e) => Eq (Dom c e)
instance (Ord c, Ord e) => Ord (Dom c e)
instance Functor (Dom c)
instance Foldable (Dom c)
instance Traversable (Dom c)
instance (Eq name, Eq a) => Eq (Named name a)
instance (Ord name, Ord a) => Ord (Named name a)
instance Functor (Named name)
instance Foldable (Named name)
instance Traversable (Named name)
instance Functor Ranged
instance Foldable Ranged
instance Traversable Ranged
instance Show IsInfix
instance Eq IsInfix
instance Ord IsInfix
instance Show Access
instance Eq Access
instance Ord Access
instance Show IsAbstract
instance Eq IsAbstract
instance Ord IsAbstract
instance Show IsInstance
instance Eq IsInstance
instance Ord IsInstance
instance Eq NameId
instance Ord NameId
instance Eq InteractionId
instance Ord InteractionId
instance Num InteractionId
instance Integral InteractionId
instance Real InteractionId
instance Enum InteractionId
instance Show m => Show (TerminationCheck m)
instance Eq m => Eq (TerminationCheck m)
instance Functor TerminationCheck
instance KillRange m => KillRange (TerminationCheck m)
instance KillRange InteractionId
instance Show InteractionId
instance Hashable NameId
instance Enum NameId
instance Show NameId
instance KillRange IsAbstract
instance Decoration Ranged
instance KillRange (Ranged a)
instance HasRange (Ranged a)
instance Ord a => Ord (Ranged a)
instance Eq a => Eq (Ranged a)
instance Show a => Show (Ranged a)
instance Show a => Show (Named_ a)
instance Sized a => Sized (Named name a)
instance (KillRange name, KillRange a) => KillRange (Named name a)
instance HasRange a => HasRange (Named name a)
instance Decoration (Named name)
instance LensRelevance (Dom c e)
instance LensHiding (Dom c e)
instance (Show a, Show c) => Show (Dom c a)
instance Sized a => Sized (Dom c a)
instance (KillRange c, KillRange a) => KillRange (Dom c a)
instance HasRange a => HasRange (Dom c a)
instance Decoration (Dom c)
instance Underscore Doc
instance Underscore ByteString
instance Underscore String
instance LensRelevance (Arg c e)
instance LensHiding (Arg c e)
instance (Show a, Show c) => Show (Arg c a)
instance (Eq a, Eq c) => Eq (Arg c a)
instance Sized a => Sized (Arg c a)
instance (KillRange c, KillRange a) => KillRange (Arg c a)
instance HasRange a => HasRange (Arg c a)
instance Decoration (Arg c)
instance LensRelevance (ArgInfo c)
instance LensHiding (ArgInfo c)
instance KillRange c => KillRange (ArgInfo c)
instance LensRelevance Relevance
instance Ord Relevance
instance Arbitrary Relevance
instance KillRange Relevance
instance LensHiding Hiding
instance KillRange Hiding
instance CoArbitrary Induction
instance Arbitrary Induction
instance KillRange Induction
instance HasRange Induction
instance Show Induction
instance KillRange Delayed


-- | Names in the concrete syntax are just strings (or lists of strings for
--   qualified names).
module Agda.Syntax.Concrete.Name

-- | A name is a non-empty list of alternating <a>Id</a>s and <a>Hole</a>s.
--   A normal name is represented by a singleton list, and operators are
--   represented by a list with <a>Hole</a>s where the arguments should go.
--   For instance: <tt>[Hole,Id "+",Hole]</tt> is infix addition.
--   
--   Equality and ordering on <tt>Name</tt>s are defined to ignore range so
--   same names in different locations are equal.
data Name

-- | A (mixfix) identifier.
Name :: !Range -> [NamePart] -> Name

-- | <tt>_</tt>.
NoName :: !Range -> NameId -> Name

-- | Mixfix identifiers are composed of words and holes, e.g. <tt>_+_</tt>
--   or <tt>if_then_else_</tt> or <tt>[_/_]</tt>.
data NamePart

-- | <tt>_</tt> part.
Hole :: NamePart

-- | Identifier part.
Id :: RawName -> NamePart

-- | Define equality on <tt>Name</tt> to ignore range so same names in
--   different locations are equal.
--   
--   Is there a reason not to do this? -Jeff
--   
--   No. But there are tons of reasons to do it. For instance, when using
--   names as keys in maps you really don't want to have to get the range
--   right to be able to do a lookup. -Ulf

-- | <tt>QName</tt> is a list of namespaces and the name of the constant.
--   For the moment assumes namespaces are just <tt>Name</tt>s and not
--   explicitly applied modules. Also assumes namespaces are generative by
--   just using derived equality. We will have to define an equality
--   instance to non-generative namespaces (as well as having some sort of
--   lookup table for namespace names).
data QName

-- | <tt>A.rest</tt>.
Qual :: Name -> QName -> QName

-- | <tt>x</tt>.
QName :: Name -> QName

-- | Top-level module names. Used in connection with the file system.
--   
--   Invariant: The list must not be empty.
newtype TopLevelModuleName
TopLevelModuleName :: [String] -> TopLevelModuleName
moduleNameParts :: TopLevelModuleName -> [String]
nameToRawName :: Name -> RawName
nameParts :: Name -> [NamePart]
nameStringParts :: Name -> [RawName]

-- | Parse a string to parts of a concrete name.
stringNameParts :: String -> [NamePart]

-- | Is the name an operator?
isOperator :: Name -> Bool
isHole :: NamePart -> Bool
isPrefix :: Name -> Bool
isNonfix :: Name -> Bool
isInfix :: Name -> Bool
isPostfix :: Name -> Bool

-- | <pre>
--   qualify A.B x == A.B.x
--   </pre>
qualify :: QName -> Name -> QName

-- | <pre>
--   unqualify A.B.x == x
--   </pre>
--   
--   The range is preserved.
unqualify :: QName -> Name

-- | <pre>
--   qnameParts A.B.x = [A, B, x]
--   </pre>
qnameParts :: QName -> [Name]

-- | Turns a qualified name into a <a>TopLevelModuleName</a>. The qualified
--   name is assumed to represent a top-level module name.
toTopLevelModuleName :: QName -> TopLevelModuleName

-- | Turns a top-level module name into a file name with the given suffix.
moduleNameToFileName :: TopLevelModuleName -> String -> FilePath

-- | Finds the current project's "root" directory, given a project file and
--   the corresponding top-level module name.
--   
--   Example: If the module "A.B.C" is located in the file
--   "<i>foo</i>A<i>B</i>C.agda", then the root is "<i>foo</i>".
--   
--   Precondition: The module name must be well-formed.
projectRoot :: AbsolutePath -> TopLevelModuleName -> AbsolutePath

-- | <pre>
--   noName_ = <a>noName</a> <a>noRange</a>
--   </pre>
noName_ :: Name

-- | <pre>
--   noName r = <a>Name</a> r [<a>Hole</a>]
--   </pre>
noName :: Range -> Name

-- | Check whether a name is the empty name "_".
class IsNoName a
isNoName :: IsNoName a => a -> Bool
instance Typeable NamePart
instance Typeable Name
instance Typeable QName
instance Typeable TopLevelModuleName
instance Eq QName
instance Ord QName
instance Show TopLevelModuleName
instance Eq TopLevelModuleName
instance Ord TopLevelModuleName
instance KillRange Name
instance KillRange QName
instance SetRange QName
instance SetRange Name
instance HasRange QName
instance HasRange Name
instance CoArbitrary TopLevelModuleName
instance Arbitrary TopLevelModuleName
instance Pretty TopLevelModuleName
instance Pretty QName
instance Pretty NamePart
instance Pretty Name
instance Show QName
instance Show NamePart
instance Show Name
instance IsNoName QName
instance IsNoName Name
instance IsNoName ByteString
instance IsNoName String
instance Underscore QName
instance Ord NamePart
instance Eq NamePart
instance Ord Name
instance Eq Name
instance Underscore Name
instance NFData Name

module Agda.Compiler.JS.Syntax
data Exp
Self :: Exp
Local :: LocalId -> Exp
Global :: GlobalId -> Exp
Undefined :: Exp
String :: String -> Exp
Char :: Char -> Exp
Integer :: Integer -> Exp
Double :: Double -> Exp
Lambda :: Nat -> Exp -> Exp
Object :: (Map MemberId Exp) -> Exp
Apply :: Exp -> [Exp] -> Exp
Lookup :: Exp -> MemberId -> Exp
If :: Exp -> Exp -> Exp -> Exp
BinOp :: Exp -> String -> Exp -> Exp
PreOp :: String -> Exp -> Exp
Const :: String -> Exp
newtype LocalId
LocalId :: Nat -> LocalId
newtype GlobalId
GlobalId :: [String] -> GlobalId
newtype MemberId
MemberId :: String -> MemberId
data Export
Export :: [MemberId] -> Exp -> Export
expName :: Export -> [MemberId]
defn :: Export -> Exp
data Module
Module :: GlobalId -> [Export] -> Module
modName :: Module -> GlobalId
exports :: Module -> [Export]
class Uses a
uses :: Uses a => a -> Set [MemberId]
class Globals a
globals :: Globals a => a -> Set GlobalId
instance Typeable LocalId
instance Typeable GlobalId
instance Typeable MemberId
instance Typeable Exp
instance Typeable Export
instance Typeable Module
instance Eq LocalId
instance Ord LocalId
instance Show LocalId
instance Eq GlobalId
instance Ord GlobalId
instance Show GlobalId
instance Eq MemberId
instance Ord MemberId
instance Show MemberId
instance Show Exp
instance Show Export
instance Show Module
instance Globals Module
instance Globals Export
instance Globals Exp
instance Globals a => Globals (Map k a)
instance Globals a => Globals [a]
instance Uses Export
instance Uses Exp
instance Uses a => Uses (Map k a)
instance Uses a => Uses [a]

module Agda.Compiler.JS.Pretty
br :: Int -> String
unescape :: Char -> String
unescapes :: String -> String
class Pretty a
pretty :: Pretty a => Nat -> Int -> a -> String
class Pretties a
pretties :: Pretties a => Nat -> Int -> a -> [String]
block :: Nat -> Int -> Exp -> String
block' :: Nat -> Int -> Exp -> String
modname :: GlobalId -> String
exports :: Nat -> Int -> Set [MemberId] -> [Export] -> String
instance Pretty Module
instance Pretty Exp
instance Pretty MemberId
instance Pretty GlobalId
instance Pretty LocalId
instance (Pretty a, Pretty b) => Pretties (Map a b)
instance Pretty a => Pretties [a]
instance (Pretty a, Pretty b) => Pretty (a, b)

module Agda.Compiler.JS.Substitution
map :: Nat -> (Nat -> LocalId -> Exp) -> Exp -> Exp
shift :: Nat -> Exp -> Exp
shiftFrom :: Nat -> Nat -> Exp -> Exp
shifter :: Nat -> Nat -> LocalId -> Exp
subst :: Nat -> [Exp] -> Exp -> Exp
substituter :: Nat -> [Exp] -> Nat -> LocalId -> Exp
map' :: Nat -> (Nat -> LocalId -> Exp) -> Exp -> Exp
subst' :: Nat -> [Exp] -> Exp -> Exp
apply :: Exp -> [Exp] -> Exp
lookup :: Exp -> MemberId -> Exp
self :: Exp -> Exp -> Exp
fix :: Exp -> Exp
curriedApply :: Exp -> [Exp] -> Exp
curriedLambda :: Nat -> Exp -> Exp
emp :: Exp
union :: Exp -> Exp -> Exp
vine :: [MemberId] -> Exp -> Exp
object :: [([MemberId], Exp)] -> Exp

module Agda.Compiler.JS.Case
data Case
Case :: [Patt] -> Exp -> Case
pats :: Case -> [Patt]
body :: Case -> Exp
data Patt
VarPatt :: Patt
Tagged :: Tag -> [Patt] -> Patt
data Tag
Tag :: MemberId -> [MemberId] -> (Exp -> [Exp] -> Exp) -> Tag
numVars :: [Patt] -> Nat
numVars' :: Patt -> Nat
lambda :: [Case] -> Exp
lambda' :: Nat -> Nat -> Nat -> [Case] -> Exp
pop :: Case -> Case
match :: Nat -> Nat -> Nat -> [Case] -> MemberId -> Nat -> Exp
refine :: MemberId -> Nat -> Case -> [Case]
visit :: [Case] -> Exp -> [Exp] -> Exp
tags :: [Case] -> Map MemberId Nat
tag :: Case -> Map MemberId Nat
instance Show Patt
instance Show Case
instance Show Tag
instance Pretty Patt
instance Pretty Case

module Agda.Compiler.JS.Parser
type Parser = ReadP Char
identifier :: Parser String
wordBoundary :: Parser ()
token :: String -> Parser ()
punct :: Char -> Parser ()
parened :: Parser a -> Parser a
braced :: Parser a -> Parser a
bracketed :: Parser a -> Parser a
quoted :: Parser a -> Parser a
stringLit :: Parser Exp
stringStr :: Parser String
stringChr :: Parser Char
escChr :: Parser Char
intLit :: Parser Exp
undef :: Parser Exp
localid :: (Map String Nat) -> Parser Exp
globalid :: Parser Exp
preop :: Parser String
binop :: Parser String
field :: (Map String Nat) -> Parser (MemberId, Exp)
object :: (Map String Nat) -> Parser Exp
function :: (Map String Nat) -> Parser Exp
bracedBlock :: (Map String Nat) -> Parser Exp
returnBlock :: (Map String Nat) -> Parser Exp
ifBlock :: (Map String Nat) -> Parser Exp
exp0 :: (Map String Nat) -> Parser Exp
exp1 :: (Map String Nat) -> Parser Exp
exp2 :: (Map String Nat) -> Parser Exp
exp2' :: (Map String Nat) -> Exp -> Parser Exp
exp3 :: (Map String Nat) -> Parser Exp
exp3' :: (Map String Nat) -> Exp -> Parser Exp
exp :: (Map String Nat) -> Parser Exp
topLevel :: Parser Exp
parse :: String -> Either Exp String


-- | As a concrete name, a notation is a non-empty list of alternating
--   <a>IdPart</a>s and holes. In contrast to concrete names, holes can be
--   binders.
--   
--   Example: <tt> syntax fmap (λ x → e) xs = for x ∈ xs return e </tt>
--   
--   The declared notation for <tt>fmap</tt> is <tt>for_∈_return_</tt>
--   where the first hole is a binder.
module Agda.Syntax.Notation

-- | Data type constructed in the Happy parser; converted to <a>GenPart</a>
--   before it leaves the Happy code.
data HoleName

-- | <tt> x -&gt; y</tt>; 1st argument is the bound name (unused for now).
LambdaHole :: RawName -> RawName -> HoleName
_bindHoleName :: HoleName -> RawName
holeName :: HoleName -> RawName

-- | Simple named hole with hiding.
ExprHole :: RawName -> HoleName
holeName :: HoleName -> RawName

-- | Is the hole a binder?
isLambdaHole :: HoleName -> Bool

-- | Notation as provided by the <tt>syntax</tt> declaration.
type Notation = [GenPart]

-- | Part of a Notation
data GenPart

-- | Argument is the position of the hole (with binding) where the binding
--   should occur.
BindHole :: Int -> GenPart

-- | Argument is where the expression should go.
NormalHole :: (NamedArg () Int) -> GenPart
IdPart :: RawName -> GenPart

-- | Get a flat list of identifier parts of a notation.
stringParts :: Notation -> [RawName]

-- | Target argument position of a part (Nothing if it is not a hole).
holeTarget :: GenPart -> Maybe Int

-- | Is the part a hole?
isAHole :: GenPart -> Bool

-- | Is the part a binder?
isBindingHole :: GenPart -> Bool

-- | Classification of notations.
data NotationKind

-- | Ex: <tt>_bla_blub_</tt>.
InfixNotation :: NotationKind

-- | Ex: <tt>_bla_blub</tt>.
PrefixNotation :: NotationKind

-- | Ex: <tt>bla_blub_</tt>.
PostfixNotation :: NotationKind

-- | Ex: <tt>bla_blub</tt>.
NonfixNotation :: NotationKind
NoNotation :: NotationKind

-- | Classify a notation by presence of leading and/or trailing hole.
notationKind :: Notation -> NotationKind

-- | From notation with names to notation with indices.
--   
--   Example: <tt> ids = ["for", "x", "∈", "xs", "return", "e"] holes = [
--   LambdaHole "x" "e", ExprHole "xs" ] </tt> creates the notation <tt> [
--   IdPart "for" , BindHole 0 , IdPart "∈" , NormalHole 1 , IdPart
--   "return" , NormalHole 0 ] </tt>
mkNotation :: [NamedArg c HoleName] -> [RawName] -> Either String Notation

-- | No notation by default.
defaultNotation :: Notation

-- | No notation by default.
noNotation :: Notation
instance Typeable GenPart
instance Show GenPart
instance Eq GenPart
instance Eq NotationKind


-- | Definitions for fixity, precedence levels, and declared syntax.
module Agda.Syntax.Fixity

-- | The notation is handled as the fixity in the renamer. Hence, they are
--   grouped together in this type.
data Fixity'
Fixity' :: Fixity -> Notation -> Fixity'
theFixity :: Fixity' -> Fixity
theNotation :: Fixity' -> Notation

-- | Decorating something with <tt>Fixity'</tt>.
data ThingWithFixity x
ThingWithFixity :: x -> Fixity' -> ThingWithFixity x

-- | All the notation information related to a name.
data NewNotation
NewNotation :: QName -> Fixity -> Notation -> NewNotation

-- | The concrete name the syntax or fixity belongs to.
notaName :: NewNotation -> QName

-- | Associativity and precedence (fixity) of the name.
notaFixity :: NewNotation -> Fixity

-- | Syntax associated with the name.
notation :: NewNotation -> Notation

-- | If an operator has no specific notation, recover it from its name.
oldToNewNotation :: (QName, Fixity') -> NewNotation

-- | Return the <a>IdPart</a>s of a notation, the first part qualified, the
--   other parts unqualified. This allows for qualified use of operators,
--   e.g., <tt>M.for x ∈ xs return e</tt>, or <tt>x ℕ.+ y</tt>.
notationNames :: NewNotation -> [QName]

-- | Create a <a>Notation</a> (without binders) from a concrete
--   <a>Name</a>. Does the obvious thing: <a>Hole</a>s become
--   <a>NormalHole</a>s, <a>Id</a>s become <tt>IdParts</tt>. If <a>Name</a>
--   has no <a>Hole</a>s, it returns <a>noNotation</a>.
syntaxOf :: Name -> Notation
defaultFixity' :: Fixity'

-- | Removes copies of <tt>defaultFixity'</tt> from a list of fixities.
--   Never returns an empty list, though, rather a singleton list
--   consisting of <tt>defaultFixity'</tt>.
interestingFixities :: [Fixity'] -> [Fixity']

-- | If different interesting fixities are available for the same symbol,
--   we take none of them.
chooseFixity :: [Fixity'] -> Fixity'

-- | Fixity of operators.
data Fixity
LeftAssoc :: Range -> Integer -> Fixity
fixityRange :: Fixity -> Range
fixityLevel :: Fixity -> Integer
RightAssoc :: Range -> Integer -> Fixity
fixityRange :: Fixity -> Range
fixityLevel :: Fixity -> Integer
NonAssoc :: Range -> Integer -> Fixity
fixityRange :: Fixity -> Range
fixityLevel :: Fixity -> Integer

-- | The default fixity. Currently defined to be <tt><a>NonAssoc</a>
--   20</tt>.
defaultFixity :: Fixity

-- | Hack used for <tt>syntax</tt> facility.
noFixity :: Fixity

-- | Precedence is associated with a context.
data Precedence
TopCtx :: Precedence
FunctionSpaceDomainCtx :: Precedence
LeftOperandCtx :: Fixity -> Precedence
RightOperandCtx :: Fixity -> Precedence
FunctionCtx :: Precedence
ArgumentCtx :: Precedence
InsideOperandCtx :: Precedence
WithFunCtx :: Precedence
WithArgCtx :: Precedence
DotPatternCtx :: Precedence

-- | The precedence corresponding to a possibly hidden argument.
hiddenArgumentCtx :: Hiding -> Precedence

-- | Do we need to bracket an operator application of the given fixity in a
--   context with the given precedence.
opBrackets :: Fixity -> Precedence -> Bool

-- | Does a lambda-like thing (lambda, let or pi) need brackets in the
--   given context? A peculiar thing with lambdas is that they don't need
--   brackets in certain right operand contexts. However, we insert
--   brackets anyway, for the following reasons:
--   
--   <ul>
--   <li>Clarity.</li>
--   <li>Sometimes brackets are needed. Example: <tt>m₁ &gt;&gt;= (λ x → x)
--   &gt;&gt;= m₂</tt> (here <tt>_&gt;&gt;=_</tt> is left
--   associative).</li>
--   </ul>
lamBrackets :: Precedence -> Bool

-- | Does a function application need brackets?
appBrackets :: Precedence -> Bool

-- | Does a with application need brackets?
withAppBrackets :: Precedence -> Bool

-- | Does a function space need brackets?
piBrackets :: Precedence -> Bool
roundFixBrackets :: Precedence -> Bool
instance Typeable Fixity
instance Typeable NewNotation
instance Typeable Fixity'
instance Typeable ThingWithFixity
instance Typeable Precedence
instance Show Fixity
instance Show NewNotation
instance Show Fixity'
instance Eq Fixity'
instance Functor ThingWithFixity
instance Foldable ThingWithFixity
instance Traversable ThingWithFixity
instance Show x => Show (ThingWithFixity x)
instance Show Precedence
instance KillRange Fixity'
instance KillRange Fixity
instance HasRange Fixity
instance Eq Fixity


-- | Construct a graph from constraints <tt> x + n <a>y becomes x
--   ---(-n)---</a> y x <a>n + y becomes x ---(+n)---</a> y </tt> the
--   default edge (= no edge) is labelled with infinity.
--   
--   Building the graph involves keeping track of the node names. We do
--   this in a finite map, assigning consecutive numbers to nodes.
module Agda.Utils.Warshall
type Matrix a = Array (Int, Int) a
warshall :: SemiRing a => Matrix a -> Matrix a
type AdjList node edge = Map node [(node, edge)]

-- | Warshall's algorithm on a graph represented as an adjacency list.
warshallG :: (SemiRing edge, Ord node) => AdjList node edge -> AdjList node edge

-- | Edge weight in the graph, forming a semi ring.
data Weight
Finite :: Int -> Weight
Infinite :: Weight
inc :: Weight -> Int -> Weight

-- | Nodes of the graph are either - flexible variables (with identifiers
--   drawn from <tt>Int</tt>), - rigid variables (also identified by
--   <tt>Int</tt>s), or - constants (like 0, infinity, or anything
--   between).
data Node
Rigid :: Rigid -> Node
Flex :: FlexId -> Node
data Rigid
RConst :: Weight -> Rigid
RVar :: RigidId -> Rigid
type NodeId = Int
type RigidId = Int
type FlexId = Int

-- | Which rigid variables a flex may be instatiated to.
type Scope = RigidId -> Bool
infinite :: Rigid -> Bool

-- | <tt>isBelow r w r'</tt> checks, if <tt>r</tt> and <tt>r'</tt> are
--   connected by <tt>w</tt> (meaning <tt>w</tt> not infinite), whether
--   <tt>r + w &lt;= r'</tt>. Precondition: not the same rigid variable.
isBelow :: Rigid -> Weight -> Rigid -> Bool

-- | A constraint is an edge in the graph.
data Constraint
NewFlex :: FlexId -> Scope -> Constraint

-- | For <tt>Arc v1 k v2</tt> at least one of <tt>v1</tt> or <tt>v2</tt> is
--   a <tt>MetaV</tt> (Flex), the other a <tt>MetaV</tt> or a <tt>Var</tt>
--   (Rigid). If <tt>k &lt;= 0</tt> this means <tt>suc^(-k) v1 &lt;=
--   v2</tt> otherwise <tt>v1 &lt;= suc^k v3</tt>.
Arc :: Node -> Int -> Node -> Constraint
type Constraints = [Constraint]
emptyConstraints :: Constraints
data Graph
Graph :: Map FlexId Scope -> Map Node NodeId -> Map NodeId Node -> NodeId -> (NodeId -> NodeId -> Weight) -> Graph

-- | Scope for each flexible var.
flexScope :: Graph -> Map FlexId Scope

-- | Node labels to node numbers.
nodeMap :: Graph -> Map Node NodeId

-- | Node numbers to node labels.
intMap :: Graph -> Map NodeId Node

-- | Number of nodes <tt>n</tt>.
nextNode :: Graph -> NodeId

-- | The edges (restrict to <tt>[0..n[</tt>).
graph :: Graph -> NodeId -> NodeId -> Weight

-- | The empty graph: no nodes, edges are all undefined (infinity weight).
initGraph :: Graph

-- | The Graph Monad, for constructing a graph iteratively.
type GM = State Graph

-- | Add a size meta node.
addFlex :: FlexId -> Scope -> GM ()

-- | Lookup identifier of a node. If not present, it is added first.
addNode :: Node -> GM Int

-- | <tt>addEdge n1 k n2</tt> improves the weight of egde
--   <tt>n1-&gt;n2</tt> to be at most <tt>k</tt>. Also adds nodes if not
--   yet present.
addEdge :: Node -> Int -> Node -> GM ()
addConstraint :: Constraint -> GM ()
buildGraph :: Constraints -> Graph
mkMatrix :: Int -> (Int -> Int -> Weight) -> Matrix Weight

-- | A matrix with row descriptions in <tt>b</tt> and column descriptions
--   in <tt>c</tt>.
data LegendMatrix a b c
LegendMatrix :: Matrix a -> (Int -> b) -> (Int -> c) -> LegendMatrix a b c
matrix :: LegendMatrix a b c -> Matrix a
rowdescr :: LegendMatrix a b c -> Int -> b
coldescr :: LegendMatrix a b c -> Int -> c

-- | A solution assigns to each flexible variable a size expression which
--   is either a constant or a <tt>v + n</tt> for a rigid variable
--   <tt>v</tt>.
type Solution = Map Int SizeExpr
emptySolution :: Solution
extendSolution :: Solution -> Int -> SizeExpr -> Solution
data SizeExpr

-- | e.g. x + 5
SizeVar :: RigidId -> Int -> SizeExpr

-- | a number or infinity
SizeConst :: Weight -> SizeExpr

-- | <tt>sizeRigid r n</tt> returns the size expression corresponding to
--   <tt>r + n</tt>
sizeRigid :: Rigid -> Int -> SizeExpr
solve :: Constraints -> Maybe Solution
genGraph :: Ord node => Float -> Gen edge -> [node] -> Gen (AdjList node edge)
newtype Distance
Dist :: Nat -> Distance
genGraph_ :: Nat -> Gen (AdjList Nat Distance)
lookupEdge :: Ord n => n -> n -> AdjList n e -> Maybe e
edges :: Ord n => AdjList n e -> [(n, n, e)]

-- | Check that no edges get longer when completing a graph.
prop_smaller :: Nat -> Property
newEdge :: Nat -> Nat -> Distance -> AdjList Nat Distance -> AdjList Nat Distance
genPath :: Nat -> Nat -> Nat -> AdjList Nat Distance -> Gen (AdjList Nat Distance)

-- | Check that all transitive edges are added.
prop_path :: Nat -> Property
mapNodes :: (Ord node, Ord node') => (node -> node') -> AdjList node edge -> AdjList node' edge

-- | Check that no edges are added between components.
prop_disjoint :: Nat -> Property
prop_stable :: Nat -> Property
tests :: IO Bool
instance Eq Weight
instance Eq Rigid
instance Ord Rigid
instance Show Rigid
instance Eq Node
instance Ord Node
instance Eq Distance
instance Ord Distance
instance Num Distance
instance Integral Distance
instance Show Distance
instance Enum Distance
instance Real Distance
instance SemiRing Distance
instance Show SizeExpr
instance (Show a, Show b, Show c) => Show (LegendMatrix a b c)
instance Show Constraint
instance Show Node
instance SemiRing Weight
instance Ord Weight
instance Show Weight

module Agda.Utils.Permutation

-- | Partial permutations. Examples:
--   
--   <tt>permute [1,2,0] [x0,x1,x2] = [x1,x2,x0]</tt> (proper permutation).
--   
--   <tt>permute [1,0] [x0,x1,x2] = [x1,x0]</tt> (partial permuation).
--   
--   <tt>permute [1,0,1,2] [x0,x1,x2] = [x1,x0,x1,x2]</tt> (not a
--   permutation because not invertible).
--   
--   Agda typing would be: <tt>Perm : {m : Nat}(n : Nat) -&gt; Vec (Fin n)
--   m -&gt; Permutation</tt> <tt>m</tt> is the <a>size</a> of the
--   permutation.
data Permutation
Perm :: Int -> [Int] -> Permutation
permRange :: Permutation -> Int
permPicks :: Permutation -> [Int]

-- | <tt>permute [1,2,0] [x0,x1,x2] = [x1,x2,x0]</tt> More precisely,
--   <tt>permute indices list = sublist</tt>, generates <tt>sublist</tt>
--   from <tt>list</tt> by picking the elements of list as indicated by
--   <tt>indices</tt>. <tt>permute [1,3,0] [x0,x1,x2,x3] = [x1,x3,x0]</tt>
--   
--   Agda typing: <tt>permute (Perm {m} n is) : Vec A m -&gt; Vec A n</tt>
permute :: Permutation -> [a] -> [a]
safePermute :: Permutation -> [a] -> [Maybe a]

-- | Invert a Permutation on a partial finite int map. <tt>inversePermute
--   perm f = f'</tt> such that <tt>permute perm f' = f</tt>
--   
--   Example, with map represented as <tt>[Maybe a]</tt>: <tt> f =
--   [Nothing, Just a, Just b ] perm = Perm 4 [3,0,2] f' = [ Just a ,
--   Nothing , Just b , Nothing ] </tt> Zipping <tt>perm</tt> with
--   <tt>f</tt> gives <tt>[(0,a),(2,b)]</tt>, after compression with
--   <tt>catMaybes</tt>. This is an <tt>IntMap</tt> which can easily
--   written out into a substitution again.
class InversePermute a b
inversePermute :: InversePermute a b => Permutation -> a -> b

-- | Identity permutation.
idP :: Int -> Permutation

-- | Restrict a permutation to work on <tt>n</tt> elements, discarding
--   picks <tt>&gt;=n</tt>.
takeP :: Int -> Permutation -> Permutation

-- | Pick the elements that are not picked by the permutation.
droppedP :: Permutation -> Permutation

-- | <tt>liftP k</tt> takes a <tt>Perm {m} n</tt> to a <tt>Perm {m+k}
--   (n+k)</tt>. Analogous to <a>liftS</a>, but Permutations operate on de
--   Bruijn LEVELS, not indices.
liftP :: Int -> Permutation -> Permutation

-- | <pre>
--   permute (compose p1 p2) == permute p1 . permute p2
--   </pre>
composeP :: Permutation -> Permutation -> Permutation

-- | <tt>invertP err p</tt> is the inverse of <tt>p</tt> where defined,
--   otherwise defaults to <tt>err</tt>. <tt>composeP p (invertP err p) ==
--   p</tt>
invertP :: Int -> Permutation -> Permutation

-- | Turn a possible non-surjective permutation into a surjective
--   permutation.
compactP :: Permutation -> Permutation

-- | <pre>
--   permute (reverseP p) xs ==
--       reverse $ permute p $ reverse xs
--   </pre>
--   
--   Example: <tt> permute (reverseP (Perm 4 [1,3,0])) [x0,x1,x2,x3] ==
--   permute (Perm 4 $ map (3-) [0,3,1]) [x0,x1,x2,x3] == permute (Perm 4
--   [3,0,2]) [x0,x1,x2,x3] == [x3,x0,x2] == reverse [x2,x0,x3] == reverse
--   $ permute (Perm 4 [1,3,0]) [x3,x2,x1,x0] == reverse $ permute (Perm 4
--   [1,3,0]) $ reverse [x0,x1,x2,x3] </tt>
reverseP :: Permutation -> Permutation

-- | <tt>expandP i n π</tt> in the domain of <tt>π</tt> replace the
--   <i>i</i>th element by <i>n</i> elements.
expandP :: Int -> Int -> Permutation -> Permutation

-- | Stable topologic sort. The first argument decides whether its first
--   argument is an immediate parent to its second argument.
topoSort :: (a -> a -> Bool) -> [a] -> Maybe Permutation

-- | Delayed dropping which allows undropping.
data Drop a
Drop :: Int -> a -> Drop a

-- | Non-negative number of things to drop.
dropN :: Drop a -> Int

-- | Where to drop from.
dropFrom :: Drop a -> a

-- | Things that support delayed dropping.
class DoDrop a where dropMore n (Drop m xs) = Drop (m + n) xs unDrop n (Drop m xs) | n <= m = Drop (m - n) xs | otherwise = (throwImpossible (Impossible "dist/build/tmp-29154/src/full/Agda/Utils/Permutation.hs" 217))
doDrop :: DoDrop a => Drop a -> a
dropMore :: DoDrop a => Int -> Drop a -> Drop a
unDrop :: DoDrop a => Int -> Drop a -> Drop a
instance Typeable Permutation
instance Typeable Drop
instance Eq Permutation
instance Eq a => Eq (Drop a)
instance Ord a => Ord (Drop a)
instance Show a => Show (Drop a)
instance Functor Drop
instance Foldable Drop
instance Traversable Drop
instance DoDrop Permutation
instance DoDrop [a]
instance InversePermute [Maybe a] [Maybe a]
instance InversePermute [Maybe a] (IntMap a)
instance InversePermute [Maybe a] [(Int, a)]
instance Sized Permutation
instance Show Permutation

module Agda.Utils.Permutation.Tests

-- | All tests as collected by <a>quickCheckAll</a>.
tests :: IO Bool
instance Eq ComposablePermutations
instance Show ComposablePermutations
instance Arbitrary ComposablePermutations
instance Arbitrary Permutation


-- | Sparse matrices.
--   
--   We assume the matrices to be very sparse, so we just implement them as
--   sorted association lists.
--   
--   Most operations are linear in the number of non-zero elements.
--   
--   An exception is transposition, which needs to sort the association
--   list again; it has the complexity of sorting: <tt>n log n</tt> where
--   <tt>n</tt> is the number of non-zero elements.
--   
--   Another exception is matrix multiplication, of course.
module Agda.Termination.SparseMatrix

-- | Type of matrices, parameterised on the type of values.
--   
--   Sparse matrices are implemented as an ordered association list,
--   mapping coordinates to values.
data Matrix i b

-- | Matrix indices are lexicographically sorted with no duplicates. All
--   indices must be within bounds.
matrixInvariant :: (Num i, Ix i, HasZero b) => Matrix i b -> Bool

-- | Size of a matrix.
data Size i
Size :: i -> i -> Size i

-- | Number of rows, <tt>&gt;= 0</tt>.
rows :: Size i -> i

-- | Number of columns, <tt>&gt;= 0</tt>.
cols :: Size i -> i

-- | Size invariant: dimensions are non-negative.
sizeInvariant :: (Ord i, Num i) => Size i -> Bool

-- | Type of matrix indices (row, column).
data MIx i
MIx :: i -> i -> MIx i

-- | Row index, <tt>1 &lt;= row &lt;= rows</tt>.
row :: MIx i -> i

-- | Column index <tt>1 &lt;= col &lt;= cols</tt>.
col :: MIx i -> i

-- | Indices must be positive, <tt>&gt;= 1</tt>.
mIxInvariant :: (Ord i, Num i) => MIx i -> Bool

-- | <tt><a>fromLists</a> sz rs</tt> constructs a matrix from a list of
--   lists of values (a list of rows). <tt>O(size)</tt> where <tt>size =
--   rows × cols</tt>.
--   
--   Precondition: <tt><a>length</a> rs <a>==</a> <a>rows</a> sz</tt> and
--   <tt><a>all</a> ((<a>cols</a> sz <a>==</a>) . <a>length</a>) rs</tt>.
fromLists :: (Ord i, Num i, Enum i, HasZero b) => Size i -> [[b]] -> Matrix i b

-- | Constructs a matrix from a list of <tt>(index, value)</tt>-pairs.
--   <tt>O(n)</tt> where <tt>n</tt> is size of the list.
--   
--   Precondition: indices are unique.
fromIndexList :: (Ord i, HasZero b) => Size i -> [(MIx i, b)] -> Matrix i b

-- | Converts a matrix to a list of row lists. <tt>O(size)</tt> where
--   <tt>size = rows × cols</tt>.
toLists :: (Integral i, HasZero b) => Matrix i b -> [[b]]

-- | Generates a matrix of the given size.
matrix :: (Arbitrary i, Integral i, Arbitrary b, HasZero b) => Size i -> Gen (Matrix i b)

-- | Generates a matrix of the given size, using the given generator to
--   generate the rows.
matrixUsingRowGen :: (Arbitrary i, Integral i, Arbitrary b, HasZero b) => Size i -> (i -> Gen [b]) -> Gen (Matrix i b)

-- | Dimensions of the matrix.
size :: Matrix i b -> Size i

-- | <a>True</a> iff the matrix is square.
square :: Ix i => Matrix i b -> Bool

-- | Returns <a>True</a> iff the matrix is empty.
isEmpty :: (Num i, Ix i) => Matrix i b -> Bool

-- | Returns 'Just b' iff it is a 1x1 matrix with just one entry
--   <tt>b</tt>. <tt>O(1)</tt>.
isSingleton :: (Eq i, Num i, HasZero b) => Matrix i b -> Maybe b

-- | General pointwise combination function for sparse matrices. <tt>O(n1 +
--   n2)</tt>.
zipMatrices :: Ord i => (a -> c) -> (b -> c) -> (a -> b -> c) -> (c -> Bool) -> Matrix i a -> Matrix i b -> Matrix i c

-- | <tt><a>add</a> (+) m1 m2</tt> adds <tt>m1</tt> and <tt>m2</tt>, using
--   <tt>(+)</tt> to add values. <tt>O(n1 + n2)</tt>.
--   
--   Returns a matrix of size <tt><a>supSize</a> m1 m2</tt>.
add :: (Ord i, HasZero a) => (a -> a -> a) -> Matrix i a -> Matrix i a -> Matrix i a

-- | <tt><a>intersectWith</a> f m1 m2</tt> build the pointwise conjunction
--   <tt>m1</tt> and <tt>m2</tt>. Uses <tt>f</tt> to combine non-zero
--   values. <tt>O(n1 + n2)</tt>.
--   
--   Returns a matrix of size <tt>infSize m1 m2</tt>.
intersectWith :: Ord i => (a -> a -> a) -> Matrix i a -> Matrix i a -> Matrix i a

-- | <tt><a>mul</a> semiring m1 m2</tt> multiplies matrices <tt>m1</tt> and
--   <tt>m2</tt>. Uses the operations of the semiring <tt>semiring</tt> to
--   perform the multiplication.
--   
--   <tt>O(n1 + n2 log n2 + Σ(i &lt;= r1) Σ(j &lt;= c2) d(i,j))</tt> where
--   <tt>r1</tt> is the number of non-empty rows in <tt>m1</tt> and
--   <tt>c2</tt> is the number of non-empty columns in <tt>m2</tt> and
--   <tt>d(i,j)</tt> is the bigger one of the following two quantifies: the
--   length of sparse row <tt>i</tt> in <tt>m1</tt> and the length of
--   sparse column <tt>j</tt> in <tt>m2</tt>.
--   
--   Given dimensions <tt>m1 : r1 × c1</tt> and <tt>m2 : r2 × c2</tt>, a
--   matrix of size <tt>r1 × c2</tt> is returned. It is not necessary that
--   <tt>c1 == r2</tt>, the matrices are implicitly patched with zeros to
--   match up for multiplication. For sparse matrices, this patching is a
--   no-op.
mul :: (Enum i, Num i, Ix i, Eq a) => Semiring a -> Matrix i a -> Matrix i a -> Matrix i a
transpose :: Transpose a => a -> a

-- | <tt><a>diagonal</a> m</tt> extracts the diagonal of <tt>m</tt>.
--   
--   For non-square matrices, the length of the diagonal is the minimum of
--   the dimensions of the matrix.
class Diagonal m e | m -> e
diagonal :: Diagonal m e => m -> [e]

-- | <tt><a>addRow</a> x m</tt> adds a new row to <tt>m</tt>, after the
--   rows already existing in the matrix. All elements in the new row get
--   set to <tt>x</tt>.
addRow :: (Num i, HasZero b) => b -> Matrix i b -> Matrix i b

-- | <tt><a>addColumn</a> x m</tt> adds a new column to <tt>m</tt>, after
--   the columns already existing in the matrix. All elements in the new
--   column get set to <tt>x</tt>.
addColumn :: (Num i, HasZero b) => b -> Matrix i b -> Matrix i b
tests :: IO Bool
instance Eq i => Eq (Size i)
instance Ord i => Ord (Size i)
instance Show i => Show (Size i)
instance Eq i => Eq (MIx i)
instance Ord i => Ord (MIx i)
instance Show i => Show (MIx i)
instance Ix i => Ix (MIx i)
instance (Eq i, Eq b) => Eq (Matrix i b)
instance (Ord i, Ord b) => Ord (Matrix i b)
instance Functor (Matrix i)
instance Foldable (Matrix i)
instance Traversable (Matrix i)
instance (Show i, Ord i, Integral i, Enum i, Ix i, CoArbitrary b, HasZero b) => CoArbitrary (Matrix i b)
instance (Arbitrary i, Num i, Integral i, Arbitrary b, HasZero b) => Arbitrary (Matrix i b)
instance CoArbitrary i => CoArbitrary (MIx i)
instance (Arbitrary i, Integral i) => Arbitrary (MIx i)
instance CoArbitrary i => CoArbitrary (Size i)
instance (Arbitrary i, Integral i) => Arbitrary (Size i)
instance (Integral i, HasZero b, Pretty b) => Pretty (Matrix i b)
instance (Integral i, HasZero b, Show i, Show b) => Show (Matrix i b)
instance Ord i => Transpose (Matrix i b)
instance Transpose (MIx i)
instance Transpose (Size i)
instance (Integral i, HasZero b) => Diagonal (Matrix i b) b


-- | An Abstract domain of relative sizes, i.e., differences between size
--   of formal function parameter and function argument in recursive call;
--   used in the termination checker.
module Agda.Termination.Order

-- | In the paper referred to above, there is an order R with
--   <tt><a>Unknown</a> <a>&lt;=</a> <tt>Le</tt> <a>&lt;=</a>
--   <tt>Lt</tt></tt>.
--   
--   This is generalized to <tt><a>Unknown</a> <a>&lt;=</a> 'Decr k'</tt>
--   where <tt>Decr 1</tt> replaces <tt>Lt</tt> and <tt>Decr 0</tt>
--   replaces <tt>Le</tt>. A negative decrease means an increase. The
--   generalization allows the termination checker to record an increase by
--   1 which can be compensated by a following decrease by 2 which results
--   in an overall decrease.
--   
--   However, the termination checker of the paper itself terminates
--   because there are only finitely many different call-matrices. To
--   maintain termination of the terminator we set a <tt>cutoff</tt> point
--   which determines how high the termination checker can count. This
--   value should be set by a global or file-wise option.
--   
--   See <tt>Call</tt> for more information.
--   
--   TODO: document orders which are call-matrices themselves.
data Order

-- | Matrix-shaped order, currently UNUSED.
Mat :: {-# UNPACK #-} !(Matrix Int Order) -> Order

-- | Smart constructor for <tt>Decr k :: Order</tt> which cuts off too big
--   values.
--   
--   Possible values for <tt>k</tt>: <tt>- ?cutoff <a>&lt;=</a> k
--   <a>&lt;=</a> ?cutoff + 1</tt>.
decr :: ?cutoff :: CutOff => Int -> Order

-- | Raw increase which does not cut off.
increase :: Int -> Order -> Order

-- | Raw decrease which does not cut off.
decrease :: Int -> Order -> Order

-- | Multiplication of <a>Order</a>s. (Corresponds to sequential
--   composition.)
(.*.) :: ?cutoff :: CutOff => Order -> Order -> Order

-- | The supremum of a (possibly empty) list of <a>Order</a>s. More
--   information (i.e., more decrease) is bigger. <a>Unknown</a> is no
--   information, thus, smallest.
supremum :: ?cutoff :: CutOff => [Order] -> Order

-- | The infimum of a (non empty) list of <a>Order</a>s. <a>Unknown</a> is
--   the least element, thus, dominant.
infimum :: ?cutoff :: CutOff => [Order] -> Order
orderSemiring :: ?cutoff :: CutOff => Semiring Order

-- | <tt>le</tt>, <tt>lt</tt>, <tt>decreasing</tt>, <tt>unknown</tt>: for
--   backwards compatibility, and for external use.
le :: Order
lt :: Order
unknown :: Order

-- | Smart constructor for matrix shaped orders, avoiding empty and
--   singleton matrices.
orderMat :: Matrix Int Order -> Order
collapseO :: ?cutoff :: CutOff => Order -> Order
nonIncreasing :: Order -> Bool
decreasing :: Order -> Bool

-- | Matrix-shaped order is decreasing if any diagonal element is
--   decreasing.
isDecr :: Order -> Bool

-- | A partial order, aimed at deciding whether a call graph gets worse
--   during the completion.
class NotWorse a
notWorse :: NotWorse a => a -> a -> Bool
tests :: IO Bool
instance Eq Order
instance Ord Order
instance CoArbitrary Order
instance Arbitrary Order
instance Pretty Order
instance Ord i => NotWorse (Matrix i Order)
instance NotWorse Order
instance (Ord i, PartialOrd a) => PartialOrd (Matrix i a)
instance PartialOrd Order
instance HasZero Order
instance Show Order

module Agda.Termination.CallMatrix

-- | Call matrix indices = function argument indices.
--   
--   Machine integer <a>Int</a> is sufficient, since we cannot index more
--   arguments than we have addresses on our machine.
type ArgumentIndex = Int

-- | Call matrices.
--   
--   A call matrix for a call <tt>f --&gt; g</tt> has dimensions <tt>ar(g)
--   × ar(f)</tt>.
--   
--   Each column corresponds to one formal argument of caller <tt>f</tt>.
--   Each row corresponds to one argument in the call to <tt>g</tt>.
--   
--   In the presence of dot patterns, a call argument can be related to
--   <i>several</i> different formal arguments of <tt>f</tt>.
--   
--   See e.g. <tt>test<i>succeed</i>DotPatternTermination.agda</tt>:
--   
--   <pre>
--   data D : Nat -&gt; Set where
--     cz : D zero
--     c1 : forall n -&gt; D n -&gt; D (suc n)
--     c2 : forall n -&gt; D n -&gt; D n
--   
--   f : forall n -&gt; D n -&gt; Nat
--   f .zero    cz        = zero
--   f .(suc n) (c1  n d) = f n (c2 n d)
--   f n        (c2 .n d) = f n d
--   
--   </pre>
--   
--   Call matrices (without guardedness) are
--   
--   <pre>
--   -1 -1   n &lt; suc n  and       n &lt;  c1 n d
--    ?  =                   c2 n d &lt;= c1 n d
--   
--    = -1   n &lt;= n     and  n &lt; c2 n d
--    ? -1                   d &lt; c2 n d
--   
--   </pre>
--   
--   Here is a part of the original documentation for call matrices (kept
--   for historical reasons):
--   
--   This datatype encodes information about a single recursive function
--   application. The columns of the call matrix stand for <tt>source</tt>
--   function arguments (patterns). The rows of the matrix stand for
--   <tt>target</tt> function arguments. Element <tt>(i, j)</tt> in the
--   matrix should be computed as follows:
--   
--   <ul>
--   <li><a>lt</a> (less than) if the <tt>j</tt>-th argument to the
--   <tt>target</tt> function is structurally strictly smaller than the
--   <tt>i</tt>-th pattern.<ul><li><a>le</a> (less than or equal) if the
--   <tt>j</tt>-th argument to the <tt>target</tt> function is structurally
--   smaller than the <tt>i</tt>-th pattern.</li><li><a>unknown</a>
--   otherwise.</li></ul></li>
--   </ul>
newtype CallMatrix' a
CallMatrix :: Matrix ArgumentIndex a -> CallMatrix' a
mat :: CallMatrix' a -> Matrix ArgumentIndex a
type CallMatrix = CallMatrix' Order

-- | Call matrix multiplication and call combination.
class CallComb a
(>*<) :: (CallComb a, ?cutoff :: CutOff) => a -> a -> a

-- | Call matrix multiplication.
--   
--   <tt>f --(m1)--&gt; g --(m2)--&gt; h</tt> is combined to <tt>f --(m2
--   <a>mul</a> m1)--&gt; h</tt>
--   
--   Note the reversed order of multiplication: The matrix <tt>c1</tt> of
--   the second call <tt>g--&gt;h</tt> in the sequence
--   <tt>f--&gt;g--&gt;h</tt> is multiplied with the matrix <tt>c2</tt> of
--   the first call.
--   
--   Preconditions: <tt>m1</tt> has dimensions <tt>ar(g) × ar(f)</tt>.
--   <tt>m2</tt> has dimensions <tt>ar(h) × ar(g)</tt>.
--   
--   Postcondition: <tt>m1 &gt;*&lt; m2</tt> has dimensions <tt>ar(h) ×
--   ar(f)</tt>.

-- | Call matrix augmented with path information.
data CallMatrixAug cinfo
CallMatrixAug :: CallMatrix -> cinfo -> CallMatrixAug cinfo

-- | The matrix of the (composed call).
augCallMatrix :: CallMatrixAug cinfo -> CallMatrix

-- | Meta info, like call path.
augCallInfo :: CallMatrixAug cinfo -> cinfo

-- | Augmented call matrix multiplication.

-- | Non-augmented call matrix.
noAug :: Monoid cinfo => CallMatrix -> CallMatrixAug cinfo
newtype CMSet cinfo
CMSet :: Favorites (CallMatrixAug cinfo) -> CMSet cinfo
cmSet :: CMSet cinfo -> Favorites (CallMatrixAug cinfo)

-- | Call matrix set product is the Cartesian product.

-- | An empty call matrix set.
empty :: CMSet cinfo

-- | Call matrix is empty?
null :: CMSet cinfo -> Bool

-- | A singleton call matrix set.
singleton :: CallMatrixAug cinfo -> CMSet cinfo

-- | Insert into a call matrix set.
insert :: CallMatrixAug cinfo -> CMSet cinfo -> CMSet cinfo

-- | Union two call matrix sets.
union :: CMSet cinfo -> CMSet cinfo -> CMSet cinfo

-- | Convert into a list of augmented call matrices.
toList :: CMSet cinfo -> [CallMatrixAug cinfo]

-- | Generates a call matrix of the given size.
callMatrix :: Size ArgumentIndex -> Gen CallMatrix
tests :: IO Bool
instance NotWorse (CallMatrix' Order)
instance Eq a => Eq (CallMatrix' a)
instance Ord a => Ord (CallMatrix' a)
instance (Show a, HasZero a) => Show (CallMatrix' a)
instance Functor CallMatrix'
instance Foldable CallMatrix'
instance Traversable CallMatrix'
instance (CoArbitrary a, HasZero a) => CoArbitrary (CallMatrix' a)
instance PartialOrd a => PartialOrd (CallMatrix' a)
instance Eq cinfo => Eq (CallMatrixAug cinfo)
instance Show cinfo => Show (CallMatrixAug cinfo)
instance Show cinfo => Show (CMSet cinfo)
instance Arbitrary cinfo => Arbitrary (CMSet cinfo)
instance CoArbitrary cinfo => CoArbitrary (CMSet cinfo)
instance Monoid (CMSet cinfo)
instance CoArbitrary cinfo => CoArbitrary (CallMatrixAug cinfo)
instance Arbitrary cinfo => Arbitrary (CallMatrixAug cinfo)
instance Arbitrary CallMatrix
instance Pretty cinfo => Pretty (CMSet cinfo)
instance Pretty cinfo => Pretty (CallMatrixAug cinfo)
instance Pretty CallMatrix
instance Monoid cinfo => CallComb (CMSet cinfo)
instance Monoid cinfo => CallComb (CallMatrixAug cinfo)
instance NotWorse (CallMatrixAug cinfo)
instance PartialOrd (CallMatrixAug cinfo)
instance Diagonal (CallMatrixAug cinfo) Order
instance CallComb CallMatrix
instance HasZero a => Diagonal (CallMatrix' a) a


-- | Call graphs and related concepts, more or less as defined in "A
--   Predicative Analysis of Structural Recursion" by Andreas Abel and
--   Thorsten Altenkirch.
module Agda.Termination.CallGraph

-- | Call graph nodes.
--   
--   Machine integer <a>Int</a> is sufficient, since we cannot index more
--   than we have addresses on our machine.
type Node = Int

-- | Calls are edges in the call graph. It can be labelled with several
--   call matrices if there are several pathes from one function to
--   another.
type Call cinfo = Edge Node Node (CMSet cinfo)

-- | Make a call with a single matrix.
mkCall :: Node -> Node -> CallMatrix -> cinfo -> Call cinfo

-- | Make a call with empty <tt>cinfo</tt>.
mkCall' :: Monoid cinfo => Node -> Node -> CallMatrix -> Call cinfo

-- | Outgoing node.
source :: Edge s t e -> s

-- | Incoming node.
target :: Edge s t e -> t
callMatrixSet :: Call cinfo -> CMSet cinfo
(>*<) :: (CallComb a, ?cutoff :: CutOff) => a -> a -> a

-- | A call graph is a set of calls. Every call also has some associated
--   meta information, which should be <a>Monoid</a>al so that the meta
--   information for different calls can be combined when the calls are
--   combined.
newtype CallGraph cinfo
CallGraph :: Graph Node Node (CMSet cinfo) -> CallGraph cinfo
theCallGraph :: CallGraph cinfo -> Graph Node Node (CMSet cinfo)

-- | Returns all the nodes with incoming edges. Somewhat expensive.
--   <tt>O(e)</tt>.
targetNodes :: CallGraph cinfo -> Set Node

-- | Converts a list of calls with associated meta information to a call
--   graph.
fromList :: Monoid cinfo => [Call cinfo] -> CallGraph cinfo

-- | Converts a call graph to a list of calls with associated meta
--   information.
toList :: CallGraph cinfo -> [Call cinfo]

-- | Creates an empty call graph.
empty :: CallGraph cinfo

-- | Check whether the call graph is completely disconnected.
null :: CallGraph cinfo -> Bool

-- | Takes the union of two call graphs.
union :: Monoid cinfo => CallGraph cinfo -> CallGraph cinfo -> CallGraph cinfo

-- | Inserts a call into a call graph.
insert :: Monoid cinfo => Node -> Node -> CallMatrix -> cinfo -> CallGraph cinfo -> CallGraph cinfo

-- | Call graph comparison. A graph <tt>cs'</tt> is ``worse'' than
--   <tt>cs</tt> if it has a new edge (call) or a call got worse, which
--   means that one of its elements that was better or equal to <tt>Le</tt>
--   moved a step towards <tt>Un</tt>.
--   
--   A call graph is complete if combining it with itself does not make it
--   any worse. This is sound because of monotonicity: By combining a graph
--   with itself, it can only get worse, but if it does not get worse after
--   one such step, it gets never any worse.
--   
--   <tt><a>complete</a> cs</tt> completes the call graph <tt>cs</tt>. A
--   call graph is complete if it contains all indirect calls; if <tt>f
--   -&gt; g</tt> and <tt>g -&gt; h</tt> are present in the graph, then
--   <tt>f -&gt; h</tt> should also be present.
complete :: ?cutoff :: CutOff => Monoid cinfo => CallGraph cinfo -> CallGraph cinfo
completionStep :: ?cutoff :: CutOff => Monoid cinfo => CallGraph cinfo -> CallGraph cinfo -> (CallGraph cinfo, CallGraph cinfo)
tests :: IO Bool
instance CombineNewOld (CMSet cinfo)
instance Show cinfo => Show (CallGraph cinfo)
instance Pretty cinfo => Pretty (CallGraph cinfo)
instance (Monoid a, CombineNewOld a, Ord s, Ord t) => CombineNewOld (Graph s t a)
instance PartialOrd a => CombineNewOld (Favorites a)
instance Monoid cinfo => Monoid (CallGraph cinfo)
instance Monoid cinfo => CallComb (Call cinfo)


-- | Termination checker, based on "A Predicative Analysis of Structural
--   Recursion" by Andreas Abel and Thorsten Altenkirch (JFP'01), and "The
--   Size-Change Principle for Program Termination" by Chin Soon Lee, Neil
--   Jones, and Amir Ben-Amram (POPL'01).
module Agda.Termination.Termination

-- | TODO: This comment seems to be partly out of date.
--   
--   <tt><a>terminates</a> cs</tt> checks if the functions represented by
--   <tt>cs</tt> terminate. The call graph <tt>cs</tt> should have one
--   entry (<a>Call</a>) per recursive function application.
--   
--   <tt><a>Right</a> perms</tt> is returned if the functions are
--   size-change terminating.
--   
--   If termination can not be established, then <tt><a>Left</a>
--   problems</tt> is returned instead. Here <tt>problems</tt> contains an
--   indication of why termination cannot be established. See
--   <tt>lexOrder</tt> for further details.
--   
--   Note that this function assumes that all data types are strictly
--   positive.
--   
--   The termination criterion is taken from Jones et al. In the completed
--   call graph, each idempotent call-matrix from a function to itself must
--   have a decreasing argument. Idempotency is wrt. matrix multiplication.
--   
--   This criterion is strictly more liberal than searching for a
--   lexicographic order (and easier to implement, but harder to justify).
terminates :: (Monoid cinfo, ?cutoff :: CutOff) => CallGraph cinfo -> Either cinfo ()
terminatesFilter :: (Monoid cinfo, ?cutoff :: CutOff) => (Node -> Bool) -> CallGraph cinfo -> Either cinfo ()
endos :: [Call cinfo] -> [CallMatrixAug cinfo]

-- | A call <tt>c</tt> is idempotent if it is an endo (<tt><a>source</a> ==
--   <a>target</a></tt>) of order 1. (Endo-calls of higher orders are e.g.
--   argument permutations). We can test idempotency by self-composition.
--   Self-composition <tt>c &gt;*&lt; c</tt> should not make any
--   parameter-argument relation worse.
idempotent :: ?cutoff :: CutOff => CallMatrixAug cinfo -> Bool
tests :: IO Bool


-- | A cut-down implementation of lenses, with names taken from Edward
--   Kmett's lens package.
module Agda.Utils.Lens

-- | Van Laarhoven style homogeneous lenses. Mnemoic: "Lens inner outer".
type Lens' i o = forall f. Functor f => (i -> f i) -> o -> f o

-- | Get inner part <tt>i</tt> of structure <tt>o</tt> as designated by
--   <tt>Lens' i o</tt>.
(^.) :: o -> Lens' i o -> i

-- | Set inner part <tt>i</tt> of structure <tt>o</tt> as designated by
--   <tt>Lens' i o</tt>.
set :: Lens' i o -> i -> o -> o

-- | Modify inner part <tt>i</tt> of structure <tt>o</tt> using a function
--   <tt>i -&gt; i</tt>.
over :: Lens' i o -> (i -> i) -> o -> o

-- | Read a part of the state.
use :: MonadState o m => Lens' i o -> m i

-- | Write a part of the state.
(.=) :: MonadState o m => Lens' i o -> i -> m ()

-- | Modify a part of the state.
(%=) :: MonadState o m => Lens' i o -> (i -> i) -> m ()

-- | Ask for part of read-only state.
view :: MonadReader o m => Lens' i o -> m i

-- | Modify a part of the state in a subcomputation.
locally :: MonadReader o m => Lens' i o -> (i -> i) -> m a -> m a

-- | Infix version of <a>for</a>.
(<&>) :: Functor m => m a -> (a -> b) -> m b


-- | This module defines the things required by Alex and some other Alex
--   related things.
module Agda.Syntax.Parser.Alex

-- | This is what the lexer manipulates.
data AlexInput
AlexInput :: !Position -> String -> !Char -> AlexInput

-- | current position
lexPos :: AlexInput -> !Position

-- | current input
lexInput :: AlexInput -> String

-- | previously read character
lexPrevChar :: AlexInput -> !Char

-- | A lens for <a>lexInput</a>.
lensLexInput :: Lens' String AlexInput

-- | Get the previously lexed character. Same as <a>lexPrevChar</a>. Alex
--   needs this to be defined to handle "patterns with a left-context".
alexInputPrevChar :: AlexInput -> Char

-- | Lex a character. No surprises.
--   
--   This function is used by Alex 2.
alexGetChar :: AlexInput -> Maybe (Char, AlexInput)

-- | A variant of <a>alexGetChar</a>.
--   
--   This function is used by Alex 3.
alexGetByte :: AlexInput -> Maybe (Word8, AlexInput)

-- | In the lexer, regular expressions are associated with lex actions
--   who's task it is to construct the tokens.
type LexAction r = PreviousInput -> CurrentInput -> TokenLength -> Parser r

-- | Sometimes regular expressions aren't enough. Alex provides a way to do
--   arbitrary computations to see if the input matches. This is done with
--   a lex predicate.
type LexPredicate = ([LexState], ParseFlags) -> PreviousInput -> TokenLength -> CurrentInput -> Bool

-- | Conjunction of <a>LexPredicate</a>s.
(.&&.) :: LexPredicate -> LexPredicate -> LexPredicate

-- | Disjunction of <a>LexPredicate</a>s.
(.||.) :: LexPredicate -> LexPredicate -> LexPredicate

-- | Negation of <a>LexPredicate</a>s.
not' :: LexPredicate -> LexPredicate
type PreviousInput = AlexInput
type CurrentInput = AlexInput
type TokenLength = Int
getLexInput :: Parser AlexInput
setLexInput :: AlexInput -> Parser ()


-- | When lexing by hands (for instance string literals) we need to do some
--   looking ahead. The <a>LookAhead</a> monad keeps track of the position
--   we are currently looking at, and provides facilities to synchronise
--   the look-ahead position with the actual position of the <a>Parser</a>
--   monad (see <a>sync</a> and <a>rollback</a>).
module Agda.Syntax.Parser.LookAhead

-- | The LookAhead monad is basically a state monad keeping with an extra
--   <a>AlexInput</a>, wrapped around the <a>Parser</a> monad.
data LookAhead a

-- | Run a <a>LookAhead</a> computation. The first argument is the error
--   function.
runLookAhead :: (forall b. String -> LookAhead b) -> LookAhead a -> Parser a

-- | Get the current look-ahead position.
getInput :: LookAhead AlexInput

-- | Set the look-ahead position.
setInput :: AlexInput -> LookAhead ()

-- | Lift a computation in the <a>Parser</a> monad to the <a>LookAhead</a>
--   monad.
liftP :: Parser a -> LookAhead a

-- | Look at the next character. Fails if there are no more characters.
nextChar :: LookAhead Char

-- | Consume the next character. Does <a>nextChar</a> followed by
--   <a>sync</a>.
eatNextChar :: LookAhead Char

-- | Consume all the characters up to the current look-ahead position.
sync :: LookAhead ()

-- | Undo look-ahead. Restores the input from the <a>ParseState</a>.
rollback :: LookAhead ()

-- | Do a case on the current input string. If any of the given strings
--   match we move past it and execute the corresponding action. If no
--   string matches, we execute a default action, advancing the input one
--   character. This function only affects the look-ahead position.
match :: [(String, LookAhead a)] -> LookAhead a -> LookAhead a

-- | Same as <a>match</a> but takes the initial character from the first
--   argument instead of reading it from the input. Consequently, in the
--   default case the input is not advanced.
match' :: Char -> [(String, LookAhead a)] -> LookAhead a -> LookAhead a
instance Functor LookAhead
instance Applicative LookAhead
instance Monad LookAhead


-- | Examples how to use <a>Lens</a>.
module Agda.Utils.Lens.Examples
data Record a b
Record :: a -> b -> Record a b
field1 :: Record a b -> a
field2 :: Record a b -> b

-- | (View source:) This is how you implement a lens for a record field.
lensField1 :: Lens' a (Record a b)
lensField2 :: Lens' b (Record a b)

module Agda.Interaction.Options
data CommandLineOptions
Options :: String -> Maybe FilePath -> IncludeDirs -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe FilePath -> Bool -> Bool -> Bool -> Maybe FilePath -> FilePath -> FilePath -> Maybe FilePath -> Bool -> Bool -> [String] -> PragmaOptions -> [String] -> Bool -> CommandLineOptions
optProgramName :: CommandLineOptions -> String
optInputFile :: CommandLineOptions -> Maybe FilePath
optIncludeDirs :: CommandLineOptions -> IncludeDirs
optShowVersion :: CommandLineOptions -> Bool
optShowHelp :: CommandLineOptions -> Bool
optInteractive :: CommandLineOptions -> Bool
optRunTests :: CommandLineOptions -> Bool
optGHCiInteraction :: CommandLineOptions -> Bool
optCompile :: CommandLineOptions -> Bool
optCompileNoMain :: CommandLineOptions -> Bool
optEpicCompile :: CommandLineOptions -> Bool
optJSCompile :: CommandLineOptions -> Bool

-- | In the absence of a path the project root is used.
optCompileDir :: CommandLineOptions -> Maybe FilePath
optGenerateVimFile :: CommandLineOptions -> Bool
optGenerateLaTeX :: CommandLineOptions -> Bool
optGenerateHTML :: CommandLineOptions -> Bool
optDependencyGraph :: CommandLineOptions -> Maybe FilePath
optLaTeXDir :: CommandLineOptions -> FilePath
optHTMLDir :: CommandLineOptions -> FilePath
optCSSFile :: CommandLineOptions -> Maybe FilePath
optIgnoreInterfaces :: CommandLineOptions -> Bool
optForcing :: CommandLineOptions -> Bool
optGhcFlags :: CommandLineOptions -> [String]
optPragmaOptions :: CommandLineOptions -> PragmaOptions
optEpicFlags :: CommandLineOptions -> [String]
optSafe :: CommandLineOptions -> Bool

-- | Options which can be set in a pragma.
data PragmaOptions
PragmaOptions :: Bool -> Bool -> Verbosity -> Bool -> Bool -> Bool -> Bool -> CutOff -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> PragmaOptions
optShowImplicit :: PragmaOptions -> Bool
optShowIrrelevant :: PragmaOptions -> Bool
optVerbose :: PragmaOptions -> Verbosity
optProofIrrelevance :: PragmaOptions -> Bool
optAllowUnsolved :: PragmaOptions -> Bool
optDisablePositivity :: PragmaOptions -> Bool
optTerminationCheck :: PragmaOptions -> Bool

-- | Cut off structural order comparison at some depth in termination
--   checker?
optTerminationDepth :: PragmaOptions -> CutOff
optCompletenessCheck :: PragmaOptions -> Bool
optUniverseCheck :: PragmaOptions -> Bool
optSizedTypes :: PragmaOptions -> Bool
optInjectiveTypeConstructors :: PragmaOptions -> Bool
optGuardingTypeConstructors :: PragmaOptions -> Bool
optUniversePolymorphism :: PragmaOptions -> Bool
optIrrelevantProjections :: PragmaOptions -> Bool

-- | irrelevant levels, irrelevant data matching
optExperimentalIrrelevance :: PragmaOptions -> Bool
optWithoutK :: PragmaOptions -> Bool

-- | Allow definitions by copattern matching?
optCopatterns :: PragmaOptions -> Bool

-- | Is pattern matching allowed in the current file?
optPatternMatching :: PragmaOptions -> Bool

-- | The options from an <tt>OPTIONS</tt> pragma.
--   
--   In the future it might be nice to switch to a more structured
--   representation. Note that, currently, there is not a one-to-one
--   correspondence between list elements and options.
type OptionsPragma = [String]

-- | <tt>f :: Flag opts</tt> is an action on the option record that results
--   from parsing an option. <tt>f opts</tt> produces either an error
--   message or an updated options record
type Flag opts = opts -> Either String opts
type Verbosity = Trie String Int
type IncludeDirs = Either [FilePath] [AbsolutePath]

-- | Checks that the given options are consistent.
checkOpts :: Flag CommandLineOptions

-- | Parse the standard options.
parseStandardOptions :: [String] -> Either String CommandLineOptions

-- | Parse options from an options pragma.
parsePragmaOptions :: [String] -> CommandLineOptions -> Either String PragmaOptions

-- | Parse options for a plugin.
parsePluginOptions :: [String] -> [OptDescr (Flag opts)] -> Flag opts
defaultOptions :: CommandLineOptions
defaultInteractionOptions :: PragmaOptions
defaultVerbosity :: Verbosity

-- | The default termination depth.
defaultCutOff :: CutOff

-- | Used for printing usage info.
standardOptions_ :: [OptDescr ()]
unsafePragmaOptions :: PragmaOptions -> [String]

-- | This should probably go somewhere else.
isLiterate :: FilePath -> Bool

-- | Map a function over the long options. Also removes the short options.
--   Will be used to add the plugin name to the plugin options.
mapFlag :: (String -> String) -> OptDescr a -> OptDescr a

-- | The usage info message. The argument is the program name (probably
--   agda).
usage :: [OptDescr ()] -> [(String, String, [String], [OptDescr ()])] -> String -> String
tests :: IO Bool
instance Show PragmaOptions
instance Show CommandLineOptions


-- | Abstract names carry unique identifiers and stuff.
module Agda.Syntax.Abstract.Name

-- | A name is a unique identifier and a suggestion for a concrete name.
--   The concrete name contains the source location (if any) of the name.
--   The source location of the binding site is also recorded.
data Name
Name :: NameId -> Name -> Range -> Fixity' -> Name
nameId :: Name -> NameId
nameConcrete :: Name -> Name
nameBindingSite :: Name -> Range
nameFixity :: Name -> Fixity'

-- | Qualified names are non-empty lists of names. Equality on qualified
--   names are just equality on the last name, i.e. the module part is just
--   for show.
--   
--   The <a>SetRange</a> instance for qualified names sets all individual
--   ranges (including those of the module prefix) to the given one.
data QName
QName :: ModuleName -> Name -> QName
qnameModule :: QName -> ModuleName
qnameName :: QName -> Name

-- | Something preceeded by a qualified name.
data QNamed a
QNamed :: QName -> a -> QNamed a
qname :: QNamed a -> QName
qnamed :: QNamed a -> a

-- | A module name is just a qualified name.
--   
--   The <a>SetRange</a> instance for module names sets all individual
--   ranges to the given one.
newtype ModuleName
MName :: [Name] -> ModuleName
mnameToList :: ModuleName -> [Name]

-- | Ambiguous qualified names. Used for overloaded constructors.
--   
--   Invariant: All the names in the list must have the same concrete,
--   unqualified name. (This implies that they all have the same
--   <a>Range</a>).
newtype AmbiguousQName
AmbQ :: [QName] -> AmbiguousQName
unAmbQ :: AmbiguousQName -> [QName]

-- | A module is anonymous if the qualification path ends in an underscore.
isAnonymousModuleName :: ModuleName -> Bool

-- | Sets the ranges of the individual names in the module name to match
--   those of the corresponding concrete names. If the concrete names are
--   fewer than the number of module name name parts, then the initial name
--   parts get the range <a>noRange</a>.
--   
--   <tt>C.D.E `withRangesOf` [A, B]</tt> returns <tt>C.D.E</tt> but with
--   ranges set as follows:
--   
--   <ul>
--   <li><tt>C</tt>: <a>noRange</a>.</li>
--   <li><tt>D</tt>: the range of <tt>A</tt>.</li>
--   <li><tt>E</tt>: the range of <tt>B</tt>.</li>
--   </ul>
--   
--   Precondition: The number of module name name parts has to be at least
--   as large as the length of the list.
withRangesOf :: ModuleName -> [Name] -> ModuleName

-- | Like <a>withRangesOf</a>, but uses the name parts (qualifier + name)
--   of the qualified name as the list of concrete names.
withRangesOfQ :: ModuleName -> QName -> ModuleName
mnameFromList :: [Name] -> ModuleName
noModuleName :: ModuleName

-- | Make a <a>Name</a> from some kind of string.
class MkName a where mkName_ = mkName noRange
mkName :: MkName a => Range -> NameId -> a -> Name
mkName_ :: MkName a => NameId -> a -> Name
qnameToList :: QName -> [Name]
qnameFromList :: [Name] -> QName
qnameToMName :: QName -> ModuleName
mnameToQName :: ModuleName -> QName
showQNameId :: QName -> String

-- | Turn a qualified name into a concrete name. This should only be used
--   as a fallback when looking up the right concrete name in the scope
--   fails.
qnameToConcrete :: QName -> QName
mnameToConcrete :: ModuleName -> QName

-- | Computes the <tt>TopLevelModuleName</tt> corresponding to the given
--   module name, which is assumed to represent a top-level module name.
--   
--   Precondition: The module name must be well-formed.
toTopLevelModuleName :: ModuleName -> TopLevelModuleName
qualifyM :: ModuleName -> ModuleName -> ModuleName
qualifyQ :: ModuleName -> QName -> QName
qualify :: ModuleName -> Name -> QName

-- | Convert a <a>Name</a> to a <a>QName</a> (add no module name).
qualify_ :: Name -> QName

-- | Is the name an operator?
isOperator :: QName -> Bool
isSubModuleOf :: ModuleName -> ModuleName -> Bool
isInModule :: QName -> ModuleName -> Bool

-- | Get the next version of the concrete name. For instance, <tt>nextName
--   "x" = "x₁"</tt>. The name must not be a <tt>NoName</tt>.
nextName :: Name -> Name

-- | An abstract name is empty if its concrete name is empty.

-- | Only use this <tt>show</tt> function in debugging! To convert an
--   abstract <a>Name</a> into a string use <tt>prettyShow</tt>.

-- | Only use this <tt>show</tt> function in debugging! To convert an
--   abstract <a>ModuleName</a> into a string use <tt>prettyShow</tt>.

-- | Only use this <tt>show</tt> function in debugging! To convert an
--   abstract <a>QName</a> into a string use <tt>prettyShow</tt>.

-- | The range of an <tt>AmbiguousQName</tt> is the range of any of its
--   disambiguations (they are the same concrete name).

-- | Check whether a name is the empty name "_".
class IsNoName a
isNoName :: IsNoName a => a -> Bool
instance Typeable Name
instance Typeable ModuleName
instance Typeable QName
instance Typeable QNamed
instance Typeable AmbiguousQName
instance Eq ModuleName
instance Ord ModuleName
instance Show a => Show (QNamed a)
instance Functor QNamed
instance Foldable QNamed
instance Traversable QNamed
instance Show AmbiguousQName
instance Sized ModuleName
instance Sized QName
instance KillRange AmbiguousQName
instance KillRange QName
instance KillRange ModuleName
instance KillRange Name
instance SetRange ModuleName
instance SetRange QName
instance SetRange Name
instance HasRange AmbiguousQName
instance HasRange QName
instance HasRange ModuleName
instance HasRange Name
instance Pretty QName
instance Pretty ModuleName
instance Pretty Name
instance Show QName
instance Show ModuleName
instance Show Name
instance IsNoName Name
instance Hashable QName
instance Ord QName
instance Eq QName
instance Hashable Name
instance Ord Name
instance Eq Name
instance MkName String

module Agda.Syntax.Literal
data Literal
LitInt :: Range -> Integer -> Literal
LitFloat :: Range -> Double -> Literal
LitString :: Range -> String -> Literal
LitChar :: Range -> Char -> Literal
LitQName :: Range -> QName -> Literal
showString' :: String -> ShowS
showChar' :: Char -> ShowS
instance Typeable Literal
instance KillRange Literal
instance SetRange Literal
instance HasRange Literal
instance Ord Literal
instance Eq Literal
instance Pretty Literal
instance Show Literal

module Agda.Syntax.Parser.Tokens
data Token
TokKeyword :: Keyword -> Interval -> Token
TokId :: (Interval, String) -> Token
TokQId :: [(Interval, String)] -> Token
TokLiteral :: Literal -> Token
TokSymbol :: Symbol -> Interval -> Token
TokString :: (Interval, String) -> Token
TokSetN :: (Interval, Integer) -> Token
TokTeX :: (Interval, String) -> Token
TokComment :: (Interval, String) -> Token
TokDummy :: Token
TokEOF :: Token
data Keyword
KwLet :: Keyword
KwIn :: Keyword
KwWhere :: Keyword
KwData :: Keyword
KwCoData :: Keyword
KwPostulate :: Keyword
KwMutual :: Keyword
KwAbstract :: Keyword
KwPrivate :: Keyword
KwInstance :: Keyword
KwOpen :: Keyword
KwImport :: Keyword
KwModule :: Keyword
KwPrimitive :: Keyword
KwInfix :: Keyword
KwInfixL :: Keyword
KwInfixR :: Keyword
KwWith :: Keyword
KwRewrite :: Keyword
KwSet :: Keyword
KwProp :: Keyword
KwForall :: Keyword
KwRecord :: Keyword
KwConstructor :: Keyword
KwField :: Keyword
KwInductive :: Keyword
KwCoInductive :: Keyword
KwHiding :: Keyword
KwUsing :: Keyword
KwRenaming :: Keyword
KwTo :: Keyword
KwPublic :: Keyword
KwOPTIONS :: Keyword
KwBUILTIN :: Keyword
KwLINE :: Keyword
KwCOMPILED_DATA :: Keyword
KwCOMPILED_TYPE :: Keyword
KwCOMPILED :: Keyword
KwCOMPILED_EXPORT :: Keyword
KwCOMPILED_EPIC :: Keyword
KwCOMPILED_JS :: Keyword
KwIMPORT :: Keyword
KwIMPOSSIBLE :: Keyword
KwETA :: Keyword
KwSTATIC :: Keyword
KwNO_TERMINATION_CHECK :: Keyword
KwTERMINATING :: Keyword
KwNON_TERMINATING :: Keyword
KwMEASURE :: Keyword
KwREWRITE :: Keyword
KwQuoteGoal :: Keyword
KwQuoteContext :: Keyword
KwQuote :: Keyword
KwQuoteTerm :: Keyword
KwUnquote :: Keyword
KwUnquoteDecl :: Keyword
KwSyntax :: Keyword
KwPatternSyn :: Keyword
KwTactic :: Keyword
layoutKeywords :: [Keyword]
data Symbol
SymDot :: Symbol
SymSemi :: Symbol
SymVirtualSemi :: Symbol
SymBar :: Symbol
SymColon :: Symbol
SymArrow :: Symbol
SymEqual :: Symbol
SymLambda :: Symbol
SymUnderscore :: Symbol
SymQuestionMark :: Symbol
SymAs :: Symbol
SymOpenParen :: Symbol
SymCloseParen :: Symbol
SymDoubleOpenBrace :: Symbol
SymDoubleCloseBrace :: Symbol
SymOpenBrace :: Symbol
SymCloseBrace :: Symbol
SymOpenVirtualBrace :: Symbol
SymCloseVirtualBrace :: Symbol
SymOpenPragma :: Symbol
SymClosePragma :: Symbol
SymEllipsis :: Symbol
SymDotDot :: Symbol

-- | A misplaced end-comment "-}".
SymEndComment :: Symbol
instance Eq Keyword
instance Show Keyword
instance Eq Symbol
instance Show Symbol
instance Eq Token
instance Show Token
instance HasRange Token


-- | This module defines the lex action to lex nested comments. As is
--   well-known this cannot be done by regular expressions (which,
--   incidently, is probably the reason why C-comments don't nest).
--   
--   When scanning nested comments we simply keep track of the nesting
--   level, counting up for <i>open comments</i> and down for <i>close
--   comments</i>.
module Agda.Syntax.Parser.Comments

-- | Should comment tokens be output?
keepComments :: LexPredicate

-- | Should comment tokens be output?
keepCommentsM :: Parser Bool

-- | Manually lexing a block comment. Assumes an <i>open comment</i> has
--   been lexed. In the end the comment is discarded and <a>lexToken</a> is
--   called to lex a real token.
nestedComment :: LexAction Token

-- | Lex a hole (<tt>{! ... !}</tt>). Holes can be nested. Returns
--   <tt><a>TokSymbol</a> <a>SymQuestionMark</a></tt>.
hole :: LexAction Token

-- | Skip a block of text enclosed by the given open and close strings.
--   Assumes the first open string has been consumed. Open-close pairs may
--   be nested.
skipBlock :: String -> String -> LookAhead ()


-- | The code to lex string and character literals. Basically the same code
--   as in GHC.
module Agda.Syntax.Parser.StringLiterals

-- | Lex a string literal. Assumes that a double quote has been lexed.
litString :: LexAction Token

-- | Lex a character literal. Assumes that a single quote has been lexed. A
--   character literal is lexed in exactly the same way as a string
--   literal. Only before returning the token do we check that the lexed
--   string is of length 1. This is maybe not the most efficient way of
--   doing things, but on the other hand it will only be inefficient if
--   there is a lexical error.
litChar :: LexAction Token


-- | The lexer is generated by Alex (<a>http://www.haskell.org/alex</a>)
--   and is an adaptation of GHC's lexer. The main lexing function
--   <a>lexer</a> is called by the <a>Agda.Syntax.Parser.Parser</a> to get
--   the next token from the input.
module Agda.Syntax.Parser.Lexer

-- | Return the next token. This is the function used by Happy in the
--   parser.
--   
--   <pre>
--   lexer k = <a>lexToken</a> &gt;&gt;= k
--   </pre>
lexer :: (Token -> Parser a) -> Parser a

-- | This is the initial state for parsing a regular, non-literate file.
normal :: LexState

-- | This is the initial state for parsing a literate file. Code blocks
--   should be enclosed in <tt>\begin{code}</tt> <tt>\end{code}</tt> pairs.
literate :: LexState
code :: Int

-- | The layout state. Entered when we see a layout keyword
--   (<a>withLayout</a>) and exited either when seeing an open brace
--   (<tt>openBrace</tt>) or at the next token (<a>newLayoutContext</a>).
--   
--   Update: we don't use braces for layout anymore.
layout :: LexState

-- | We enter this state from <a>newLayoutContext</a> when the token
--   following a layout keyword is to the left of (or at the same column
--   as) the current layout context. Example:
--   
--   <pre>
--   data Empty : Set where
--   foo : Empty -&gt; Nat
--   </pre>
--   
--   Here the second line is not part of the <tt>where</tt> clause since it
--   is has the same indentation as the <tt>data</tt> definition. What we
--   have to do is insert an empty layout block <tt>{}</tt> after the
--   <tt>where</tt>. The only thing that can happen in this state is that
--   <a>emptyLayout</a> is executed, generating the closing brace. The open
--   brace is generated when entering by <a>newLayoutContext</a>.
empty_layout :: LexState

-- | This state is entered at the beginning of each line. You can't lex
--   anything in this state, and to exit you have to check the layout rule.
--   Done with <a>offsideRule</a>.
bol :: LexState

-- | This state can only be entered by the parser. In this state you can
--   only lex the keywords <tt>using</tt>, <tt>hiding</tt>,
--   <tt>renaming</tt> and <tt>to</tt>. Moreover they are only keywords in
--   this particular state. The lexer will never enter this state by
--   itself, that has to be done in the parser.
imp_dir :: LexState
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a

-- | This is the main lexing function generated by Alex.
alexScanUser :: ([LexState], ParseFlags) -> AlexInput -> Int -> AlexReturn (LexAction Token)
instance Functor AlexLastAcc


-- | This module contains the building blocks used to construct the lexer.
module Agda.Syntax.Parser.LexActions

-- | Scan the input to find the next token. Calls <a>alexScanUser</a>. This
--   is the main lexing function where all the work happens. The function
--   <a>lexer</a>, used by the parser is the continuation version of this
--   function.
lexToken :: Parser Token

-- | The most general way of parsing a token.
token :: (String -> Parser tok) -> LexAction tok

-- | Parse a token from an <a>Interval</a> and the lexed string.
withInterval :: ((Interval, String) -> tok) -> LexAction tok

-- | Like <a>withInterval</a>, but applies a function to the string.
withInterval' :: (String -> a) -> ((Interval, a) -> tok) -> LexAction tok

-- | Return a token without looking at the lexed string.
withInterval_ :: (Interval -> r) -> LexAction r

-- | Executed for layout keywords. Enters the <a>layout</a> state and
--   performs the given action.
withLayout :: LexAction r -> LexAction r

-- | Enter a new state without consuming any input.
begin :: LexState -> LexAction Token

-- | Exit the current state without consuming any input
end :: LexAction Token

-- | Exit the current state and perform the given action.
endWith :: LexAction a -> LexAction a

-- | Enter a new state throwing away the current lexeme.
begin_ :: LexState -> LexAction Token

-- | Exit the current state throwing away the current lexeme.
end_ :: LexAction Token

-- | For lexical errors we want to report the current position as the site
--   of the error, whereas for parse errors the previous position is the
--   one we're interested in (since this will be the position of the token
--   we just lexed). This function does <a>parseErrorAt</a> the current
--   position.
lexError :: String -> Parser a

-- | Parse a <a>Keyword</a> token, triggers layout for
--   <a>layoutKeywords</a>.
keyword :: Keyword -> LexAction Token

-- | Parse a <a>Symbol</a> token.
symbol :: Symbol -> LexAction Token

-- | Parse an identifier. Identifiers can be qualified (see <tt>Name</tt>).
--   Example: <tt>Foo.Bar.f</tt>
identifier :: LexAction Token

-- | Parse a literal.
literal :: Read a => (Range -> a -> Literal) -> LexAction Token

-- | True when the given character is the next character of the input
--   string.
followedBy :: Char -> LexPredicate

-- | True if we are at the end of the file.
eof :: LexPredicate

-- | True if the given state appears somewhere on the state stack
inState :: LexState -> LexPredicate


-- | This module contains the lex actions that handle the layout rules. The
--   way it works is that the <a>Parser</a> monad keeps track of a stack of
--   <a>LayoutContext</a>s specifying the indentation of the layout blocks
--   in scope. For instance, consider the following incomplete (Haskell)
--   program:
--   
--   <pre>
--   f x = x'
--     where
--       x' = case x of { True -&gt; False; False -&gt; ...
--   </pre>
--   
--   At the <tt>...</tt> the layout context would be
--   
--   <pre>
--   [NoLayout, Layout 4, Layout 0]
--   </pre>
--   
--   The closest layout block is the one containing the <tt>case</tt>
--   branches. This block starts with an open brace (<tt>'{'</tt>) and so
--   doesn't use layout. The second closest block is the <tt>where</tt>
--   clause. Here, there is no open brace so the block is started by the
--   <tt>x'</tt> token which has indentation 4. Finally there is a
--   top-level layout block with indentation 0.
module Agda.Syntax.Parser.Layout

-- | Executed upon lexing an open brace (<tt>'{'</tt>). Enters the
--   <a>NoLayout</a> context.
openBrace :: LexAction Token

-- | Executed upon lexing a close brace (<tt>'}'</tt>). Exits the current
--   layout context. This might look a bit funny--the lexer will happily
--   use a close brace to close a context open by a virtual brace. This is
--   not a problem since the parser will make sure the braces are
--   appropriately matched.
closeBrace :: LexAction Token

-- | Executed for layout keywords. Enters the <a>layout</a> state and
--   performs the given action.
withLayout :: LexAction r -> LexAction r

-- | Executed for the first token in each line (see <a>bol</a>). Checks the
--   position of the token relative to the current layout context. If the
--   token is
--   
--   <ul>
--   <li><i>to the left</i> : Exit the current context and a return virtual
--   close brace (stay in the <a>bol</a> state).<ul><li><i>same column</i>
--   : Exit the <a>bol</a> state and return a virtual semi
--   colon.</li><li><i>to the right</i> : Exit the <a>bol</a> state and
--   continue lexing.</li></ul>If the current block doesn't use layout
--   (i.e. it was started by <a>openBrace</a>) all positions are considered
--   to be <i>to the right</i>.</li>
--   </ul>
offsideRule :: LexAction Token

-- | Start a new layout context. This is one of two ways to get out of the
--   <a>layout</a> state (the other is <a>openBrace</a>). There are two
--   possibilities:
--   
--   <ul>
--   <li>The current token is to the right of the current layout context
--   (or we're in a no layout context).<ul><li>The current token is to the
--   left of or in the same column as the current context.</li></ul>In the
--   first case everything is fine and we enter a new layout context at the
--   column of the current token. In the second case we have an empty
--   layout block so we enter the <a>empty_layout</a> state. In both cases
--   we return a virtual open brace without consuming any input.Entering a
--   new state when we know we want to generate a virtual <tt>{}</tt> may
--   seem a bit roundabout. The thing is that we can only generate one
--   token at a time, so the way to generate two tokens is to generate the
--   first one and then enter a state in which the only thing you can do is
--   generate the second one.</li>
--   </ul>
newLayoutContext :: LexAction Token

-- | This action is only executed from the <a>empty_layout</a> state. It
--   will exit this state, enter the <a>bol</a> state, and return a virtual
--   close brace (closing the empty layout block started by
--   <a>newLayoutContext</a>).
emptyLayout :: LexAction Token


-- | Split tree for transforming pattern clauses into case trees.
--   
--   The coverage checker generates a split tree from the clauses. The
--   clause compiler uses it to transform clauses to case trees.
--   
--   The initial problem is a set of clauses. The root node designates on
--   which argument to split and has subtrees for all the constructors.
--   Splitting continues until there is only a single clause left at each
--   leaf of the split tree.
module Agda.TypeChecking.Coverage.SplitTree
type SplitTree = SplitTree' QName
type SplitTrees = SplitTrees' QName

-- | Abstract case tree shape.
data SplitTree' a

-- | No more splits coming. We are at a single, all-variable clause.
SplittingDone :: Int -> SplitTree' a

-- | The number of variables bound in the clause
splitBindings :: SplitTree' a -> Int

-- | A split is necessary.
SplitAt :: Int -> SplitTrees' a -> SplitTree' a

-- | Arg. no to split at.
splitArg :: SplitTree' a -> Int

-- | Sub split trees.
splitTrees :: SplitTree' a -> SplitTrees' a

-- | Split tree branching. A finite map from constructor names to
--   splittrees A list representation seems appropriate, since we are
--   expecting not so many constructors per data type, and there is no need
--   for random access.
type SplitTrees' a = [(a, SplitTree' a)]
data SplitTreeLabel a
SplitTreeLabel :: Maybe a -> Maybe Int -> Maybe Int -> SplitTreeLabel a

-- | <a>Nothing</a> for root of split tree
lblConstructorName :: SplitTreeLabel a -> Maybe a
lblSplitArg :: SplitTreeLabel a -> Maybe Int
lblBindings :: SplitTreeLabel a -> Maybe Int

-- | Convert a split tree into a <a>Tree</a> (for printing).
toTree :: SplitTree' a -> Tree (SplitTreeLabel a)
toTrees :: SplitTrees' a -> Forest (SplitTreeLabel a)
newtype CName
CName :: String -> CName
testSplitTreePrinting :: IO ()
instance Eq a => Eq (SplitTree' a)
instance Arbitrary CName
instance Show CName
instance Arbitrary a => Arbitrary (SplitTree' a)
instance Show a => Show (SplitTree' a)
instance Show a => Show (SplitTreeLabel a)


-- | The concrete syntax is a raw representation of the program text
--   without any desugaring at all. This is what the parser produces. The
--   idea is that if we figure out how to keep the concrete syntax around,
--   it can be printed exactly as the user wrote it.
module Agda.Syntax.Concrete

-- | Concrete expressions. Should represent exactly what the user wrote.
data Expr

-- | ex: <tt>x</tt>
Ident :: QName -> Expr

-- | ex: <tt>1</tt> or <tt>"foo"</tt>
Lit :: Literal -> Expr

-- | ex: <tt>?</tt> or <tt>{! ... !}</tt>
QuestionMark :: !Range -> (Maybe Nat) -> Expr

-- | ex: <tt>_</tt> or <tt>_A_5</tt>
Underscore :: !Range -> (Maybe String) -> Expr

-- | before parsing operators
RawApp :: !Range -> [Expr] -> Expr

-- | ex: <tt>e e</tt>, <tt>e {e}</tt>, or <tt>e {x = e}</tt>
App :: !Range -> Expr -> (NamedArg Expr) -> Expr

-- | ex: <tt>e + e</tt>
OpApp :: !Range -> QName -> [NamedArg (OpApp Expr)] -> Expr

-- | ex: <tt>e | e1 | .. | en</tt>
WithApp :: !Range -> Expr -> [Expr] -> Expr

-- | ex: <tt>{e}</tt> or <tt>{x=e}</tt>
HiddenArg :: !Range -> (Named_ Expr) -> Expr

-- | ex: <tt>{{e}}</tt> or <tt>{{x=e}}</tt>
InstanceArg :: !Range -> (Named_ Expr) -> Expr

-- | ex: <tt>\x {y} -&gt; e</tt> or <tt>\(x:A){y:B} -&gt; e</tt>
Lam :: !Range -> [LamBinding] -> Expr -> Expr

-- | ex: <tt>\ ()</tt>
AbsurdLam :: !Range -> Hiding -> Expr

-- | ex: <tt>\ { p11 .. p1a -&gt; e1 ; .. ; pn1 .. pnz -&gt; en }</tt>
ExtendedLam :: !Range -> [(LHS, RHS, WhereClause)] -> Expr

-- | ex: <tt>e -&gt; e</tt> or <tt>.e -&gt; e</tt> (NYI: <tt>{e} -&gt;
--   e</tt>)
Fun :: !Range -> Expr -> Expr -> Expr

-- | ex: <tt>(xs:e) -&gt; e</tt> or <tt>{xs:e} -&gt; e</tt>
Pi :: Telescope -> Expr -> Expr

-- | ex: <tt>Set</tt>
Set :: !Range -> Expr

-- | ex: <tt>Prop</tt>
Prop :: !Range -> Expr

-- | ex: <tt>Set0, Set1, ..</tt>
SetN :: !Range -> Integer -> Expr

-- | ex: <tt>record {x = a; y = b}</tt>
Rec :: !Range -> [(Name, Expr)] -> Expr

-- | ex: <tt>record e {x = a; y = b}</tt>
RecUpdate :: !Range -> Expr -> [(Name, Expr)] -> Expr

-- | ex: <tt>let Ds in e</tt>
Let :: !Range -> [Declaration] -> Expr -> Expr

-- | ex: <tt>(e)</tt>
Paren :: !Range -> Expr -> Expr

-- | ex: <tt>()</tt> or <tt>{}</tt>, only in patterns
Absurd :: !Range -> Expr

-- | ex: <tt>x@p</tt>, only in patterns
As :: !Range -> Name -> Expr -> Expr

-- | ex: <tt>.p</tt>, only in patterns
Dot :: !Range -> Expr -> Expr

-- | only used for printing telescopes
ETel :: Telescope -> Expr

-- | ex: <tt>quoteGoal x in e</tt>
QuoteGoal :: !Range -> Name -> Expr -> Expr

-- | ex: <tt>quoteContext ctx in e</tt>
QuoteContext :: !Range -> Name -> Expr -> Expr

-- | ex: <tt>quote</tt>, should be applied to a name
Quote :: !Range -> Expr

-- | ex: <tt>quoteTerm</tt>, should be applied to a term
QuoteTerm :: !Range -> Expr

-- | <pre>
--   tactic solve | subgoal1 | .. | subgoalN
--   </pre>
Tactic :: !Range -> Expr -> [Expr] -> Expr

-- | ex: <tt>unquote</tt>, should be applied to a term of type
--   <tt>Term</tt>
Unquote :: !Range -> Expr

-- | to print irrelevant things
DontCare :: Expr -> Expr

-- | ex: <tt>a = b</tt>, used internally in the parser
Equal :: !Range -> Expr -> Expr -> Expr
data OpApp e

-- | An abstraction inside a special syntax declaration (see Issue 358 why
--   we introduce this).
SyntaxBindingLambda :: !Range -> [LamBinding] -> e -> OpApp e
Ordinary :: e -> OpApp e
fromOrdinary :: e -> OpApp e -> e
appView :: Expr -> AppView

-- | The <a>Expr</a> is not an application.
data AppView
AppView :: Expr -> [NamedArg Expr] -> AppView

-- | A lambda binding is either domain free or typed.
type LamBinding = LamBinding' TypedBindings
data LamBinding' a

-- | . <tt>x</tt> or <tt>{x}</tt> or <tt>.x</tt> or <tt>.{x}</tt> or
--   <tt>{.x}</tt>
DomainFree :: ArgInfo -> BoundName -> LamBinding' a

-- | . <tt>(xs : e)</tt> or <tt>{xs : e}</tt>
DomainFull :: a -> LamBinding' a

-- | A sequence of typed bindings with hiding information. Appears in
--   dependent function spaces, typed lambdas, and telescopes.
type TypedBindings = TypedBindings' TypedBinding
data TypedBindings' a

-- | . <tt>(xs : e)</tt> or <tt>{xs : e}</tt>
TypedBindings :: !Range -> (Arg a) -> TypedBindings' a

-- | A typed binding.
type TypedBinding = TypedBinding' Expr
data TypedBinding' e

-- | Binding <tt>(x1 ... xn : A)</tt>.
TBind :: !Range -> [BoundName] -> e -> TypedBinding' e

-- | Let binding <tt>(let Ds)</tt> or <tt>(open M args)</tt>.
TLet :: !Range -> [Declaration] -> TypedBinding' e

-- | Color a TypeBinding. Used by Pretty.
data ColoredTypedBinding
WithColors :: [Color] -> TypedBinding -> ColoredTypedBinding
data BoundName
BName :: Name -> Name -> Fixity' -> BoundName
boundName :: BoundName -> Name

-- | for implicit function types the label matters and can't be
--   alpha-renamed
boundLabel :: BoundName -> Name
bnameFixity :: BoundName -> Fixity'
mkBoundName_ :: Name -> BoundName
mkBoundName :: Name -> Fixity' -> BoundName

-- | A telescope is a sequence of typed bindings. Bound variables are in
--   scope in later types.
type Telescope = [TypedBindings]
countTelVars :: Telescope -> Nat

-- | The representation type of a declaration. The comments indicate which
--   type in the intended family the constructor targets.
data Declaration

-- | Axioms and functions can be irrelevant. (Hiding should be NotHidden)
TypeSig :: ArgInfo -> Name -> Expr -> Declaration

-- | Record field, can be hidden and/or irrelevant.
Field :: Name -> (Arg Expr) -> Declaration
FunClause :: LHS -> RHS -> WhereClause -> Declaration

-- | lone data signature in mutual block
DataSig :: !Range -> Induction -> Name -> [LamBinding] -> Expr -> Declaration
Data :: !Range -> Induction -> Name -> [LamBinding] -> (Maybe Expr) -> [Constructor] -> Declaration

-- | lone record signature in mutual block
RecordSig :: !Range -> Name -> [LamBinding] -> Expr -> Declaration

-- | The optional name is a name for the record constructor.
Record :: !Range -> Name -> (Maybe (Ranged Induction)) -> (Maybe Name) -> [LamBinding] -> (Maybe Expr) -> [Declaration] -> Declaration
Infix :: Fixity -> [Name] -> Declaration

-- | notation declaration for a name
Syntax :: Name -> Notation -> Declaration
PatternSyn :: !Range -> Name -> [Arg Name] -> Pattern -> Declaration
Mutual :: !Range -> [Declaration] -> Declaration
Abstract :: !Range -> [Declaration] -> Declaration
Private :: !Range -> [Declaration] -> Declaration
InstanceB :: !Range -> [Declaration] -> Declaration
Postulate :: !Range -> [TypeSignatureOrInstanceBlock] -> Declaration
Primitive :: !Range -> [TypeSignature] -> Declaration
Open :: !Range -> QName -> ImportDirective -> Declaration
Import :: !Range -> QName -> (Maybe AsName) -> OpenShortHand -> ImportDirective -> Declaration
ModuleMacro :: !Range -> Name -> ModuleApplication -> OpenShortHand -> ImportDirective -> Declaration
Module :: !Range -> QName -> [TypedBindings] -> [Declaration] -> Declaration
UnquoteDecl :: !Range -> Name -> Expr -> Declaration
Pragma :: Pragma -> Declaration
data ModuleApplication

-- | <pre>
--   tel. M args
--   </pre>
SectionApp :: Range -> [TypedBindings] -> Expr -> ModuleApplication

-- | <pre>
--   M {{...}}
--   </pre>
RecordModuleIFS :: Range -> QName -> ModuleApplication

-- | Just type signatures.
type TypeSignature = Declaration

-- | Just type signatures or instance blocks.
type TypeSignatureOrInstanceBlock = Declaration

-- | A data constructor declaration is just a type signature.
type Constructor = TypeSignature

-- | The things you are allowed to say when you shuffle names between name
--   spaces (i.e. in <tt>import</tt>, <tt>namespace</tt>, or <tt>open</tt>
--   declarations).
data ImportDirective
ImportDirective :: !Range -> UsingOrHiding -> [Renaming] -> Bool -> ImportDirective
importDirRange :: ImportDirective -> !Range
usingOrHiding :: ImportDirective -> UsingOrHiding
renaming :: ImportDirective -> [Renaming]

-- | Only for <tt>open</tt>. Exports the opened names from the current
--   module.
publicOpen :: ImportDirective -> Bool
data UsingOrHiding
Hiding :: [ImportedName] -> UsingOrHiding
Using :: [ImportedName] -> UsingOrHiding

-- | An imported name can be a module or a defined name
data ImportedName
ImportedModule :: Name -> ImportedName
importedName :: ImportedName -> Name
ImportedName :: Name -> ImportedName
importedName :: ImportedName -> Name
data Renaming
Renaming :: ImportedName -> Name -> Range -> Renaming

-- | Rename from this name.
renFrom :: Renaming -> ImportedName

-- | To this one.
renTo :: Renaming -> Name

-- | The range of the "to" keyword. Retained for highlighting purposes.
renToRange :: Renaming -> Range
data AsName
AsName :: Name -> Range -> AsName

-- | The "as" name.
asName :: AsName -> Name

-- | The range of the "as" keyword. Retained for highlighting purposes.
asRange :: AsName -> Range

-- | Default is directive is <tt>private</tt> (use everything, but do not
--   export).
defaultImportDir :: ImportDirective
data OpenShortHand
DoOpen :: OpenShortHand
DontOpen :: OpenShortHand
type RewriteEqn = Expr
type WithExpr = Expr

-- | Left hand sides can be written in infix style. For example:
--   
--   <pre>
--   n + suc m = suc (n + m)
--   (f ∘ g) x = f (g x)
--   </pre>
--   
--   We use fixity information to see which name is actually defined.
data LHS

-- | original pattern, with-patterns, rewrite equations and
--   with-expressions
LHS :: Pattern -> [Pattern] -> [RewriteEqn] -> [WithExpr] -> LHS

-- | <pre>
--   f ps
--   </pre>
lhsOriginalPattern :: LHS -> Pattern

-- | <tt>| p</tt> (many)
lhsWithPattern :: LHS -> [Pattern]

-- | <tt>rewrite e</tt> (many)
lhsRewriteEqn :: LHS -> [RewriteEqn]

-- | <tt>with e</tt> (many)
lhsWithExpr :: LHS -> [WithExpr]

-- | new with-patterns, rewrite equations and with-expressions
Ellipsis :: Range -> [Pattern] -> [RewriteEqn] -> [WithExpr] -> LHS

-- | Concrete patterns. No literals in patterns at the moment.
data Pattern

-- | <tt>c</tt> or <tt>x</tt>
IdentP :: QName -> Pattern

-- | <pre>
--   quote
--   </pre>
QuoteP :: !Range -> Pattern

-- | <tt>p p'</tt> or <tt>p {x = p'}</tt>
AppP :: Pattern -> (NamedArg Pattern) -> Pattern

-- | <tt>p1..pn</tt> before parsing operators
RawAppP :: !Range -> [Pattern] -> Pattern

-- | eg: <tt>p =&gt; p'</tt> for operator <tt>_=&gt;_</tt>
OpAppP :: !Range -> QName -> [NamedArg Pattern] -> Pattern

-- | <tt>{p}</tt> or <tt>{x = p}</tt>
HiddenP :: !Range -> (Named_ Pattern) -> Pattern

-- | <tt>{{p}}</tt> or <tt>{{x = p}}</tt>
InstanceP :: !Range -> (Named_ Pattern) -> Pattern

-- | <pre>
--   (p)
--   </pre>
ParenP :: !Range -> Pattern -> Pattern

-- | <pre>
--   _
--   </pre>
WildP :: !Range -> Pattern

-- | <pre>
--   ()
--   </pre>
AbsurdP :: !Range -> Pattern

-- | <tt>x@p</tt> unused
AsP :: !Range -> Name -> Pattern -> Pattern

-- | <pre>
--   .e
--   </pre>
DotP :: !Range -> Expr -> Pattern

-- | <tt>0</tt>, <tt>1</tt>, etc.
LitP :: Literal -> Pattern

-- | Processed (scope-checked) intermediate form of the core <tt>f ps</tt>
--   of <a>LHS</a>. Corresponds to <a>lhsOriginalPattern</a>.
data LHSCore
LHSHead :: Name -> [NamedArg Pattern] -> LHSCore

-- | <pre>
--   f
--   </pre>
lhsDefName :: LHSCore -> Name

-- | <pre>
--   ps
--   </pre>
lhsPats :: LHSCore -> [NamedArg Pattern]
LHSProj :: QName -> [NamedArg Pattern] -> NamedArg LHSCore -> [NamedArg Pattern] -> LHSCore

-- | record projection identifier
lhsDestructor :: LHSCore -> QName

-- | side patterns
lhsPatsLeft :: LHSCore -> [NamedArg Pattern]

-- | main branch
lhsFocus :: LHSCore -> NamedArg LHSCore

-- | side patterns
lhsPatsRight :: LHSCore -> [NamedArg Pattern]
type RHS = RHS' Expr
data RHS' e

-- | No right hand side because of absurd match.
AbsurdRHS :: RHS' e
RHS :: e -> RHS' e
type WhereClause = WhereClause' [Declaration]
data WhereClause' decls

-- | No <tt>where</tt> clauses.
NoWhere :: WhereClause' decls

-- | Ordinary <tt>where</tt>.
AnyWhere :: decls -> WhereClause' decls

-- | Named where: <tt>module M where</tt>.
SomeWhere :: Name -> decls -> WhereClause' decls
data Pragma
OptionsPragma :: !Range -> [String] -> Pragma
BuiltinPragma :: !Range -> String -> Expr -> Pragma
RewritePragma :: !Range -> QName -> Pragma
CompiledDataPragma :: !Range -> QName -> String -> [String] -> Pragma
CompiledTypePragma :: !Range -> QName -> String -> Pragma
CompiledPragma :: !Range -> QName -> String -> Pragma
CompiledExportPragma :: !Range -> QName -> String -> Pragma
CompiledEpicPragma :: !Range -> QName -> String -> Pragma
CompiledJSPragma :: !Range -> QName -> String -> Pragma
StaticPragma :: !Range -> QName -> Pragma

-- | Invariant: The string must be a valid Haskell module name.
ImportPragma :: !Range -> String -> Pragma
ImpossiblePragma :: !Range -> Pragma
EtaPragma :: !Range -> QName -> Pragma
TerminationCheckPragma :: !Range -> (TerminationCheck Name) -> Pragma

-- | Modules: Top-level pragmas plus other top-level declarations.
type Module = ([Pragma], [Declaration])

-- | Decorating something with <tt>Fixity'</tt>.
data ThingWithFixity x
ThingWithFixity :: x -> Fixity' -> ThingWithFixity x

-- | Computes the top-level module name.
--   
--   Precondition: The <a>Module</a> has to be well-formed.
topLevelModuleName :: Module -> TopLevelModuleName

-- | Get the leftmost symbol in a pattern.
patternHead :: Pattern -> Maybe Name

-- | Get all the identifiers in a pattern in left-to-right order.
patternNames :: Pattern -> [Name]
mapLhsOriginalPattern :: (Pattern -> Pattern) -> LHS -> LHS
type Color = Expr
type Arg a = Arg Color a
type NamedArg a = NamedArg Color a
type ArgInfo = ArgInfo Color
instance Typeable BoundName
instance Typeable RHS'
instance Typeable WhereClause'
instance Typeable ImportedName
instance Typeable UsingOrHiding
instance Typeable Renaming
instance Typeable ImportDirective
instance Typeable AsName
instance Typeable OpenShortHand
instance Typeable Pragma
instance Typeable Expr
instance Typeable Declaration
instance Typeable ModuleApplication
instance Typeable TypedBinding'
instance Typeable TypedBindings'
instance Typeable LHS
instance Typeable Pattern
instance Typeable LamBinding'
instance Typeable OpApp
instance Typeable LHSCore
instance Functor RHS'
instance Foldable RHS'
instance Traversable RHS'
instance Functor WhereClause'
instance Foldable WhereClause'
instance Traversable WhereClause'
instance Eq ImportedName
instance Ord ImportedName
instance Show AsName
instance Eq OpenShortHand
instance Show OpenShortHand
instance Functor TypedBinding'
instance Foldable TypedBinding'
instance Traversable TypedBinding'
instance Functor TypedBindings'
instance Foldable TypedBindings'
instance Traversable TypedBindings'
instance Functor LamBinding'
instance Foldable LamBinding'
instance Traversable LamBinding'
instance Functor OpApp
instance Foldable OpApp
instance Traversable OpApp
instance KillRange WhereClause
instance KillRange UsingOrHiding
instance KillRange TypedBindings
instance KillRange TypedBinding
instance KillRange RHS
instance KillRange Renaming
instance KillRange Pragma
instance KillRange Pattern
instance KillRange e => KillRange (OpApp e)
instance KillRange ModuleApplication
instance KillRange LHS
instance KillRange LamBinding
instance KillRange ImportedName
instance KillRange ImportDirective
instance KillRange Expr
instance KillRange Declaration
instance KillRange BoundName
instance KillRange AsName
instance HasRange Pattern
instance HasRange AsName
instance HasRange Renaming
instance HasRange ImportedName
instance HasRange ImportDirective
instance HasRange UsingOrHiding
instance HasRange Pragma
instance HasRange RHS
instance HasRange LHSCore
instance HasRange LHS
instance HasRange Declaration
instance HasRange ModuleApplication
instance HasRange WhereClause
instance HasRange BoundName
instance HasRange LamBinding
instance HasRange TypedBinding
instance HasRange TypedBindings
instance HasRange Expr
instance HasRange e => HasRange (OpApp e)
instance Show ImportedName
instance NFData LHSCore
instance NFData Pattern
instance NFData Expr


-- | Pretty printer for the concrete syntax.
module Agda.Syntax.Concrete.Pretty
braces' :: Doc -> Doc
dbraces :: Doc -> Doc
bracesAndSemicolons :: [Doc] -> Doc
arrow :: Doc
lambda :: Doc
pHidden :: Pretty a => ArgInfo -> a -> Doc
pRelevance :: Pretty a => ArgInfo -> a -> Doc
newtype Tel
Tel :: Telescope -> Tel
pColors :: String -> [Color] -> Doc
smashTel :: Telescope -> Telescope
prettyOpApp :: Pretty a => QName -> [a] -> [Doc]
instance Pretty ImportedName
instance Pretty UsingOrHiding
instance Pretty ImportDirective
instance Pretty Pattern
instance Pretty [Pattern]
instance Pretty e => Pretty (Named_ e)
instance Pretty e => Pretty (Arg e)
instance Pretty Fixity'
instance Pretty Notation
instance Pretty GenPart
instance Pretty Fixity
instance Pretty Pragma
instance Pretty OpenShortHand
instance Pretty Declaration
instance Pretty ModuleApplication
instance Show ModuleApplication
instance Pretty [Declaration]
instance Pretty LHSCore
instance Show LHSCore
instance Pretty LHS
instance Show LHS
instance Pretty WhereClause
instance Show WhereClause
instance Pretty RHS
instance Pretty TypedBinding
instance Pretty ColoredTypedBinding
instance Pretty Tel
instance Pretty TypedBindings
instance Pretty LamBinding
instance Pretty BoundName
instance Pretty Expr
instance Pretty (OpApp Expr)
instance Pretty Induction
instance Pretty Relevance
instance Pretty (ThingWithFixity Name)
instance (Pretty a, Pretty b) => Pretty (a, b)
instance Show RHS
instance Show Pragma
instance Show ImportDirective
instance Show LamBinding
instance Show TypedBindings
instance Show TypedBinding
instance Show Pattern
instance Show Declaration
instance Show Expr


-- | This module defines the notion of a scope and operations on scopes.
module Agda.Syntax.Scope.Base

-- | A scope is a named collection of names partitioned into public and
--   private names.
data Scope
Scope :: ModuleName -> [ModuleName] -> ScopeNameSpaces -> Map QName ModuleName -> Bool -> Scope
scopeName :: Scope -> ModuleName
scopeParents :: Scope -> [ModuleName]
scopeNameSpaces :: Scope -> ScopeNameSpaces
scopeImports :: Scope -> Map QName ModuleName
scopeDatatypeModule :: Scope -> Bool

-- | See <a>Access</a>.
data NameSpaceId

-- | Things not exported by this module.
PrivateNS :: NameSpaceId

-- | Things defined and exported by this module.
PublicNS :: NameSpaceId

-- | Things from open public, exported by this module.
ImportedNS :: NameSpaceId

-- | Visible (as qualified) from outside, but not exported when opening the
--   module. Used for qualified constructors.
OnlyQualifiedNS :: NameSpaceId
type ScopeNameSpaces = [(NameSpaceId, NameSpace)]
localNameSpace :: Access -> NameSpaceId
nameSpaceAccess :: NameSpaceId -> Access

-- | Get a <a>NameSpace</a> from <a>Scope</a>.
scopeNameSpace :: NameSpaceId -> Scope -> NameSpace

-- | A lens for <a>scopeNameSpaces</a>
updateScopeNameSpaces :: (ScopeNameSpaces -> ScopeNameSpaces) -> Scope -> Scope

-- | ``Monadic'' lens (Functor sufficient).
updateScopeNameSpacesM :: Functor m => (ScopeNameSpaces -> m ScopeNameSpaces) -> Scope -> m Scope

-- | The complete information about the scope at a particular program point
--   includes the scope stack, the local variables, and the context
--   precedence.
data ScopeInfo
ScopeInfo :: ModuleName -> Map ModuleName Scope -> LocalVars -> Precedence -> ScopeInfo
scopeCurrent :: ScopeInfo -> ModuleName
scopeModules :: ScopeInfo -> Map ModuleName Scope
scopeLocals :: ScopeInfo -> LocalVars
scopePrecedence :: ScopeInfo -> Precedence

-- | Local variables.
type LocalVars = AssocList Name LocalVar

-- | A local variable can be shadowed by an import. In case of reference to
--   a shadowed variable, we want to report a scope error.
data LocalVar

-- | Unique ID of local variable.
LocalVar :: Name -> LocalVar
localVar :: LocalVar -> Name

-- | This local variable is shadowed by one or more imports. (List not
--   empty).
ShadowedVar :: Name -> [AbstractName] -> LocalVar
localVar :: LocalVar -> Name
localShadowedBy :: LocalVar -> [AbstractName]

-- | We show shadowed variables as prefixed by a ".", as not in scope.

-- | Shadow a local name by a non-empty list of imports.
shadowLocal :: [AbstractName] -> LocalVar -> LocalVar

-- | Project name of unshadowed local variable.
notShadowedLocal :: LocalVar -> Maybe Name

-- | Get all locals that are not shadowed.
notShadowedLocals :: LocalVars -> AssocList Name Name

-- | Lens for <a>scopeLocals</a>.
updateScopeLocals :: (LocalVars -> LocalVars) -> ScopeInfo -> ScopeInfo
setScopeLocals :: LocalVars -> ScopeInfo -> ScopeInfo

-- | A <tt>NameSpace</tt> contains the mappings from concrete names that
--   the user can write to the abstract fully qualified names that the type
--   checker wants to read.
data NameSpace
NameSpace :: NamesInScope -> ModulesInScope -> NameSpace

-- | Maps concrete names to a list of abstract names.
nsNames :: NameSpace -> NamesInScope

-- | Maps concrete module names to a list of abstract module names.
nsModules :: NameSpace -> ModulesInScope
type ThingsInScope a = Map Name [a]
type NamesInScope = ThingsInScope AbstractName
type ModulesInScope = ThingsInScope AbstractModule

-- | Set of types consisting of exactly <a>AbstractName</a> and
--   <a>AbstractModule</a>.
--   
--   A GADT just for some dependent-types trickery.
data InScopeTag a
NameTag :: InScopeTag AbstractName
ModuleTag :: InScopeTag AbstractModule

-- | Type class for some dependent-types trickery.
class Eq a => InScope a
inScopeTag :: InScope a => InScopeTag a

-- | <tt>inNameSpace</tt> selects either the name map or the module name
--   map from a <a>NameSpace</a>. What is selected is determined by result
--   type (using the dependent-type trickery).
inNameSpace :: InScope a => NameSpace -> ThingsInScope a

-- | For the sake of parsing left-hand sides, we distinguish constructor
--   and record field names from defined names.
data KindOfName

-- | Constructor name.
ConName :: KindOfName

-- | Record field name.
FldName :: KindOfName

-- | Ordinary defined name.
DefName :: KindOfName

-- | Name of a pattern synonym.
PatternSynName :: KindOfName

-- | A name that can only quoted.
QuotableName :: KindOfName

-- | A list containing all name kinds.
allKindsOfNames :: [KindOfName]

-- | Where does a name come from?
--   
--   This information is solely for reporting to the user, see
--   <a>whyInScope</a>.
data WhyInScope

-- | Defined in this module.
Defined :: WhyInScope

-- | Imported from another module.
Opened :: QName -> WhyInScope -> WhyInScope

-- | Imported by a module application.
Applied :: QName -> WhyInScope -> WhyInScope

-- | A decoration of <a>QName</a>.
data AbstractName
AbsName :: QName -> KindOfName -> WhyInScope -> AbstractName

-- | The resolved qualified name.
anameName :: AbstractName -> QName

-- | The kind (definition, constructor, record field etc.).
anameKind :: AbstractName -> KindOfName

-- | Explanation where this name came from.
anameLineage :: AbstractName -> WhyInScope

-- | A decoration of abstract syntax module names.
data AbstractModule
AbsModule :: ModuleName -> WhyInScope -> AbstractModule

-- | The resolved module name.
amodName :: AbstractModule -> ModuleName

-- | Explanation where this name came from.
amodLineage :: AbstractModule -> WhyInScope

-- | Van Laarhoven lens on <a>anameName</a>.
lensAnameName :: Functor m => (QName -> m QName) -> AbstractName -> m AbstractName

-- | Van Laarhoven lens on <a>amodName</a>.
lensAmodName :: Functor m => (ModuleName -> m ModuleName) -> AbstractModule -> m AbstractModule
mergeNames :: Eq a => ThingsInScope a -> ThingsInScope a -> ThingsInScope a

-- | The empty name space.
emptyNameSpace :: NameSpace

-- | Map functions over the names and modules in a name space.
mapNameSpace :: (NamesInScope -> NamesInScope) -> (ModulesInScope -> ModulesInScope) -> NameSpace -> NameSpace

-- | Zip together two name spaces.
zipNameSpace :: (NamesInScope -> NamesInScope -> NamesInScope) -> (ModulesInScope -> ModulesInScope -> ModulesInScope) -> NameSpace -> NameSpace -> NameSpace

-- | Map monadic function over a namespace.
mapNameSpaceM :: Applicative m => (NamesInScope -> m NamesInScope) -> (ModulesInScope -> m ModulesInScope) -> NameSpace -> m NameSpace

-- | The empty scope.
emptyScope :: Scope

-- | The empty scope info.
emptyScopeInfo :: ScopeInfo

-- | Map functions over the names and modules in a scope.
mapScope :: (NameSpaceId -> NamesInScope -> NamesInScope) -> (NameSpaceId -> ModulesInScope -> ModulesInScope) -> Scope -> Scope

-- | Same as <a>mapScope</a> but applies the same function to all name
--   spaces.
mapScope_ :: (NamesInScope -> NamesInScope) -> (ModulesInScope -> ModulesInScope) -> Scope -> Scope

-- | Map monadic functions over the names and modules in a scope.
mapScopeM :: (Functor m, Applicative m) => (NameSpaceId -> NamesInScope -> m NamesInScope) -> (NameSpaceId -> ModulesInScope -> m ModulesInScope) -> Scope -> m Scope

-- | Same as <a>mapScopeM</a> but applies the same function to both the
--   public and private name spaces.
mapScopeM_ :: (Functor m, Applicative m) => (NamesInScope -> m NamesInScope) -> (ModulesInScope -> m ModulesInScope) -> Scope -> m Scope

-- | Zip together two scopes. The resulting scope has the same name as the
--   first scope.
zipScope :: (NameSpaceId -> NamesInScope -> NamesInScope -> NamesInScope) -> (NameSpaceId -> ModulesInScope -> ModulesInScope -> ModulesInScope) -> Scope -> Scope -> Scope

-- | Same as <a>zipScope</a> but applies the same function to both the
--   public and private name spaces.
zipScope_ :: (NamesInScope -> NamesInScope -> NamesInScope) -> (ModulesInScope -> ModulesInScope -> ModulesInScope) -> Scope -> Scope -> Scope

-- | Filter a scope keeping only concrete names matching the predicates.
--   The first predicate is applied to the names and the second to the
--   modules.
filterScope :: (Name -> Bool) -> (Name -> Bool) -> Scope -> Scope

-- | Return all names in a scope.
allNamesInScope :: InScope a => Scope -> ThingsInScope a
allNamesInScope' :: InScope a => Scope -> ThingsInScope (a, Access)

-- | Returns the scope's non-private names.
exportedNamesInScope :: InScope a => Scope -> ThingsInScope a
namesInScope :: InScope a => [NameSpaceId] -> Scope -> ThingsInScope a
allThingsInScope :: Scope -> NameSpace
thingsInScope :: [NameSpaceId] -> Scope -> NameSpace

-- | Merge two scopes. The result has the name of the first scope.
mergeScope :: Scope -> Scope -> Scope

-- | Merge a non-empty list of scopes. The result has the name of the first
--   scope in the list.
mergeScopes :: [Scope] -> Scope

-- | Move all names in a scope to the given name space (except never move
--   from Imported to Public).
setScopeAccess :: NameSpaceId -> Scope -> Scope

-- | Update a particular name space.
setNameSpace :: NameSpaceId -> NameSpace -> Scope -> Scope

-- | Add names to a scope.
addNamesToScope :: NameSpaceId -> Name -> [AbstractName] -> Scope -> Scope

-- | Add a name to a scope.
addNameToScope :: NameSpaceId -> Name -> AbstractName -> Scope -> Scope

-- | Remove a name from a scope.
removeNameFromScope :: NameSpaceId -> Name -> Scope -> Scope

-- | Add a module to a scope.
addModuleToScope :: NameSpaceId -> Name -> AbstractModule -> Scope -> Scope

-- | Apply an <a>ImportDirective</a> to a scope.
applyImportDirective :: ImportDirective -> Scope -> Scope

-- | Rename the abstract names in a scope.
renameCanonicalNames :: Map QName QName -> Map ModuleName ModuleName -> Scope -> Scope

-- | Remove private name space of a scope.
--   
--   Should be a right identity for <a>exportedNamesInScope</a>.
--   <tt>exportedNamesInScope . restrictPrivate ==
--   exportedNamesInscope</tt>.
restrictPrivate :: Scope -> Scope

-- | Remove names that can only be used qualified (when opening a scope)
removeOnlyQualified :: Scope -> Scope

-- | Add an explanation to why things are in scope.
inScopeBecause :: (WhyInScope -> WhyInScope) -> Scope -> Scope

-- | Get the public parts of the public modules of a scope
publicModules :: ScopeInfo -> Map ModuleName Scope
everythingInScope :: ScopeInfo -> NameSpace

-- | Compute a flattened scope. Only include unqualified names or names
--   qualified by modules in the first argument.
flattenScope :: [[Name]] -> ScopeInfo -> Map QName [AbstractName]

-- | Look up a name in the scope
scopeLookup :: InScope a => QName -> ScopeInfo -> [a]
scopeLookup' :: InScope a => QName -> ScopeInfo -> [(a, Access)]
data AllowAmbiguousConstructors
AllowAmbiguousConstructors :: AllowAmbiguousConstructors
NoAmbiguousConstructors :: AllowAmbiguousConstructors

-- | Find the shortest concrete name that maps (uniquely) to a given
--   abstract name.
inverseScopeLookup :: Either ModuleName QName -> ScopeInfo -> Maybe QName
inverseScopeLookup' :: AllowAmbiguousConstructors -> Either ModuleName QName -> ScopeInfo -> Maybe QName

-- | Takes the first component of <a>inverseScopeLookup</a>.
inverseScopeLookupName :: QName -> ScopeInfo -> Maybe QName
inverseScopeLookupName' :: AllowAmbiguousConstructors -> QName -> ScopeInfo -> Maybe QName

-- | Takes the second component of <a>inverseScopeLookup</a>.
inverseScopeLookupModule :: ModuleName -> ScopeInfo -> Maybe QName

-- | Add first string only if list is non-empty.
blockOfLines :: String -> [String] -> [String]
instance Typeable NameSpaceId
instance Typeable KindOfName
instance Typeable WhyInScope
instance Typeable AbstractName
instance Typeable LocalVar
instance Typeable AbstractModule
instance Typeable NameSpace
instance Typeable Scope
instance Typeable ScopeInfo
instance Eq NameSpaceId
instance Bounded NameSpaceId
instance Enum NameSpaceId
instance Eq KindOfName
instance Show KindOfName
instance Enum KindOfName
instance Bounded KindOfName
instance Eq AllowAmbiguousConstructors
instance SetRange AbstractName
instance HasRange AbstractName
instance KillRange ScopeInfo
instance Show ScopeInfo
instance Show Scope
instance Show NameSpace
instance Show NameSpaceId
instance Show AbstractModule
instance Show AbstractName
instance Ord AbstractModule
instance Eq AbstractModule
instance Ord AbstractName
instance Eq AbstractName
instance InScope AbstractModule
instance InScope AbstractName
instance Show LocalVar
instance Ord LocalVar
instance Eq LocalVar
instance NFData LocalVar


-- | An info object contains additional information about a piece of
--   abstract syntax that isn't part of the actual syntax. For instance, it
--   might contain the source code position of an expression or the
--   concrete syntax that an internal expression originates from.
module Agda.Syntax.Info
data MetaInfo
MetaInfo :: Range -> ScopeInfo -> Maybe Nat -> String -> MetaInfo
metaRange :: MetaInfo -> Range
metaScope :: MetaInfo -> ScopeInfo

-- | The <tt>MetaId</tt>, not the <a>InteractionId</a>.
metaNumber :: MetaInfo -> Maybe Nat
metaNameSuggestion :: MetaInfo -> String
emptyMetaInfo :: MetaInfo
newtype ExprInfo
ExprRange :: Range -> ExprInfo
exprNoRange :: ExprInfo
data ModuleInfo
ModuleInfo :: Range -> Range -> Maybe Name -> Maybe OpenShortHand -> Maybe ImportDirective -> ModuleInfo
minfoRange :: ModuleInfo -> Range

-- | The range of the "as" and "to" keywords, if any. Retained for
--   highlighting purposes.
minfoAsTo :: ModuleInfo -> Range

-- | The "as" module name, if any. Retained for highlighting purposes.
minfoAsName :: ModuleInfo -> Maybe Name
minfoOpenShort :: ModuleInfo -> Maybe OpenShortHand

-- | Retained for <tt>abstractToConcrete</tt> of <a>ModuleMacro</a>.
minfoDirective :: ModuleInfo -> Maybe ImportDirective
newtype LetInfo
LetRange :: Range -> LetInfo
data DefInfo
DefInfo :: Fixity' -> Access -> IsAbstract -> IsInstance -> DeclInfo -> DefInfo
defFixity :: DefInfo -> Fixity'
defAccess :: DefInfo -> Access
defAbstract :: DefInfo -> IsAbstract
defInstance :: DefInfo -> IsInstance
defInfo :: DefInfo -> DeclInfo
mkDefInfo :: Name -> Fixity' -> Access -> IsAbstract -> Range -> DefInfo

-- | Same as <tt>mkDefInfo</tt> but where we can also give the
--   <tt>IsInstance</tt>
mkDefInfoInstance :: Name -> Fixity' -> Access -> IsAbstract -> IsInstance -> Range -> DefInfo
data DeclInfo
DeclInfo :: Name -> Range -> DeclInfo
declName :: DeclInfo -> Name
declRange :: DeclInfo -> Range
data MutualInfo
MutualInfo :: TerminationCheck Name -> Range -> MutualInfo
mutualTermCheck :: MutualInfo -> TerminationCheck Name
mutualRange :: MutualInfo -> Range
newtype LHSInfo
LHSRange :: Range -> LHSInfo

-- | For a general pattern we can either remember just the source code
--   position or the entire concrete pattern it came from.
data PatInfo
PatRange :: Range -> PatInfo

-- | Even if we store the original pattern we have to know whether to put
--   parenthesis around it.
PatSource :: Range -> (Precedence -> Pattern) -> PatInfo

-- | Empty range for patterns.
patNoRange :: PatInfo

-- | Constructor pattern info.
data ConPatInfo
ConPatInfo :: Bool -> PatInfo -> ConPatInfo

-- | Does this pattern come form the eta-expansion of an implicit pattern?
patImplicit :: ConPatInfo -> Bool
patInfo :: ConPatInfo -> PatInfo
instance Typeable MetaInfo
instance Typeable ExprInfo
instance Typeable ModuleInfo
instance Typeable LetInfo
instance Typeable DeclInfo
instance Typeable DefInfo
instance Typeable MutualInfo
instance Typeable LHSInfo
instance Typeable PatInfo
instance (Show OpenShortHand, Show ImportDirective) => Show ModuleInfo
instance Show MetaInfo
instance Show ExprInfo
instance Show LetInfo
instance Show DeclInfo
instance Show DefInfo
instance Show MutualInfo
instance Show LHSInfo
instance SetRange ConPatInfo
instance KillRange ConPatInfo
instance HasRange ConPatInfo
instance Show ConPatInfo
instance KillRange PatInfo
instance HasRange PatInfo
instance Show PatInfo
instance KillRange LHSInfo
instance HasRange LHSInfo
instance KillRange MutualInfo
instance HasRange MutualInfo
instance KillRange DeclInfo
instance SetRange DeclInfo
instance HasRange DeclInfo
instance KillRange DefInfo
instance SetRange DefInfo
instance HasRange DefInfo
instance KillRange LetInfo
instance HasRange LetInfo
instance KillRange ModuleInfo
instance SetRange ModuleInfo
instance HasRange ModuleInfo
instance KillRange ExprInfo
instance HasRange ExprInfo
instance KillRange MetaInfo
instance HasRange MetaInfo


-- | Utilities related to Geniplate.
module Agda.Utils.Geniplate

-- | A localised instance of <a>instanceUniverseBiT</a>. The generated
--   <a>universeBi</a> functions neither descend into the types in
--   <a>dontDescendInto</a>, nor into the types in the list argument.
instanceUniverseBiT' :: [TypeQ] -> TypeQ -> Q [Dec]

-- | A localised instance of <a>instanceTransformBiMT</a>. The generated
--   <a>transformBiM</a> functions neither descend into the types in
--   <a>dontDescendInto</a>, nor into the types in the list argument.
instanceTransformBiMT' :: [TypeQ] -> TypeQ -> TypeQ -> Q [Dec]

-- | Types which Geniplate should not descend into.
dontDescendInto :: [TypeQ]


-- | The abstract syntax. This is what you get after desugaring and scope
--   analysis of the concrete syntax. The type checker works on abstract
--   syntax, producing internal syntax (<a>Agda.Syntax.Internal</a>).
module Agda.Syntax.Abstract
type Color = Expr
type Arg a = Arg Color a
type Dom a = Dom Color a
type NamedArg a = NamedArg Color a
type ArgInfo = ArgInfo Color
type Args = [NamedArg Expr]

-- | Expressions after scope checking (operators parsed, names resolved).
data Expr

-- | Bound variable.
Var :: Name -> Expr

-- | Constant: axiom, function, data or record type.
Def :: QName -> Expr

-- | Projection.
Proj :: QName -> Expr

-- | Constructor.
Con :: AmbiguousQName -> Expr

-- | Pattern synonym.
PatternSyn :: QName -> Expr

-- | Literal.
Lit :: Literal -> Expr

-- | Meta variable for interaction. The <a>InteractionId</a> is usually
--   identical with the <a>metaNumber</a> of <a>MetaInfo</a>. However, if
--   you want to print an interaction meta as just <tt>?</tt> instead of
--   <tt>?n</tt>, you should set the <a>metaNumber</a> to <a>Nothing</a>
--   while keeping the <a>InteractionId</a>.
QuestionMark :: MetaInfo -> InteractionId -> Expr

-- | Meta variable for hidden argument (must be inferred locally).
Underscore :: MetaInfo -> Expr

-- | Ordinary (binary) application.
App :: ExprInfo -> Expr -> (NamedArg Expr) -> Expr

-- | With application.
WithApp :: ExprInfo -> Expr -> [Expr] -> Expr

-- | <tt>λ bs → e</tt>.
Lam :: ExprInfo -> LamBinding -> Expr -> Expr

-- | <tt>λ()</tt> or <tt>λ{}</tt>.
AbsurdLam :: ExprInfo -> Hiding -> Expr
ExtendedLam :: ExprInfo -> DefInfo -> QName -> [Clause] -> Expr

-- | Dependent function space <tt>Γ → A</tt>.
Pi :: ExprInfo -> Telescope -> Expr -> Expr

-- | Non-dependent function space.
Fun :: ExprInfo -> (Arg Expr) -> Expr -> Expr

-- | <tt>Set</tt>, <tt>Set1</tt>, <tt>Set2</tt>, ...
Set :: ExprInfo -> Integer -> Expr

-- | <tt>Prop</tt> (no longer supported, used as dummy type).
Prop :: ExprInfo -> Expr

-- | <tt>let bs in e</tt>.
Let :: ExprInfo -> [LetBinding] -> Expr -> Expr

-- | Only used when printing telescopes.
ETel :: Telescope -> Expr

-- | Record construction.
Rec :: ExprInfo -> Assigns -> Expr

-- | Record update.
RecUpdate :: ExprInfo -> Expr -> Assigns -> Expr

-- | Scope annotation.
ScopedExpr :: ScopeInfo -> Expr -> Expr

-- | Binds <tt>Name</tt> to current type in <tt>Expr</tt>.
QuoteGoal :: ExprInfo -> Name -> Expr -> Expr

-- | Binds <tt>Name</tt> to current context in <tt>Expr</tt>.
QuoteContext :: ExprInfo -> Name -> Expr -> Expr

-- | Quote an identifier <a>QName</a>.
Quote :: ExprInfo -> Expr

-- | Quote a term.
QuoteTerm :: ExprInfo -> Expr

-- | The splicing construct: unquote ...
Unquote :: ExprInfo -> Expr

-- | For printing <tt>DontCare</tt> from <tt>Syntax.Internal</tt>.
DontCare :: Expr -> Expr

-- | Record field assignment <tt>f = e</tt>.
type Assign = (Name, Expr)
type Assigns = [Assign]

-- | Is a type signature a <tt>postulate</tt> or a function signature?
data Axiom

-- | A function signature.
FunSig :: Axiom

-- | Not a function signature, i.e., a postulate (in user input) or another
--   (e.g. data/record) type signature (internally).
NoFunSig :: Axiom

-- | Renaming (generic).
type Ren a = Map a a
data Declaration

-- | type signature (can be irrelevant and colored, but not hidden)
Axiom :: Axiom -> DefInfo -> ArgInfo -> QName -> Expr -> Declaration

-- | record field
Field :: DefInfo -> QName -> (Arg Expr) -> Declaration

-- | primitive function
Primitive :: DefInfo -> QName -> Expr -> Declaration

-- | a bunch of mutually recursive definitions
Mutual :: MutualInfo -> [Declaration] -> Declaration
Section :: ModuleInfo -> ModuleName -> [TypedBindings] -> [Declaration] -> Declaration
Apply :: ModuleInfo -> ModuleName -> ModuleApplication -> (Ren QName) -> (Ren ModuleName) -> Declaration
Import :: ModuleInfo -> ModuleName -> Declaration
Pragma :: Range -> Pragma -> Declaration

-- | only retained for highlighting purposes
Open :: ModuleInfo -> ModuleName -> Declaration

-- | sequence of function clauses
FunDef :: DefInfo -> QName -> Delayed -> [Clause] -> Declaration

-- | lone data signature ^ the <a>LamBinding</a>s are <a>DomainFree</a> and
--   binds the parameters of the datatype.
DataSig :: DefInfo -> QName -> Telescope -> Expr -> Declaration

-- | the <a>LamBinding</a>s are <a>DomainFree</a> and binds the parameters
--   of the datatype.
DataDef :: DefInfo -> QName -> [LamBinding] -> [Constructor] -> Declaration

-- | lone record signature
RecSig :: DefInfo -> QName -> Telescope -> Expr -> Declaration

-- | The <a>Expr</a> gives the constructor type telescope, <tt>(x1 :
--   A1)..(xn : An) -&gt; Prop</tt>, and the optional name is the
--   constructor's name.
RecDef :: DefInfo -> QName -> (Maybe (Ranged Induction)) -> (Maybe QName) -> [LamBinding] -> Expr -> [Declaration] -> Declaration

-- | Only for highlighting purposes
PatternSynDef :: QName -> [Arg Name] -> Pattern -> Declaration
UnquoteDecl :: MutualInfo -> DefInfo -> QName -> Expr -> Declaration

-- | scope annotation
ScopedDecl :: ScopeInfo -> [Declaration] -> Declaration
class GetDefInfo a
getDefInfo :: GetDefInfo a => a -> Maybe DefInfo
data ModuleApplication

-- | <tt>tel. M args</tt>: applies <tt>M</tt> to <tt>args</tt> and
--   abstracts <tt>tel</tt>.
SectionApp :: Telescope -> ModuleName -> [NamedArg Expr] -> ModuleApplication

-- | <pre>
--   M {{...}}
--   </pre>
RecordModuleIFS :: ModuleName -> ModuleApplication
data Pragma
OptionsPragma :: [String] -> Pragma
BuiltinPragma :: String -> Expr -> Pragma
RewritePragma :: QName -> Pragma
CompiledPragma :: QName -> String -> Pragma
CompiledExportPragma :: QName -> String -> Pragma
CompiledTypePragma :: QName -> String -> Pragma
CompiledDataPragma :: QName -> String -> [String] -> Pragma
CompiledEpicPragma :: QName -> String -> Pragma
CompiledJSPragma :: QName -> String -> Pragma
StaticPragma :: QName -> Pragma
EtaPragma :: QName -> Pragma

-- | Bindings that are valid in a <tt>let</tt>.
data LetBinding

-- | <pre>
--   LetBind info rel name type defn
--   </pre>
LetBind :: LetInfo -> ArgInfo -> Name -> Expr -> Expr -> LetBinding

-- | Irrefutable pattern binding.
LetPatBind :: LetInfo -> Pattern -> Expr -> LetBinding

-- | <tt>LetApply mi newM (oldM args) renaming moduleRenaming</tt>.
LetApply :: ModuleInfo -> ModuleName -> ModuleApplication -> (Ren QName) -> (Ren ModuleName) -> LetBinding

-- | only for highlighting and abstractToConcrete
LetOpen :: ModuleInfo -> ModuleName -> LetBinding

-- | Only <a>Axiom</a>s.
type TypeSignature = Declaration
type Constructor = TypeSignature
type Field = TypeSignature

-- | A lambda binding is either domain free or typed.
data LamBinding

-- | . <tt>x</tt> or <tt>{x}</tt> or <tt>.x</tt> or <tt>.{x}</tt>
DomainFree :: ArgInfo -> Name -> LamBinding

-- | . <tt>(xs:e)</tt> or <tt>{xs:e}</tt> or <tt>(let Ds)</tt>
DomainFull :: TypedBindings -> LamBinding

-- | Typed bindings with hiding information.
data TypedBindings

-- | . <tt>(xs : e)</tt> or <tt>{xs : e}</tt>
TypedBindings :: Range -> (Arg TypedBinding) -> TypedBindings

-- | A typed binding. Appears in dependent function spaces, typed lambdas,
--   and telescopes. I might be tempting to simplify this to only bind a
--   single name at a time. This would mean that we would have to typecheck
--   the type several times (<tt>(x y : A)</tt> vs. <tt>(x : A)(y :
--   A)</tt>). In most cases this wouldn't really be a problem, but it's
--   good principle to not do extra work unless you have to.
--   
--   (Andreas, 2013-12-10: The more serious problem would that the
--   translation from <tt>(x y : ?)</tt> to <tt>(x : ?) (y : ?)</tt>
--   duplicates the hole <tt>?</tt>.
data TypedBinding

-- | As in telescope <tt>(x y z : A)</tt> or type <tt>(x y z : A) -&gt;
--   B</tt>.
TBind :: Range -> [Name] -> Expr -> TypedBinding
TLet :: Range -> [LetBinding] -> TypedBinding
type Telescope = [TypedBindings]

-- | We could throw away <tt>where</tt> clauses at this point and translate
--   them to <tt>let</tt>. It's not obvious how to remember that the
--   <tt>let</tt> was really a <tt>where</tt> clause though, so for the
--   time being we keep it here.
data Clause' lhs
Clause :: lhs -> RHS -> [Declaration] -> Clause' lhs
clauseLHS :: Clause' lhs -> lhs
clauseRHS :: Clause' lhs -> RHS
clauseWhereDecls :: Clause' lhs -> [Declaration]
type Clause = Clause' LHS
type SpineClause = Clause' SpineLHS
data RHS
RHS :: Expr -> RHS
AbsurdRHS :: RHS

-- | The <a>QName</a> is the name of the with function.
WithRHS :: QName -> [Expr] -> [Clause] -> RHS

-- | The <a>QName</a>s are the names of the generated with functions. One
--   for each <a>Expr</a>. The RHS shouldn't be another
--   <tt>RewriteRHS</tt>.
RewriteRHS :: [QName] -> [Expr] -> RHS -> [Declaration] -> RHS

-- | The lhs of a clause in spine view (inside-out). Projection patterns
--   are contained in <tt>spLhsPats</tt>, represented as <tt>DefP d
--   []</tt>.
data SpineLHS
SpineLHS :: LHSInfo -> QName -> [NamedArg Pattern] -> [Pattern] -> SpineLHS

-- | Range.
spLhsInfo :: SpineLHS -> LHSInfo

-- | Name of function we are defining.
spLhsDefName :: SpineLHS -> QName

-- | Function parameters (patterns).
spLhsPats :: SpineLHS -> [NamedArg Pattern]

-- | <tt>with</tt> patterns (after <tt>|</tt>).
spLhsWithPats :: SpineLHS -> [Pattern]

-- | The lhs of a clause in focused (projection-application) view
--   (outside-in). Projection patters are represented as <a>LHSProj</a>s.
data LHS
LHS :: LHSInfo -> LHSCore -> [Pattern] -> LHS

-- | Range.
lhsInfo :: LHS -> LHSInfo

-- | Copatterns.
lhsCore :: LHS -> LHSCore

-- | <tt>with</tt> patterns (after <tt>|</tt>).
lhsWithPats :: LHS -> [Pattern]

-- | The lhs minus <tt>with</tt>-patterns in projection-application view.
--   Parameterised over the type <tt>e</tt> of dot patterns.
data LHSCore' e

-- | The head applied to ordinary patterns.
LHSHead :: QName -> [NamedArg (Pattern' e)] -> LHSCore' e

-- | Head <tt>f</tt>.
lhsDefName :: LHSCore' e -> QName

-- | Applied to patterns <tt>ps</tt>.
lhsPats :: LHSCore' e -> [NamedArg (Pattern' e)]

-- | Projection
LHSProj :: QName -> [NamedArg (Pattern' e)] -> NamedArg (LHSCore' e) -> [NamedArg (Pattern' e)] -> LHSCore' e

-- | Record projection identifier.
lhsDestructor :: LHSCore' e -> QName

-- | Indices of the projection. Currently none <tt>[]</tt>, since we do not
--   have indexed records.
lhsPatsLeft :: LHSCore' e -> [NamedArg (Pattern' e)]

-- | Main branch.
lhsFocus :: LHSCore' e -> NamedArg (LHSCore' e)

-- | Further applied to patterns.
lhsPatsRight :: LHSCore' e -> [NamedArg (Pattern' e)]
type LHSCore = LHSCore' Expr

-- | Convert a focused lhs to spine view and back.
class LHSToSpine a b
lhsToSpine :: LHSToSpine a b => a -> b
spineToLhs :: LHSToSpine a b => b -> a

-- | Clause instance.

-- | List instance (for clauses).

-- | LHS instance.
lhsCoreToSpine :: LHSCore' e -> QNamed [NamedArg (Pattern' e)]
spineToLhsCore :: QNamed [NamedArg (Pattern' e)] -> LHSCore' e

-- | Add applicative patterns (non-projection patterns) to the right.
lhsCoreApp :: LHSCore' e -> [NamedArg (Pattern' e)] -> LHSCore' e

-- | Add projection and applicative patterns to the right.
lhsCoreAddSpine :: LHSCore' e -> [NamedArg (Pattern' e)] -> LHSCore' e

-- | Used for checking pattern linearity.
lhsCoreAllPatterns :: LHSCore' e -> [Pattern' e]

-- | Used in AbstractToConcrete.
lhsCoreToPattern :: LHSCore -> Pattern
mapLHSHead :: (QName -> [NamedArg Pattern] -> LHSCore) -> LHSCore -> LHSCore

-- | Parameterised over the type of dot patterns.
data Pattern' e
VarP :: Name -> Pattern' e
ConP :: ConPatInfo -> AmbiguousQName -> [NamedArg (Pattern' e)] -> Pattern' e

-- | Defined pattern: function definition <tt>f ps</tt> or destructor
--   pattern <tt>d p ps</tt>.
DefP :: PatInfo -> QName -> [NamedArg (Pattern' e)] -> Pattern' e

-- | Underscore pattern entered by user.
WildP :: PatInfo -> Pattern' e
AsP :: PatInfo -> Name -> (Pattern' e) -> Pattern' e
DotP :: PatInfo -> e -> Pattern' e
AbsurdP :: PatInfo -> Pattern' e
LitP :: Literal -> Pattern' e

-- | Generated at type checking for implicit arguments.
ImplicitP :: PatInfo -> Pattern' e
PatternSynP :: PatInfo -> QName -> [NamedArg (Pattern' e)] -> Pattern' e
type Pattern = Pattern' Expr
type Patterns = [NamedArg Pattern]

-- | Check whether we are a projection pattern.
class IsProjP a
isProjP :: IsProjP a => a -> Maybe QName

-- | Extracts all the names which are declared in a <a>Declaration</a>.
--   This does not include open public or let expressions, but it does
--   include local modules, where clauses and the names of extended
--   lambdas.
class AllNames a
allNames :: AllNames a => a -> Seq QName

-- | The name defined by the given axiom.
--   
--   Precondition: The declaration has to be a (scoped) <a>Axiom</a>.
axiomName :: Declaration -> QName

-- | Are we in an abstract block?
--   
--   In that case some definition is abstract.
class AnyAbstract a
anyAbstract :: AnyAbstract a => a -> Bool
app :: Expr -> [NamedArg Expr] -> Expr
patternToExpr :: Pattern -> Expr
type PatternSynDefn = ([Arg Name], Pattern)
type PatternSynDefns = Map QName PatternSynDefn
lambdaLiftExpr :: [Name] -> Expr -> Expr
substPattern :: [(Name, Pattern)] -> Pattern -> Pattern
class SubstExpr a
substExpr :: SubstExpr a => [(Name, Expr)] -> a -> a
insertImplicitPatSynArgs :: HasRange a => (Range -> a) -> Range -> [Arg Name] -> [NamedArg a] -> Maybe ([(Name, a)], [Arg Name])
instance SubstExpr TypedBinding
instance SubstExpr TypedBindings
instance SubstExpr LetBinding
instance SubstExpr Expr
instance SubstExpr Name
instance (SubstExpr a, SubstExpr b) => SubstExpr (a, b)
instance SubstExpr a => SubstExpr (Named name a)
instance SubstExpr a => SubstExpr (Arg a)
instance SubstExpr a => SubstExpr [a]
instance AnyAbstract Declaration
instance AnyAbstract a => AnyAbstract [a]
instance AllNames ModuleApplication
instance AllNames LetBinding
instance AllNames TypedBinding
instance AllNames TypedBindings
instance AllNames LamBinding
instance AllNames Expr
instance AllNames RHS
instance AllNames Clause
instance AllNames Declaration
instance AllNames QName
instance (AllNames a, AllNames b) => AllNames (a, b)
instance AllNames a => AllNames (Named name a)
instance AllNames a => AllNames (Arg a)
instance AllNames a => AllNames (Maybe a)
instance AllNames a => AllNames [a]
instance UniverseBi Declaration RString
instance UniverseBi Declaration ModuleInfo
instance UniverseBi Declaration ModuleName
instance UniverseBi Declaration Declaration
instance UniverseBi Declaration Pattern
instance UniverseBi Declaration TypedBinding
instance UniverseBi Declaration LamBinding
instance UniverseBi Declaration LetBinding
instance UniverseBi Declaration Expr
instance UniverseBi Declaration AmbiguousQName
instance UniverseBi Declaration QName
instance Typeable Axiom
instance Typeable Pattern'
instance Typeable Expr
instance Typeable LHS
instance Typeable LHSCore'
instance Typeable Clause'
instance Typeable RHS
instance Typeable Declaration
instance Typeable TypedBindings
instance Typeable TypedBinding
instance Typeable LetBinding
instance Typeable ModuleApplication
instance Typeable LamBinding
instance Typeable Pragma
instance Typeable SpineLHS
instance Eq Axiom
instance Ord Axiom
instance Show Axiom
instance Show e => Show (Pattern' e)
instance Functor Pattern'
instance Foldable Pattern'
instance Traversable Pattern'
instance Show Expr
instance Show LHS
instance Show e => Show (LHSCore' e)
instance Functor LHSCore'
instance Foldable LHSCore'
instance Traversable LHSCore'
instance Show lhs => Show (Clause' lhs)
instance Functor Clause'
instance Foldable Clause'
instance Traversable Clause'
instance Show RHS
instance Show Declaration
instance Show TypedBindings
instance Show TypedBinding
instance Show LetBinding
instance Show ModuleApplication
instance Show LamBinding
instance Show Pragma
instance Show SpineLHS
instance KillRange LetBinding
instance KillRange RHS
instance KillRange a => KillRange (Clause' a)
instance KillRange e => KillRange (LHSCore' e)
instance KillRange LHS
instance KillRange SpineLHS
instance KillRange e => KillRange (Pattern' e)
instance KillRange x => KillRange (ThingWithFixity x)
instance KillRange ModuleApplication
instance KillRange Declaration
instance KillRange Expr
instance KillRange TypedBinding
instance KillRange TypedBindings
instance KillRange LamBinding
instance SetRange (Pattern' a)
instance HasRange LetBinding
instance HasRange RHS
instance HasRange a => HasRange (Clause' a)
instance HasRange (LHSCore' e)
instance HasRange LHS
instance HasRange SpineLHS
instance HasRange (Pattern' e)
instance HasRange Declaration
instance HasRange Expr
instance HasRange TypedBinding
instance HasRange TypedBindings
instance HasRange LamBinding
instance IsProjP a => IsProjP (Named n a)
instance IsProjP a => IsProjP (Arg c a)
instance IsProjP (Pattern' e)
instance LHSToSpine LHS SpineLHS
instance LHSToSpine a b => LHSToSpine [a] [b]
instance LHSToSpine Clause SpineClause
instance GetDefInfo Declaration
instance Ord Color
instance Eq Color

module Agda.Syntax.Abstract.Views
data AppView
Application :: Expr -> [NamedArg Expr] -> AppView

-- | Gather applications to expose head and spine.
--   
--   Note: everything is an application, possibly of itself to 0 arguments
appView :: Expr -> AppView
unAppView :: AppView -> Expr

-- | Gather top-level <a>AsP</a>atterns to expose underlying pattern.
asView :: Pattern -> ([Name], Pattern)

-- | Check whether we are dealing with a universe.
isSet :: Expr -> Bool

-- | Remove top <a>ScopedExpr</a> wrappers.
unScope :: Expr -> Expr

-- | Remove <a>ScopedExpr</a> wrappers everywhere.
deepUnScope :: Expr -> Expr

-- | Apply an expression rewriting to every subexpression, inside-out. See
--   <a>Generic</a>
class ExprLike a where mapExpr f e = runIdentity $ traverseExpr (Identity . f) e
foldExpr :: (ExprLike a, Monoid m) => (Expr -> m) -> a -> m
traverseExpr :: (ExprLike a, Monad m, Applicative m) => (Expr -> m Expr) -> a -> m a
mapExpr :: ExprLike a => (Expr -> Expr) -> (a -> a)

-- | TODO: currently does not go into colors.

-- | TODO: currently does not go into patterns.

-- | TODO: currently does not go into clauses.
instance ExprLike (Clause' a)
instance ExprLike (Pattern' a)
instance ExprLike LetBinding
instance ExprLike TypedBinding
instance ExprLike TypedBindings
instance ExprLike LamBinding
instance ExprLike a => ExprLike (x, a)
instance ExprLike a => ExprLike [a]
instance ExprLike a => ExprLike (Named x a)
instance ExprLike a => ExprLike (Arg c a)
instance ExprLike Expr

module Agda.Syntax.Internal
type Color = Term
type ArgInfo = ArgInfo Color
type Arg a = Arg Color a
type Dom a = Dom Color a
type NamedArg a = NamedArg Color a

-- | Type of argument lists.
type Args = [Arg Term]
type NamedArgs = [NamedArg Term]

-- | Store the names of the record fields in the constructor. This allows
--   reduction of projection redexes outside of TCM. For instance, during
--   substitution and application.
data ConHead
ConHead :: QName -> Induction -> [QName] -> ConHead

-- | The name of the constructor.
conName :: ConHead -> QName

-- | Record constructors can be coinductive.
conInductive :: ConHead -> Induction

-- | The name of the record fields. Empty list for data constructors.
--   <a>Arg</a> is not needed here since it is stored in the constructor
--   args.
conFields :: ConHead -> [QName]
class LensConName a where setConName = mapConName . const mapConName f a = setConName (f (getConName a)) a
getConName :: LensConName a => a -> QName
setConName :: LensConName a => QName -> a -> a
mapConName :: LensConName a => (QName -> QName) -> a -> a

-- | Raw values.
--   
--   <tt>Def</tt> is used for both defined and undefined constants. Assume
--   there is a type declaration and a definition for every constant, even
--   if the definition is an empty list of clauses.
data Term

-- | <tt>x es</tt> neutral
Var :: {-# UNPACK #-} !Int -> Elims -> Term

-- | Terms are beta normal. Relevance is ignored
Lam :: ArgInfo -> (Abs Term) -> Term

-- | Only used by unquote --&gt; reify. Should never appear elsewhere.
ExtLam :: [Clause] -> Args -> Term
Lit :: Literal -> Term

-- | <tt>f es</tt>, possibly a delta/iota-redex
Def :: QName -> Elims -> Term

-- | <pre>
--   c vs
--   </pre>
Con :: ConHead -> Args -> Term

-- | dependent or non-dependent function space
Pi :: (Dom Type) -> (Abs Type) -> Term
Sort :: Sort -> Term
Level :: Level -> Term
MetaV :: {-# UNPACK #-} !MetaId -> Elims -> Term

-- | Irrelevant stuff in relevant position, but created in an irrelevant
--   context. Basically, an internal version of the irrelevance axiom
--   <tt>.irrAx : .A -&gt; A</tt>.
DontCare :: Term -> Term

-- | Explicit sharing
Shared :: !(Ptr Term) -> Term

-- | Eliminations, subsuming applications and projections.
data Elim' a
Apply :: (Arg a) -> Elim' a

-- | name of a record projection
Proj :: QName -> Elim' a
type Elim = Elim' Term
type Elims = [Elim]

-- | Names in binders and arguments.
type ArgName = String
argNameToString :: ArgName -> String
stringToArgName :: String -> ArgName
appendArgNames :: ArgName -> ArgName -> ArgName
nameToArgName :: Name -> ArgName

-- | Binder. <a>Abs</a>: The bound variable might appear in the body.
--   <a>NoAbs</a> is pseudo-binder, it does not introduce a fresh variable,
--   similar to the <tt>const</tt> of Haskell.
data Abs a

-- | The body has (at least) one free variable. Danger: <a>unAbs</a>
--   doesn't shift variables properly
Abs :: ArgName -> a -> Abs a
absName :: Abs a -> ArgName
unAbs :: Abs a -> a
NoAbs :: ArgName -> a -> Abs a
absName :: Abs a -> ArgName
unAbs :: Abs a -> a

-- | Types are terms with a sort annotation.
data Type' a
El :: Sort -> a -> Type' a
getSort :: Type' a -> Sort
unEl :: Type' a -> a
type Type = Type' Term

-- | Sequence of types. An argument of the first type is bound in later
--   types and so on.
data Tele a
EmptyTel :: Tele a

-- | <a>Abs</a> is never <a>NoAbs</a>.
ExtendTel :: a -> (Abs (Tele a)) -> Tele a
type Telescope = Tele (Dom Type)
mapAbsNamesM :: Applicative m => (ArgName -> m ArgName) -> Tele a -> m (Tele a)
mapAbsNames :: (ArgName -> ArgName) -> Tele a -> Tele a
replaceEmptyName :: ArgName -> Tele a -> Tele a

-- | Sorts.
data Sort
Type :: Level -> Sort
Prop :: Sort
Inf :: Sort

-- | if the free variable occurs in the second sort the whole thing should
--   reduce to Inf, otherwise it's the normal Lub
DLub :: Sort -> (Abs Sort) -> Sort

-- | A level is a maximum expression of 0..n <a>PlusLevel</a> expressions
--   each of which is a number or an atom plus a number.
--   
--   The empty maximum is the canonical representation for level 0.
newtype Level
Max :: [PlusLevel] -> Level
data PlusLevel
ClosedLevel :: Integer -> PlusLevel
Plus :: Integer -> LevelAtom -> PlusLevel
data LevelAtom
MetaLevel :: MetaId -> Elims -> LevelAtom
BlockedLevel :: MetaId -> Term -> LevelAtom
NeutralLevel :: Term -> LevelAtom

-- | Introduced by <tt>instantiate</tt>, removed by <tt>reduce</tt>.
UnreducedLevel :: Term -> LevelAtom

-- | A meta variable identifier is just a natural number.
newtype MetaId
MetaId :: Nat -> MetaId
metaId :: MetaId -> Nat

-- | Something where a meta variable may block reduction.
data Blocked t
Blocked :: MetaId -> t -> Blocked t
NotBlocked :: t -> Blocked t

-- | A clause is a list of patterns and the clause body should
--   <tt>Bind</tt>.
--   
--   The telescope contains the types of the pattern variables and the
--   permutation is how to get from the order the variables occur in the
--   patterns to the order they occur in the telescope. The body binds the
--   variables in the order they appear in the patterns.
--   
--   <pre>
--   clauseTel ~ permute clausePerm (patternVars clausPats)
--   </pre>
--   
--   Terms in dot patterns are valid in the clause telescope.
--   
--   For the purpose of the permutation and the body dot patterns count as
--   variables. TODO: Change this!
data Clause
Clause :: Range -> Telescope -> Permutation -> [NamedArg Pattern] -> ClauseBody -> Maybe (Arg Type) -> Clause
clauseRange :: Clause -> Range

-- | The types of the pattern variables.
clauseTel :: Clause -> Telescope
clausePerm :: Clause -> Permutation
namedClausePats :: Clause -> [NamedArg Pattern]
clauseBody :: Clause -> ClauseBody

-- | The type of the rhs under <tt>clauseTel</tt>. Used, e.g., by
--   <tt>TermCheck</tt>. Can be <a>Irrelevant</a> if we encountered an
--   irrelevant projection pattern on the lhs.
clauseType :: Clause -> Maybe (Arg Type)
clausePats :: Clause -> [Arg Pattern]
data ClauseBodyF a
Body :: a -> ClauseBodyF a
Bind :: (Abs (ClauseBodyF a)) -> ClauseBodyF a

-- | for absurd clauses.
NoBody :: ClauseBodyF a
type ClauseBody = ClauseBodyF Term

-- | Pattern variables.
type PatVarName = ArgName
patVarNameToString :: PatVarName -> String
nameToPatVarName :: Name -> PatVarName

-- | Patterns are variables, constructors, or wildcards. <tt>QName</tt> is
--   used in <tt>ConP</tt> rather than <tt>Name</tt> since a constructor
--   might come from a particular namespace. This also meshes well with the
--   fact that values (i.e. the arguments we are matching with) use
--   <tt>QName</tt>.
data Pattern' x

-- | <pre>
--   x
--   </pre>
VarP :: x -> Pattern' x

-- | <pre>
--   .t
--   </pre>
DotP :: Term -> Pattern' x

-- | <tt>c ps</tt> The subpatterns do not contain any projection
--   copatterns.
ConP :: ConHead -> ConPatternInfo -> [NamedArg (Pattern' x)] -> Pattern' x

-- | E.g. <tt>5</tt>, <tt>"hello"</tt>.
LitP :: Literal -> Pattern' x

-- | Projection copattern. Can only appear by itself.
ProjP :: QName -> Pattern' x
type Pattern = Pattern' PatVarName
namedVarP :: PatVarName -> Named (Ranged PatVarName) Pattern

-- | The <tt>ConPatternInfo</tt> states whether the constructor belongs to
--   a record type (<tt>Just</tt>) or data type (<tt>Nothing</tt>). In the
--   former case, the <tt>Bool</tt> says whether the record pattern
--   orginates from the expansion of an implicit pattern. The <tt>Type</tt>
--   is the type of the whole record pattern. The scope used for the type
--   is given by any outer scope plus the clause's telescope
--   (<a>clauseTel</a>).
type ConPatternInfo = Maybe (Bool, Arg Type)

-- | Extract pattern variables in left-to-right order. A <a>DotP</a> is
--   also treated as variable (see docu for <a>Clause</a>).
patternVars :: Arg Pattern -> [Arg (Either PatVarName Term)]

-- | Does the pattern perform a match that could fail?
properlyMatching :: Pattern -> Bool

-- | Substitutions.
data Substitution
IdS :: Substitution
EmptyS :: Substitution
Wk :: !Int -> Substitution -> Substitution
(:#) :: Term -> Substitution -> Substitution
Strengthen :: Empty -> Substitution -> Substitution
Lift :: !Int -> Substitution -> Substitution

-- | Absurd lambdas are internally represented as identity with variable
--   name "()".
absurdBody :: Abs Term
isAbsurdBody :: Abs Term -> Bool
absurdPatternName :: PatVarName
isAbsurdPatternName :: PatVarName -> Bool
ignoreSharing :: Term -> Term
ignoreSharingType :: Type -> Type

-- | Introduce sharing.
shared :: Term -> Term
sharedType :: Type -> Type

-- | Typically m would be TCM and f would be Blocked.
updateSharedFM :: (Monad m, Applicative m, Traversable f) => (Term -> m (f Term)) -> Term -> m (f Term)
updateSharedM :: Monad m => (Term -> m Term) -> Term -> m Term
updateShared :: (Term -> Term) -> Term -> Term
pointerChain :: Term -> [Ptr Term]
compressPointerChain :: Term -> Term

-- | An unapplied variable.
var :: Nat -> Term

-- | Add <a>DontCare</a> is it is not already a <tt>DontCare</tt>.
dontCare :: Term -> Term

-- | A dummy type.
typeDontCare :: Type

-- | Top sort (Setomega).
topSort :: Type
prop :: Type
sort :: Sort -> Type
varSort :: Int -> Sort

-- | Get the next higher sort.
sSuc :: Sort -> Sort
levelSuc :: Level -> Level
mkType :: Integer -> Sort
impossibleTerm :: String -> Int -> Term
class SgTel a
sgTel :: SgTel a => a -> Telescope
hackReifyToMeta :: Term
isHackReifyToMeta :: Term -> Bool
blockingMeta :: Blocked t -> Maybe MetaId
blocked :: MetaId -> a -> Blocked a
notBlocked :: a -> Blocked a
ignoreBlocking :: Blocked a -> a

-- | Removing a topmost <a>DontCare</a> constructor.
stripDontCare :: Term -> Term

-- | Doesn't do any reduction.
arity :: Type -> Nat

-- | Suggest a name for the first argument of a function of the given type.
argName :: Type -> String

-- | Pick the better name suggestion, i.e., the one that is not just
--   underscore.
class Suggest a b
suggest :: Suggest a b => a -> b -> String

-- | Convert top-level postfix projections into prefix projections.
unSpine :: Term -> Term

-- | A view distinguishing the neutrals <tt>Var</tt>, <tt>Def</tt>, and
--   <tt>MetaV</tt> which can be projected.
hasElims :: Term -> Maybe (Elims -> Term, Elims)

-- | Drop <a>Apply</a> constructor. (Unsafe!)
argFromElim :: Elim -> Arg Term

-- | Drop <a>Apply</a> constructor. (Safe)
isApplyElim :: Elim -> Maybe (Arg Term)

-- | Drop <a>Apply</a> constructors. (Safe)
allApplyElims :: Elims -> Maybe Args

-- | Split at first non-<a>Apply</a>
splitApplyElims :: Elims -> (Args, Elims)
class IsProjElim e
isProjElim :: IsProjElim e => e -> Maybe QName

-- | Discard <tt>Proj f</tt> entries.
dropProjElims :: IsProjElim e => [e] -> [e]

-- | Discards <tt>Proj f</tt> entries.
argsFromElims :: Elims -> Args
showTerm :: Term -> String
instance Pretty a => Pretty (Arg a)
instance Pretty Elim
instance Pretty Type
instance Pretty Sort
instance Pretty LevelAtom
instance Pretty PlusLevel
instance Pretty Level
instance Pretty Term
instance UniverseBi [Term] Term
instance UniverseBi Elims Term
instance UniverseBi Args Term
instance UniverseBi ([Type], [Clause]) Term
instance UniverseBi Elims Pattern
instance UniverseBi Args Pattern
instance UniverseBi ([Type], [Clause]) Pattern
instance Typeable ConHead
instance Typeable Abs
instance Typeable Tele
instance Typeable MetaId
instance Typeable Blocked
instance Typeable ClauseBodyF
instance Typeable Type'
instance Typeable Sort
instance Typeable Level
instance Typeable PlusLevel
instance Typeable LevelAtom
instance Typeable Elim'
instance Typeable Term
instance Typeable Clause
instance Typeable Pattern'
instance Functor Abs
instance Foldable Abs
instance Traversable Abs
instance Show a => Show (Tele a)
instance Functor Tele
instance Foldable Tele
instance Traversable Tele
instance Eq MetaId
instance Ord MetaId
instance Num MetaId
instance Real MetaId
instance Enum MetaId
instance Integral MetaId
instance Eq t => Eq (Blocked t)
instance Ord t => Ord (Blocked t)
instance Functor Blocked
instance Foldable Blocked
instance Traversable Blocked
instance Show a => Show (ClauseBodyF a)
instance Functor ClauseBodyF
instance Foldable ClauseBodyF
instance Traversable ClauseBodyF
instance Show a => Show (Type' a)
instance Functor Type'
instance Foldable Type'
instance Traversable Type'
instance Show Sort
instance Show Level
instance Show PlusLevel
instance Show LevelAtom
instance Show a => Show (Elim' a)
instance Functor Elim'
instance Foldable Elim'
instance Traversable Elim'
instance Show Term
instance Show Clause
instance Show x => Show (Pattern' x)
instance Functor Pattern'
instance Foldable Pattern'
instance Traversable Pattern'
instance Show Substitution
instance KillRange a => KillRange (Elim' a)
instance KillRange a => KillRange (Abs a)
instance KillRange a => KillRange (Blocked a)
instance KillRange a => KillRange (Tele a)
instance KillRange a => KillRange (ClauseBodyF a)
instance KillRange Clause
instance KillRange Permutation
instance KillRange Pattern
instance KillRange Sort
instance KillRange Type
instance KillRange LevelAtom
instance KillRange PlusLevel
instance KillRange Level
instance KillRange Term
instance KillRange ConHead
instance Sized a => Sized (Elim' a)
instance Sized a => Sized (Abs a)
instance Sized (Tele a)
instance Sized LevelAtom
instance Sized PlusLevel
instance Sized Level
instance Sized Type
instance Sized Term
instance Show t => Show (Blocked t)
instance Show MetaId
instance Show a => Show (Abs a)
instance IsProjElim Elim
instance Suggest (Abs a) (Abs b)
instance Suggest String String
instance SgTel (Dom (ArgName, Type))
instance SgTel (ArgName, Dom Type)
instance HasRange Clause
instance Applicative Blocked
instance Null (Tele a)
instance Decoration Type'
instance LensConName ConHead
instance SetRange ConHead
instance HasRange ConHead
instance Show ConHead
instance Ord ConHead
instance Eq ConHead


-- | Computing the free variables of a term.
--   
--   The distinction between rigid and strongly rigid occurrences comes
--   from: Jason C. Reed, PhD thesis, 2009, page 96 (see also his LFMTP
--   2009 paper)
--   
--   The main idea is that x = t(x) is unsolvable if x occurs strongly
--   rigidly in t. It might have a solution if the occurrence is not
--   strongly rigid, e.g.
--   
--   x = f -&gt; suc (f (x ( y -&gt; k))) has x = f -&gt; suc (f (suc k))
--   
--   <ul>
--   <li><i>Jason C. Reed, PhD thesis, page 106</i></li>
--   </ul>
--   
--   Under coinductive constructors, occurrences are never strongly rigid.
--   Also, function types and lambdas do not establish strong rigidity.
--   Only inductive constructors do so. (See issue 1271).
module Agda.TypeChecking.Free

-- | Free variables of a term, (disjointly) partitioned into strongly and
--   and weakly rigid variables, flexible variables and irrelevant
--   variables.
data FreeVars
FV :: VarSet -> VarSet -> VarSet -> VarSet -> VarSet -> VarSet -> FreeVars

-- | Variables under only and at least one inductive constructor(s).
stronglyRigidVars :: FreeVars -> VarSet

-- | Variables at top or only under inductive record constructors λs and
--   Πs. The purpose of recording these separately is that they can still
--   become strongly rigid if put under a constructor whereas weakly rigid
--   ones stay weakly rigid.
unguardedVars :: FreeVars -> VarSet

-- | Ordinary rigid variables, e.g., in arguments of variables.
weaklyRigidVars :: FreeVars -> VarSet

-- | Variables occuring in arguments of metas. These are only potentially
--   free, depending how the meta variable is instantiated.
flexibleVars :: FreeVars -> VarSet

-- | Variables in irrelevant arguments and under a <tt>DontCare</tt>, i.e.,
--   in irrelevant positions.
irrelevantVars :: FreeVars -> VarSet

-- | Variables in <a>UnusedArg</a>uments.
unusedVars :: FreeVars -> VarSet
class Free a

-- | Where should we skip sorts in free variable analysis?
data IgnoreSorts

-- | Do not skip.
IgnoreNot :: IgnoreSorts

-- | Skip when annotation to a type.
IgnoreInAnnotations :: IgnoreSorts

-- | Skip unconditionally.
IgnoreAll :: IgnoreSorts

-- | Doesn't go inside solved metas, but collects the variables from a
--   metavariable application <tt>X ts</tt> as <tt>flexibleVars</tt>.
freeVars :: Free a => a -> FreeVars
freeVarsIgnore :: Free a => IgnoreSorts -> a -> FreeVars

-- | <tt>allVars fv</tt> includes irrelevant variables.
allVars :: FreeVars -> VarSet

-- | All but the irrelevant variables.
relevantVars :: FreeVars -> VarSet

-- | Rigid variables: either strongly rigid, unguarded, or weakly rigid.
rigidVars :: FreeVars -> VarSet
freeIn :: Free a => Nat -> a -> Bool

-- | Is the variable bound by the abstraction actually used?
isBinderUsed :: Free a => Abs a -> Bool
freeInIgnoringSorts :: Free a => Nat -> a -> Bool
freeInIgnoringSortAnn :: Free a => Nat -> a -> Bool
relevantIn :: Free a => Nat -> a -> Bool
relevantInIgnoringSortAnn :: Free a => Nat -> a -> Bool
data Occurrence
NoOccurrence :: Occurrence
Irrelevantly :: Occurrence

-- | Under at least one and only inductive constructors.
StronglyRigid :: Occurrence

-- | In top position, or only under inductive record constructors.
Unguarded :: Occurrence

-- | In arguments to variables and definitions.
WeaklyRigid :: Occurrence

-- | In arguments of metas.
Flexible :: Occurrence
Unused :: Occurrence
occurrence :: Nat -> FreeVars -> Occurrence
instance Eq Occurrence
instance Show Occurrence
instance Eq IgnoreSorts
instance Show IgnoreSorts
instance Free Clause
instance Free ClauseBody
instance Free a => Free (Tele a)
instance Free a => Free (Abs a)
instance Free a => Free (Dom a)
instance Free a => Free (Arg a)
instance Free a => Free (Elim' a)
instance (Free a, Free b) => Free (a, b)
instance Free a => Free (Maybe a)
instance Free a => Free [a]
instance Free LevelAtom
instance Free PlusLevel
instance Free Level
instance Free Sort
instance Free Type
instance Free Term
instance Monoid FreeT
instance Monoid FreeVars


-- | Epic interface data structure, which is serialisable and stored for
--   each compiled file
module Agda.Compiler.Epic.Interface
type Var = String
data Tag
Tag :: Int -> Tag
PrimTag :: Var -> Tag
data Forced
NotForced :: Forced
Forced :: Forced

-- | Filter a list using a list of Bools specifying what to keep.
pairwiseFilter :: [Bool] -> [a] -> [a]
notForced :: ForcedArgs -> [a] -> [a]
forced :: ForcedArgs -> [a] -> [a]
data Relevance
Irr :: Relevance
Rel :: Relevance
type ForcedArgs = [Forced]
type RelevantArgs = [Relevance]
data InjectiveFun
InjectiveFun :: Nat -> Nat -> InjectiveFun
injArg :: InjectiveFun -> Nat
injArity :: InjectiveFun -> Nat
data EInterface
EInterface :: Map QName Tag -> Set Var -> Map QName Bool -> Map QName Int -> Maybe QName -> Map Var RelevantArgs -> Map QName ForcedArgs -> Map QName InjectiveFun -> EInterface
constrTags :: EInterface -> Map QName Tag
definitions :: EInterface -> Set Var
defDelayed :: EInterface -> Map QName Bool
conArity :: EInterface -> Map QName Int
mainName :: EInterface -> Maybe QName
relevantArgs :: EInterface -> Map Var RelevantArgs
forcedArgs :: EInterface -> Map QName ForcedArgs
injectiveFuns :: EInterface -> Map QName InjectiveFun
instance Typeable Tag
instance Typeable Forced
instance Typeable Relevance
instance Typeable InjectiveFun
instance Typeable EInterface
instance Show Tag
instance Eq Tag
instance Ord Tag
instance Show Forced
instance Eq Forced
instance Eq Relevance
instance Ord Relevance
instance Show Relevance
instance Show InjectiveFun
instance Eq InjectiveFun
instance Show EInterface
instance Monoid EInterface


-- | Intermediate abstract syntax tree used in the compiler. Pretty close
--   to Epic syntax.
module Agda.Compiler.Epic.AuxAST
type Comment = String
type Inline = Bool
data Fun
Fun :: Inline -> Var -> Maybe QName -> Comment -> [Var] -> Expr -> Fun
funInline :: Fun -> Inline
funName :: Fun -> Var
funQName :: Fun -> Maybe QName
funComment :: Fun -> Comment
funArgs :: Fun -> [Var]
funExpr :: Fun -> Expr
EpicFun :: Var -> Maybe QName -> Comment -> String -> Fun
funName :: Fun -> Var
funQName :: Fun -> Maybe QName
funComment :: Fun -> Comment
funEpicCode :: Fun -> String
data Lit
LInt :: Integer -> Lit
LChar :: Char -> Lit
LString :: String -> Lit
LFloat :: Double -> Lit
data Expr
Var :: Var -> Expr
Lit :: Lit -> Expr
Lam :: Var -> Expr -> Expr
Con :: Tag -> QName -> [Expr] -> Expr
App :: Var -> [Expr] -> Expr
Case :: Expr -> [Branch] -> Expr
If :: Expr -> Expr -> Expr -> Expr
Let :: Var -> Expr -> Expr -> Expr
Lazy :: Expr -> Expr
UNIT :: Expr
IMPOSSIBLE :: Expr
data Branch
Branch :: Tag -> QName -> [Var] -> Expr -> Branch
brTag :: Branch -> Tag
brName :: Branch -> QName
brVars :: Branch -> [Var]
brExpr :: Branch -> Expr
BrInt :: Int -> Expr -> Branch
brInt :: Branch -> Int
brExpr :: Branch -> Expr
Default :: Expr -> Branch
brExpr :: Branch -> Expr
getBrVars :: Branch -> [Var]

-- | Smart constructor for let expressions to avoid unneceessary lets
lett :: Var -> Expr -> Expr -> Expr

-- | Some things are pointless to make lazy
lazy :: Expr -> Expr

-- | If casing on the same expression in a sub-expression, we know what
--   branch to pick
casee :: Expr -> [Branch] -> Expr

-- | Smart constructor for applications to avoid empty applications
apps :: Var -> [Expr] -> Expr

-- | Substitution
subst :: Var -> Var -> Expr -> Expr
substs :: [(Var, Var)] -> Expr -> Expr
substBranch :: Var -> Var -> Branch -> Branch

-- | Get the free variables in an expression
fv :: Expr -> [Var]
instance Show Lit
instance Ord Lit
instance Eq Lit
instance Show Branch
instance Ord Branch
instance Eq Branch
instance Show Expr
instance Ord Expr
instance Eq Expr
instance Eq Fun
instance Ord Fun
instance Show Fun


-- | Case trees.
--   
--   After coverage checking, pattern matching is translated to case trees,
--   i.e., a tree of successive case splits on one variable at a time.
module Agda.TypeChecking.CompiledClause
data WithArity c
WithArity :: Int -> c -> WithArity c
arity :: WithArity c -> Int
content :: WithArity c -> c

-- | Branches in a case tree.
data Case c
Branches :: Map QName (WithArity c) -> Map Literal c -> Maybe c -> Case c

-- | Map from constructor (or projection) names to their arity and the case
--   subtree. (Projections have arity 0.)
conBranches :: Case c -> Map QName (WithArity c)

-- | Map from literal to case subtree.
litBranches :: Case c -> Map Literal c

-- | (Possibly additional) catch-all clause.
catchAllBranch :: Case c -> Maybe c

-- | Case tree with bodies.
data CompiledClauses

-- | <tt>Case n bs</tt> stands for a match on the <tt>n</tt>-th argument
--   (counting from zero) with <tt>bs</tt> as the case branches. If the
--   <tt>n</tt>-th argument is a projection, we have only
--   <a>conBranches</a>. with arity 0.
Case :: Int -> (Case CompiledClauses) -> CompiledClauses

-- | <tt>Done xs b</tt> stands for the body <tt>b</tt> where the
--   <tt>xs</tt> contains hiding and name suggestions for the free
--   variables. This is needed to build lambdas on the right hand side for
--   partial applications which can still reduce.
Done :: [Arg ArgName] -> Term -> CompiledClauses

-- | Absurd case.
Fail :: CompiledClauses
emptyBranches :: Case CompiledClauses
litCase :: Literal -> c -> Case c
conCase :: QName -> WithArity c -> Case c
catchAll :: c -> Case c
prettyMap :: (Show k, Pretty v) => Map k v -> [Doc]
instance Typeable WithArity
instance Typeable Case
instance Typeable CompiledClauses
instance Functor WithArity
instance Foldable WithArity
instance Traversable WithArity
instance Functor Case
instance Foldable Case
instance Traversable Case
instance Pretty CompiledClauses
instance Pretty a => Pretty (Case a)
instance Pretty a => Pretty (WithArity a)
instance Show CompiledClauses
instance Pretty a => Show (Case a)
instance Monoid m => Monoid (Case m)
instance Monoid c => Monoid (WithArity c)

module Agda.Syntax.Internal.Pattern

-- | Translate the clause patterns to terms with free variables bound by
--   the clause telescope.
--   
--   Precondition: no projection patterns.
clauseArgs :: Clause -> Args

-- | Translate the clause patterns to an elimination spine with free
--   variables bound by the clause telescope.
clauseElims :: Clause -> Elims

-- | Arity of a function, computed from clauses.
class FunArity a
funArity :: FunArity a => a -> Int

-- | Get the number of initial <a>Apply</a> patterns.

-- | Get the number of initial <a>Apply</a> patterns in a clause.

-- | Get the number of common initial <a>Apply</a> patterns in a list of
--   clauses.

-- | Label the pattern variables from left to right using one label for
--   each variable pattern and one for each dot pattern.
class LabelPatVars a b i | b -> i
labelPatVars :: LabelPatVars a b i => a -> State [i] b

-- | Augment pattern variables with their de Bruijn index.
numberPatVars :: LabelPatVars a b Int => Permutation -> a -> b
patternsToElims :: Permutation -> [NamedArg Pattern] -> [Elim]

-- | A <tt>OneholePattern</tt> is a linear pattern context <tt>P</tt> such
--   that for any non-projection pattern <tt>p</tt>, inserting <tt>p</tt>
--   into the single hole <tt>P[p]</tt>, yields again a non-projection
--   pattern.
data OneHolePatterns
OHPats :: [NamedArg Pattern] -> (NamedArg OneHolePattern) -> [NamedArg Pattern] -> OneHolePatterns
data OneHolePattern
Hole :: OneHolePattern

-- | The type in <a>ConPatternInfo</a> serves the same role as in
--   <a>ConP</a>.
--   
--   TODO: If a hole is plugged this type may have to be updated in some
--   way.
OHCon :: ConHead -> ConPatternInfo -> OneHolePatterns -> OneHolePattern
plugHole :: Pattern -> OneHolePatterns -> [NamedArg Pattern]

-- | <tt>allHoles ps</tt> returns for each pattern variable <tt>x</tt> in
--   <tt>ps</tt> a context <tt>P</tt> such <tt>P[x]</tt> is one of the
--   patterns of <tt>ps</tt>. The <tt>Ps</tt> are returned in the
--   left-to-right order of the pattern variables in <tt>ps</tt>.
allHoles :: [NamedArg Pattern] -> [OneHolePatterns]
allHolesWithContents :: [NamedArg Pattern] -> [(Pattern, OneHolePatterns)]
instance [overlap ok] Show OneHolePattern
instance [overlap ok] Show OneHolePatterns
instance [overlap ok] IsProjP Pattern
instance [overlap ok] LabelPatVars (Pattern' x) (Pattern' (i, x)) i
instance [overlap ok] LabelPatVars a b i => LabelPatVars [a] [b] i
instance [overlap ok] LabelPatVars a b i => LabelPatVars (Named x a) (Named x b) i
instance [overlap ok] LabelPatVars a b i => LabelPatVars (Arg c a) (Arg c b) i
instance [overlap ok] FunArity [Clause]
instance [overlap ok] FunArity Clause
instance [overlap ok] IsProjP p => FunArity [p]


-- | Extract used definitions from terms.
module Agda.Syntax.Internal.Defs

-- | <tt>getDefs' lookup emb a</tt> extracts all used definitions
--   (functions, data/record types) from <tt>a</tt>, embedded into a monoid
--   via <tt>emb</tt>. Instantiations of meta variables are obtained via
--   <tt>lookup</tt>.
--   
--   Typical monoid instances would be <tt>[QName]</tt> or <tt>Set
--   QName</tt>. Note that <tt>emb</tt> can also choose to discard a used
--   definition by mapping to the unit of the monoid.
getDefs' :: (GetDefs a, Monoid b) => (MetaId -> Maybe Term) -> (QName -> b) -> a -> b

-- | Inputs to and outputs of <tt>getDefs'</tt> are organized as a monad.
type GetDefsM b = ReaderT (GetDefsEnv b) (Writer b)
data GetDefsEnv b
GetDefsEnv :: (MetaId -> Maybe Term) -> (QName -> b) -> GetDefsEnv b
lookupMeta :: GetDefsEnv b -> MetaId -> Maybe Term
embDef :: GetDefsEnv b -> QName -> b

-- | What it takes to get the used definitions.
class Monad m => MonadGetDefs m
doDef :: MonadGetDefs m => QName -> m ()
doMeta :: MonadGetDefs m => MetaId -> m ()

-- | Getting the used definitions.
class GetDefs a
getDefs :: (GetDefs a, MonadGetDefs m) => a -> m ()
instance (GetDefs a, GetDefs b) => GetDefs (a, b)
instance GetDefs a => GetDefs (Abs a)
instance (GetDefs c, GetDefs a) => GetDefs (Dom c a)
instance (GetDefs c, GetDefs a) => GetDefs (Arg c a)
instance GetDefs c => GetDefs (ArgInfo c)
instance GetDefs a => GetDefs (Elim' a)
instance GetDefs a => GetDefs [a]
instance GetDefs a => GetDefs (Maybe a)
instance GetDefs LevelAtom
instance GetDefs PlusLevel
instance GetDefs Level
instance GetDefs Sort
instance GetDefs Type
instance GetDefs MetaId
instance GetDefs Term
instance GetDefs ClauseBody
instance GetDefs Clause
instance Monoid b => MonadGetDefs (GetDefsM b)

module Agda.Syntax.Internal.Generic
class TermLike a
traverseTerm :: TermLike a => (Term -> Term) -> a -> a
traverseTermM :: (TermLike a, Monad m, Applicative m) => (Term -> m Term) -> a -> m a
foldTerm :: (TermLike a, Monoid m) => (Term -> m) -> a -> m

-- | Put it in a monad to make it possible to do strictly.
copyTerm :: (TermLike a, Applicative m, Monad m) => a -> m a
instance TermLike Type
instance TermLike LevelAtom
instance TermLike PlusLevel
instance TermLike Level
instance TermLike Term
instance TermLike a => TermLike (Ptr a)
instance TermLike a => TermLike (Abs a)
instance (TermLike a, TermLike b, TermLike c, TermLike d) => TermLike (a, b, c, d)
instance (TermLike a, TermLike b, TermLike c) => TermLike (a, b, c)
instance (TermLike a, TermLike b) => TermLike (a, b)
instance TermLike a => TermLike (Maybe a)
instance TermLike a => TermLike [a]
instance TermLike a => TermLike (Dom a)
instance TermLike a => TermLike (Arg a)
instance TermLike a => TermLike (Elim' a)
instance TermLike QName
instance TermLike Char
instance TermLike Integer
instance TermLike Int
instance TermLike Bool

module Agda.TypeChecking.Coverage.Match

-- | Given
--   
--   <ol>
--   <li>the function clauses <tt>cs</tt></li>
--   <li>the patterns <tt>ps</tt> and permutation <tt>perm</tt> of a split
--   clause</li>
--   </ol>
--   
--   we want to compute a variable index of the split clause to split on
--   next.
--   
--   First, we find the set <tt>cs'</tt> of all the clauses that are
--   instances (via substitutions <tt>rhos</tt>) of the split clause.
--   
--   In these substitutions, we look for a column that has only constructor
--   patterns. We try to split on this column first.
--   
--   Match the given patterns against a list of clauses
match :: [Clause] -> [Arg Pattern] -> Permutation -> Match Nat

-- | We use a special representation of the patterns we're trying to match
--   against a clause. In particular we want to keep track of which
--   variables are blocking a match.
data MPat

-- | De Bruijn index (usually, rightmost variable in patterns is 0).
VarMP :: Nat -> MPat
ConMP :: ConHead -> [Arg MPat] -> MPat
LitMP :: Literal -> MPat

-- | For dot patterns that cannot be turned into patterns.
WildMP :: MPat

-- | Projection copattern.
ProjMP :: QName -> MPat
buildMPatterns :: Permutation -> [Arg Pattern] -> [Arg MPat]

-- | If matching is inconclusive (<tt>Block</tt>) we want to know which
--   variables are blocking the match.
data Match a

-- | Matches unconditionally.
Yes :: a -> Match a

-- | Definitely does not match.
No :: Match a

-- | Could match if non-empty list of blocking variables is instantiated
--   properly.
Block :: BlockingVars -> Match a

-- | Could match if split on possible projections is performed.
BlockP :: Match a

-- | Variable blocking a match.
data BlockingVar
BlockingVar :: Nat -> Maybe [ConHead] -> BlockingVar

-- | De Bruijn index of variable blocking the match.
blockingVarNo :: BlockingVar -> Nat

-- | <tt>Nothing</tt> means there is an overlapping match for this
--   variable. This happens if one clause has a constructor pattern at this
--   position, and another a variable. It is also used for "just variable".
--   
--   <tt>Just cons</tt> means that it is an non-overlapping match and
--   <tt>cons</tt> are the encountered constructors.
blockingVarCons :: BlockingVar -> Maybe [ConHead]
type BlockingVars = [BlockingVar]
mapBlockingVarCons :: (Maybe [ConHead] -> Maybe [ConHead]) -> BlockingVar -> BlockingVar
clearBlockingVarCons :: BlockingVar -> BlockingVar
overlapping :: BlockingVars -> BlockingVars

-- | Left dominant merge of blocking vars.
zipBlockingVars :: BlockingVars -> BlockingVars -> BlockingVars

-- | <tt>choice m m'</tt> combines the match results <tt>m</tt> of a
--   function clause with the (already combined) match results $m'$ of the
--   later clauses. It is for skipping clauses that definitely do not match
--   (<a>No</a>). It is left-strict, to be used with <tt>foldr</tt>. If one
--   clause unconditionally matches (<a>Yes</a>) we do not look further.
choice :: Match a -> Match a -> Match a
type MatchLit = Literal -> MPat -> Match ()
noMatchLit :: MatchLit
yesMatchLit :: MatchLit

-- | Check if a clause could match given generously chosen literals
matchLits :: Clause -> [Arg Pattern] -> Permutation -> Bool

-- | <tt>matchClause mlit qs i c</tt> checks whether clause <tt>c</tt>
--   number <tt>i</tt> covers a split clause with patterns <tt>qs</tt>.
matchClause :: MatchLit -> [Arg MPat] -> Nat -> Clause -> Match Nat

-- | <tt>matchPats mlit ps qs</tt> checks whether a function clause with
--   patterns <tt>ps</tt> covers a split clause with patterns <tt>qs</tt>.
--   
--   Issue 842: if in case of functions with varying arity, the split
--   clause has proper patterns left, we refuse to match, because it would
--   be troublesome to construct the split tree later. We would have to
--   move bindings from the rhs to the lhs. For example, this is rejected:
--   <tt> F : Bool -&gt; Set1 F true = Set F = x -&gt; Set </tt>
matchPats :: MatchLit -> [Arg Pattern] -> [Arg MPat] -> Match ()

-- | Combine results of checking whether function clause patterns covers
--   split clause patterns.
--   
--   <a>No</a> is dominant: if one function clause pattern is disjoint to
--   the corresponding split clause pattern, then the whole clauses are
--   disjoint.
--   
--   <a>Yes</a> is neutral: for a match, all patterns have to match.
--   
--   <a>Block</a> accumulates variables of the split clause that have to be
--   instantiated to make the split clause an instance of the function
--   clause.
--   
--   <a>BlockP</a> yields to <a>Block</a>, since blocking vars can also
--   block the result type.

-- | <tt>matchPat mlit p q</tt> checks whether a function clause pattern
--   <tt>p</tt> covers a split clause pattern <tt>q</tt>. There are three
--   results: <tt>Yes ()</tt> means it covers, because <tt>p</tt> is a
--   variable pattern or <tt>q</tt> is a wildcard. <tt>No</tt> means it
--   does not cover. <tt>Block [x]</tt> means <tt>p</tt> is a proper
--   instance of <tt>q</tt> and could become a cover if <tt>q</tt> was
--   split on variable <tt>x</tt>.
matchPat :: MatchLit -> Pattern -> MPat -> Match ()
instance Show BlockingVar
instance Functor Match
instance Monoid a => Monoid (Match a)


-- | Generic traversal and reduce for concrete syntax, in the style of
--   <a>Generic</a>.
--   
--   However, here we use the terminology of <a>Traversable</a>.
module Agda.Syntax.Concrete.Generic

-- | Generic traversals for concrete expressions.
--   
--   Note: does not go into patterns!
class ExprLike a where traverseExpr = (throwImpossible (Impossible "dist/build/tmp-29154/src/full/Agda/Syntax/Concrete/Generic.hs" 35)) foldExpr = (throwImpossible (Impossible "dist/build/tmp-29154/src/full/Agda/Syntax/Concrete/Generic.hs" 36))
mapExpr :: ExprLike a => (Expr -> Expr) -> a -> a
traverseExpr :: (ExprLike a, Monad m, Applicative m) => (Expr -> m Expr) -> a -> m a
foldExpr :: (ExprLike a, Monoid m) => (Expr -> m) -> a -> m
instance ExprLike Declaration
instance ExprLike ModuleApplication
instance ExprLike LHS
instance ExprLike TypedBindings
instance ExprLike LamBinding
instance ExprLike a => ExprLike (OpApp a)
instance ExprLike Expr
instance (ExprLike a, ExprLike b, ExprLike c) => ExprLike (a, b, c)
instance (ExprLike a, ExprLike b) => ExprLike (a, b)
instance ExprLike a => ExprLike (WhereClause' a)
instance ExprLike a => ExprLike (RHS' a)
instance ExprLike a => ExprLike (TypedBinding' a)
instance ExprLike a => ExprLike (Maybe a)
instance ExprLike a => ExprLike [a]
instance ExprLike a => ExprLike (Arg a)
instance ExprLike a => ExprLike (Named name a)
instance ExprLike QName
instance ExprLike Name


-- | Types used for precise syntax highlighting.
module Agda.Interaction.Highlighting.Precise

-- | Syntactic aspects of the code. (These cannot overlap.) They can be
--   obtained from the lexed tokens already, except for the
--   <a>NameKind</a>.
data Aspect
Comment :: Aspect
Keyword :: Aspect
String :: Aspect
Number :: Aspect

-- | Symbols like forall, =, -&gt;, etc.
Symbol :: Aspect

-- | Things like Set and Prop.
PrimitiveType :: Aspect

-- | Is the name an operator part?
Name :: (Maybe NameKind) -> Bool -> Aspect

-- | <tt>NameKind</tt>s are figured our during scope checking.
data NameKind

-- | Bound variable.
Bound :: NameKind

-- | Inductive or coinductive constructor.
Constructor :: Induction -> NameKind
Datatype :: NameKind

-- | Record field.
Field :: NameKind
Function :: NameKind

-- | Module name.
Module :: NameKind
Postulate :: NameKind

-- | Primitive.
Primitive :: NameKind

-- | Record type.
Record :: NameKind

-- | Named argument, like x in {x = v}
Argument :: NameKind

-- | Other aspects, generated by type checking. (These can overlap with
--   each other and with <a>Aspect</a>s.)
data OtherAspect
Error :: OtherAspect
DottedPattern :: OtherAspect
UnsolvedMeta :: OtherAspect

-- | Unsolved constraint not connected to meta-variable. This could for
--   instance be an emptyness constraint.
UnsolvedConstraint :: OtherAspect
TerminationProblem :: OtherAspect

-- | When this constructor is used it is probably a good idea to include a
--   <a>note</a> explaining why the pattern is incomplete.
IncompletePattern :: OtherAspect

-- | Code which is being type-checked.
TypeChecks :: OtherAspect

-- | Meta information which can be associated with a character/character
--   range.
data Aspects
Aspects :: Maybe Aspect -> [OtherAspect] -> Maybe String -> Maybe (TopLevelModuleName, Int) -> Aspects
aspect :: Aspects -> Maybe Aspect
otherAspects :: Aspects -> [OtherAspect]

-- | This note, if present, can be displayed as a tool-tip or something
--   like that. It should contain useful information about the range (like
--   the module containing a certain identifier, or the fixity of an
--   operator).
note :: Aspects -> Maybe String

-- | The definition site of the annotated thing, if applicable and known.
--   File positions are counted from 1.
definitionSite :: Aspects -> Maybe (TopLevelModuleName, Int)

-- | A <a>File</a> is a mapping from file positions to meta information.
--   
--   The first position in the file has number 1.
data File

-- | Syntax highlighting information.
type HighlightingInfo = CompressedFile

-- | <tt><a>singleton</a> rs m</tt> is a file whose positions are those in
--   <tt>rs</tt>, and in which every position is associated with
--   <tt>m</tt>.
singleton :: Ranges -> Aspects -> File

-- | Like <a>singleton</a>, but with several <a>Ranges</a> instead of only
--   one.
several :: [Ranges] -> Aspects -> File

-- | Returns the smallest position, if any, in the <a>File</a>.
smallestPos :: File -> Maybe Int

-- | Convert the <a>File</a> to a map from file positions (counting from 1)
--   to meta information.
toMap :: File -> IntMap Aspects

-- | A compressed <a>File</a>, in which consecutive positions with the same
--   <a>Aspects</a> are stored together.
newtype CompressedFile
CompressedFile :: [(Range, Aspects)] -> CompressedFile
ranges :: CompressedFile -> [(Range, Aspects)]

-- | Invariant for compressed files.
--   
--   Note that these files are not required to be <i>maximally</i>
--   compressed, because ranges are allowed to be empty, and the
--   <a>Aspects</a>s in adjacent ranges are allowed to be equal.
compressedFileInvariant :: CompressedFile -> Bool

-- | Compresses a file by merging consecutive positions with equal meta
--   information into longer ranges.
compress :: File -> CompressedFile

-- | Decompresses a compressed file.
decompress :: CompressedFile -> File

-- | Clear any highlighting info for the given ranges. Used to make sure
--   unsolved meta highlighting overrides error highlighting.
noHighlightingInRange :: Ranges -> CompressedFile -> CompressedFile

-- | <tt><a>singletonC</a> rs m</tt> is a file whose positions are those in
--   <tt>rs</tt>, and in which every position is associated with
--   <tt>m</tt>.
singletonC :: Ranges -> Aspects -> CompressedFile

-- | Like <tt>singletonR</tt>, but with a list of <a>Ranges</a> instead of
--   a single one.
severalC :: [Ranges] -> Aspects -> CompressedFile

-- | <tt>splitAtC p f</tt> splits the compressed file <tt>f</tt> into
--   <tt>(f1, f2)</tt>, where all the positions in <tt>f1</tt> are <tt>&lt;
--   p</tt>, and all the positions in <tt>f2</tt> are <tt>&gt;= p</tt>.
splitAtC :: Int -> CompressedFile -> (CompressedFile, CompressedFile)

-- | Returns the smallest position, if any, in the <a>CompressedFile</a>.
smallestPosC :: CompressedFile -> Maybe Int

-- | All the properties.
tests :: IO Bool
instance Typeable NameKind
instance Typeable Aspect
instance Typeable OtherAspect
instance Typeable Aspects
instance Typeable File
instance Typeable CompressedFile
instance Eq NameKind
instance Show NameKind
instance Eq Aspect
instance Show Aspect
instance Eq OtherAspect
instance Show OtherAspect
instance Enum OtherAspect
instance Bounded OtherAspect
instance Eq Aspects
instance Show Aspects
instance Eq File
instance Show File
instance Eq CompressedFile
instance Show CompressedFile
instance Arbitrary CompressedFile
instance CoArbitrary File
instance Arbitrary File
instance CoArbitrary Aspects
instance Arbitrary Aspects
instance CoArbitrary OtherAspect
instance Arbitrary OtherAspect
instance CoArbitrary NameKind
instance Arbitrary NameKind
instance CoArbitrary Aspect
instance Arbitrary Aspect
instance Monoid CompressedFile
instance Monoid File
instance Monoid Aspects


-- | Preprocess <a>Declaration</a>s, producing <a>NiceDeclaration</a>s.
--   
--   <ul>
--   <li>Attach fixity and syntax declarations to the definition they refer
--   to.</li>
--   <li>Distribute the following attributes to the individual definitions:
--   <tt>abstract</tt>, <tt>instance</tt>, <tt>postulate</tt>,
--   <tt>primitive</tt>, <tt>private</tt>, termination pragmas.</li>
--   <li>Gather the function clauses belonging to one function
--   definition.</li>
--   <li>Expand ellipsis <tt>...</tt> in function clauses following
--   <tt>with</tt>.</li>
--   <li>Infer mutual blocks. A block starts when a lone signature is
--   encountered, and ends when all lone signatures have seen their
--   definition.</li>
--   <li>Report basic well-formedness error, when one of the above
--   transformation fails.</li>
--   </ul>
module Agda.Syntax.Concrete.Definitions

-- | The nice declarations. No fixity declarations and function definitions
--   are contained in a single constructor instead of spread out between
--   type signatures and clauses. The <tt>private</tt>, <tt>postulate</tt>,
--   <tt>abstract</tt> and <tt>instance</tt> modifiers have been
--   distributed to the individual declarations.
data NiceDeclaration

-- | Axioms and functions can be declared irrelevant. (Hiding should be
--   NotHidden)
Axiom :: Range -> Fixity' -> Access -> IsInstance -> ArgInfo -> Name -> Expr -> NiceDeclaration
NiceField :: Range -> Fixity' -> Access -> IsAbstract -> Name -> (Arg Expr) -> NiceDeclaration
PrimitiveFunction :: Range -> Fixity' -> Access -> IsAbstract -> Name -> Expr -> NiceDeclaration
NiceMutual :: Range -> TerminationCheck -> [NiceDeclaration] -> NiceDeclaration
NiceModule :: Range -> Access -> IsAbstract -> QName -> Telescope -> [Declaration] -> NiceDeclaration
NiceModuleMacro :: Range -> Access -> Name -> ModuleApplication -> OpenShortHand -> ImportDirective -> NiceDeclaration
NiceOpen :: Range -> QName -> ImportDirective -> NiceDeclaration
NiceImport :: Range -> QName -> (Maybe AsName) -> OpenShortHand -> ImportDirective -> NiceDeclaration
NicePragma :: Range -> Pragma -> NiceDeclaration
NiceRecSig :: Range -> Fixity' -> Access -> Name -> [LamBinding] -> Expr -> NiceDeclaration
NiceDataSig :: Range -> Fixity' -> Access -> Name -> [LamBinding] -> Expr -> NiceDeclaration

-- | a uncategorized function clause, could be a function clause without
--   type signature or a pattern lhs (e.g. for irrefutable let)x
NiceFunClause :: Range -> Access -> IsAbstract -> TerminationCheck -> Declaration -> NiceDeclaration
FunSig :: Range -> Fixity' -> Access -> IsInstance -> ArgInfo -> TerminationCheck -> Name -> Expr -> NiceDeclaration

-- | block of function clauses (we have seen the type signature before)
FunDef :: Range -> [Declaration] -> Fixity' -> IsAbstract -> TerminationCheck -> Name -> [Clause] -> NiceDeclaration
DataDef :: Range -> Fixity' -> IsAbstract -> Name -> [LamBinding] -> [NiceConstructor] -> NiceDeclaration
RecDef :: Range -> Fixity' -> IsAbstract -> Name -> (Maybe (Ranged Induction)) -> (Maybe (ThingWithFixity Name)) -> [LamBinding] -> [NiceDeclaration] -> NiceDeclaration
NicePatternSyn :: Range -> Fixity' -> Name -> [Arg Name] -> Pattern -> NiceDeclaration
NiceUnquoteDecl :: Range -> Fixity' -> Access -> IsAbstract -> TerminationCheck -> Name -> Expr -> NiceDeclaration

-- | Only <a>Axiom</a>s.
type NiceConstructor = NiceTypeSignature

-- | Only <a>Axiom</a>s.
type NiceTypeSignature = NiceDeclaration

-- | One clause in a function definition. There is no guarantee that the
--   <a>LHS</a> actually declares the <a>Name</a>. We will have to check
--   that later.
data Clause
Clause :: Name -> LHS -> RHS -> WhereClause -> [Clause] -> Clause

-- | The exception type.
data DeclarationException
MultipleFixityDecls :: [(Name, [Fixity'])] -> DeclarationException
MissingDefinition :: Name -> DeclarationException
MissingWithClauses :: Name -> DeclarationException
MissingTypeSignature :: LHS -> DeclarationException
MissingDataSignature :: Name -> DeclarationException
WrongDefinition :: Name -> DataRecOrFun -> DataRecOrFun -> DeclarationException
WrongParameters :: Name -> DeclarationException
NotAllowedInMutual :: NiceDeclaration -> DeclarationException
UnknownNamesInFixityDecl :: [Name] -> DeclarationException
Codata :: Range -> DeclarationException
DeclarationPanic :: String -> DeclarationException
UselessPrivate :: Range -> DeclarationException
UselessAbstract :: Range -> DeclarationException
UselessInstance :: Range -> DeclarationException
WrongContentPostulateBlock :: Range -> DeclarationException

-- | in a mutual block, a clause could belong to any of the <tt>[Name]</tt>
--   type signatures
AmbiguousFunClauses :: LHS -> [Name] -> DeclarationException
InvalidTerminationCheckPragma :: Range -> DeclarationException

-- | In a mutual block, all or none need a MEASURE pragma. Range is of
--   mutual block.
InvalidMeasureMutual :: Range -> DeclarationException

-- | Pragma <tt>{--}</tt> has been replaced by {--} and {--}.
PragmaNoTerminationCheck :: Range -> DeclarationException

-- | Nicifier monad.
type Nice = StateT NiceEnv (Either DeclarationException)
runNice :: Nice a -> Either DeclarationException a

-- | Main.
niceDeclarations :: [Declaration] -> Nice [NiceDeclaration]

-- | (Approximately) convert a <a>NiceDeclaration</a> back to a
--   <a>Declaration</a>.
notSoNiceDeclaration :: NiceDeclaration -> Declaration

-- | Termination measure is, for now, a variable name.
type Measure = Name
instance Typeable Clause
instance Typeable NiceDeclaration
instance Typeable DeclarationException
instance Show Clause
instance Show NiceDeclaration
instance Eq InMutual
instance Show InMutual
instance Eq DataRecOrFun
instance Eq DeclKind
instance Show DeclKind
instance Monoid (Nice Fixities)
instance Show DataRecOrFun
instance Show DeclarationException
instance Error DeclarationException
instance HasRange NiceDeclaration
instance HasRange DeclarationException


-- | The parser is generated by Happy
--   (<a>http://www.haskell.org/happy</a>). - - Ideally, ranges should be
--   as precise as possible, to get messages that - emphasize precisely the
--   faulting term(s) upon error. - - However, interactive highlighting is
--   only applied at the end of each - mutual block, keywords are only
--   highlighted once (see - <a>Decl</a>). So if the ranges of two
--   declarations - interleave, one must ensure that keyword ranges are not
--   included in - the intersection. (Otherwise they are uncolored by the
--   interactive - highlighting.) -
module Agda.Syntax.Parser.Parser

-- | Parse a module.
moduleParser :: Parser Module

-- | Parse an expression. Could be used in interactions.
exprParser :: Parser Expr

-- | Parse the token stream. Used by the TeX compiler.
tokensParser :: Parser [Token]

-- | Test suite.
tests :: IO Bool

module Agda.Syntax.Parser

-- | Wrapped Parser type.
data Parser a
parse :: Parser a -> String -> IO a
parseLiterate :: Parser a -> String -> IO a
parsePosString :: Parser a -> Position -> String -> IO a
parseFile' :: Parser a -> AbsolutePath -> IO a

-- | Parses a module.
moduleParser :: Parser Module

-- | Parses an expression.
exprParser :: Parser Expr

-- | Gives the parsed token stream (including comments).
tokensParser :: Parser [Token]

-- | What you get if parsing fails.
data ParseError
ParseError :: Position -> String -> String -> String -> ParseError

-- | where the error occured
errPos :: ParseError -> Position

-- | the remaining input
errInput :: ParseError -> String

-- | the previous token
errPrevToken :: ParseError -> String

-- | hopefully an explanation of what happened
errMsg :: ParseError -> String


-- | This module defines the exception handler.
module Agda.Interaction.Exceptions
handleParseException :: (ParseError -> IO a) -> ParseError -> IO a

-- | Note that <a>failOnException</a> only catches <a>ParseError</a>s.
failOnException :: (Range -> String -> IO a) -> IO a -> IO a

module Agda.TypeChecking.Monad.Base
data TCState
TCSt :: !PreScopeState -> !PostScopeState -> !PersistentTCState -> TCState

-- | The state which is frozen after scope checking.
stPreScopeState :: TCState -> !PreScopeState

-- | The state which is modified after scope checking.
stPostScopeState :: TCState -> !PostScopeState

-- | State which is forever, like a diamond.
stPersistentState :: TCState -> !PersistentTCState
data PreScopeState
PreScopeState :: CompressedFile -> InteractionPoints -> Signature -> Set ModuleName -> ModuleToSource -> VisitedModules -> ScopeInfo -> PatternSynDefns -> PatternSynDefns -> PragmaOptions -> BuiltinThings PrimFun -> Set String -> InteractionId -> NameId -> PreScopeState

-- | Highlighting info for tokens (but not those tokens for which
--   highlighting exists in <a>stSyntaxInfo</a>).
stPreTokens :: PreScopeState -> CompressedFile
stPreInteractionPoints :: PreScopeState -> InteractionPoints

-- | Imported declared identifiers. Those most not be serialized!
stPreImports :: PreScopeState -> Signature
stPreImportedModules :: PreScopeState -> Set ModuleName
stPreModuleToSource :: PreScopeState -> ModuleToSource
stPreVisitedModules :: PreScopeState -> VisitedModules
stPreScope :: PreScopeState -> ScopeInfo

-- | Pattern synonyms of the current file. Serialized.
stPrePatternSyns :: PreScopeState -> PatternSynDefns

-- | Imported pattern synonyms. Must not be serialized!
stPrePatternSynImports :: PreScopeState -> PatternSynDefns

-- | Options applying to the current file. <tt>OPTIONS</tt> pragmas only
--   affect this field.
stPrePragmaOptions :: PreScopeState -> PragmaOptions
stPreImportedBuiltins :: PreScopeState -> BuiltinThings PrimFun

-- | Imports that should be generated by the compiler (this includes
--   imports from imported modules).
stPreHaskellImports :: PreScopeState -> Set String
stPreFreshInteractionId :: PreScopeState -> InteractionId
stPreFreshNameId :: PreScopeState -> NameId
type DisambiguatedNames = IntMap QName
data PostScopeState
PostScopeState :: CompressedFile -> !DisambiguatedNames -> MetaStore -> InteractionPoints -> Constraints -> Constraints -> Bool -> Set QName -> Signature -> Maybe ModuleName -> TempInstanceTable -> Statistics -> Map MutualId (Set QName) -> BuiltinThings PrimFun -> MetaId -> MutualId -> CtxId -> ProblemId -> Int -> PostScopeState

-- | Highlighting info.
stPostSyntaxInfo :: PostScopeState -> CompressedFile

-- | Disambiguation carried out by the type checker. Maps position of first
--   name character to disambiguated <tt><a>QName</a></tt> for each
--   <tt><a>AmbiguousQName</a></tt> already passed by the type checker.
stPostDisambiguatedNames :: PostScopeState -> !DisambiguatedNames
stPostMetaStore :: PostScopeState -> MetaStore
stPostInteractionPoints :: PostScopeState -> InteractionPoints
stPostAwakeConstraints :: PostScopeState -> Constraints
stPostSleepingConstraints :: PostScopeState -> Constraints

-- | Dirty when a constraint is added, used to prevent pointer update.
--   Currently unused.
stPostDirty :: PostScopeState -> Bool

-- | Definitions to be considered during occurs check. Initialized to the
--   current mutual block before the check. During occurs check, we remove
--   definitions from this set as soon we have checked them.
stPostOccursCheckDefs :: PostScopeState -> Set QName

-- | Declared identifiers of the current file. These will be serialized
--   after successful type checking.
stPostSignature :: PostScopeState -> Signature

-- | The current module is available after it has been type checked.
stPostCurrentModule :: PostScopeState -> Maybe ModuleName
stPostInstanceDefs :: PostScopeState -> TempInstanceTable

-- | Counters to collect various statistics about meta variables etc. Only
--   for current file.
stPostStatistics :: PostScopeState -> Statistics
stPostMutualBlocks :: PostScopeState -> Map MutualId (Set QName)
stPostLocalBuiltins :: PostScopeState -> BuiltinThings PrimFun
stPostFreshMetaId :: PostScopeState -> MetaId
stPostFreshMutualId :: PostScopeState -> MutualId
stPostFreshCtxId :: PostScopeState -> CtxId
stPostFreshProblemId :: PostScopeState -> ProblemId
stPostFreshInt :: PostScopeState -> Int

-- | A part of the state which is not reverted when an error is thrown or
--   the state is reset.
data PersistentTCState
PersistentTCSt :: DecodedModules -> CommandLineOptions -> InteractionOutputCallback -> !Benchmark -> !Statistics -> PersistentTCState
stDecodedModules :: PersistentTCState -> DecodedModules
stPersistentOptions :: PersistentTCState -> CommandLineOptions

-- | Callback function to call when there is a response to give to the
--   interactive frontend. See the documentation of
--   <a>InteractionOutputCallback</a>.
stInteractionOutputCallback :: PersistentTCState -> InteractionOutputCallback

-- | Structure to track how much CPU time was spent on which Agda phase.
--   Needs to be a strict field to avoid space leaks!
stBenchmark :: PersistentTCState -> !Benchmark

-- | Should be strict field.
stAccumStatistics :: PersistentTCState -> !Statistics

-- | Empty persistent state.
initPersistentState :: PersistentTCState

-- | Empty state of type checker.
initPreScopeState :: PreScopeState
initPostScopeState :: PostScopeState
initState :: TCState
stTokens :: Lens' CompressedFile TCState
stImports :: Lens' Signature TCState
stImportedModules :: Lens' (Set ModuleName) TCState
stModuleToSource :: Lens' ModuleToSource TCState
stVisitedModules :: Lens' VisitedModules TCState
stScope :: Lens' ScopeInfo TCState
stPatternSyns :: Lens' PatternSynDefns TCState
stPatternSynImports :: Lens' PatternSynDefns TCState
stPragmaOptions :: Lens' PragmaOptions TCState
stImportedBuiltins :: Lens' (BuiltinThings PrimFun) TCState
stHaskellImports :: Lens' (Set String) TCState
stFreshInteractionId :: Lens' InteractionId TCState
stFreshNameId :: Lens' NameId TCState
stSyntaxInfo :: Lens' CompressedFile TCState
stDisambiguatedNames :: Lens' DisambiguatedNames TCState
stMetaStore :: Lens' MetaStore TCState
stInteractionPoints :: Lens' InteractionPoints TCState
stAwakeConstraints :: Lens' Constraints TCState
stSleepingConstraints :: Lens' Constraints TCState
stDirty :: Lens' Bool TCState
stOccursCheckDefs :: Lens' (Set QName) TCState
stSignature :: Lens' Signature TCState
stCurrentModule :: Lens' (Maybe ModuleName) TCState
stInstanceDefs :: Lens' TempInstanceTable TCState
stStatistics :: Lens' Statistics TCState
stMutualBlocks :: Lens' (Map MutualId (Set QName)) TCState
stLocalBuiltins :: Lens' (BuiltinThings PrimFun) TCState
stFreshMetaId :: Lens' MetaId TCState
stFreshMutualId :: Lens' MutualId TCState
stFreshCtxId :: Lens' CtxId TCState
stFreshProblemId :: Lens' ProblemId TCState
stFreshInt :: Lens' Int TCState
stBuiltinThings :: TCState -> BuiltinThings PrimFun
class Enum i => HasFresh i
freshLens :: HasFresh i => Lens' i TCState
nextFresh :: HasFresh i => TCState -> (i, TCState)
fresh :: (HasFresh i, MonadState TCState m) => m i
newtype ProblemId
ProblemId :: Nat -> ProblemId
freshName :: (MonadState TCState m, HasFresh NameId) => Range -> String -> m Name
freshNoName :: (MonadState TCState m, HasFresh NameId) => Range -> m Name
freshNoName_ :: (MonadState TCState m, HasFresh NameId) => m Name

-- | Create a fresh name from <tt>a</tt>.
class FreshName a
freshName_ :: (FreshName a, MonadState TCState m, HasFresh NameId) => a -> m Name

-- | Maps top-level module names to the corresponding source file names.
type ModuleToSource = Map TopLevelModuleName AbsolutePath

-- | Maps source file names to the corresponding top-level module names.
type SourceToModule = Map AbsolutePath TopLevelModuleName

-- | Creates a <a>SourceToModule</a> map based on <a>stModuleToSource</a>.
sourceToModule :: TCM SourceToModule
data ModuleInfo
ModuleInfo :: Interface -> Bool -> ModuleInfo
miInterface :: ModuleInfo -> Interface

-- | <a>True</a> if warnings were encountered when the module was type
--   checked.
miWarnings :: ModuleInfo -> Bool
type VisitedModules = Map TopLevelModuleName ModuleInfo
type DecodedModules = Map TopLevelModuleName Interface
data Interface
Interface :: Hash -> [(ModuleName, Hash)] -> ModuleName -> Map ModuleName Scope -> ScopeInfo -> Signature -> BuiltinThings (String, QName) -> Set String -> HighlightingInfo -> [OptionsPragma] -> PatternSynDefns -> Interface

-- | Hash of the source code.
iSourceHash :: Interface -> Hash

-- | Imported modules and their hashes.
iImportedModules :: Interface -> [(ModuleName, Hash)]

-- | Module name of this interface.
iModuleName :: Interface -> ModuleName

-- | Scope defined by this module.
iScope :: Interface -> Map ModuleName Scope

-- | Scope after we loaded this interface. Used in <a>AtTopLevel</a> and
--   <a>interactionLoop</a>.
--   
--   Andreas, AIM XX: For performance reason, this field is not serialized,
--   so if you deserialize an interface, <tt>iInsideScope</tt> will be
--   empty. You need to type-check the file to get <tt>iInsideScope</tt>.
iInsideScope :: Interface -> ScopeInfo
iSignature :: Interface -> Signature
iBuiltin :: Interface -> BuiltinThings (String, QName)

-- | Haskell imports listed in (transitively) imported modules are not
--   included here.
iHaskellImports :: Interface -> Set String
iHighlighting :: Interface -> HighlightingInfo

-- | Pragma options set in the file.
iPragmaOptions :: Interface -> [OptionsPragma]
iPatternSyns :: Interface -> PatternSynDefns

-- | Combines the source hash and the (full) hashes of the imported
--   modules.
iFullHash :: Interface -> Hash
data Closure a
Closure :: Signature -> TCEnv -> ScopeInfo -> a -> Closure a
clSignature :: Closure a -> Signature
clEnv :: Closure a -> TCEnv
clScope :: Closure a -> ScopeInfo
clValue :: Closure a -> a
buildClosure :: a -> TCM (Closure a)
type Constraints = [ProblemConstraint]
data ProblemConstraint
PConstr :: ProblemId -> Closure Constraint -> ProblemConstraint
constraintProblem :: ProblemConstraint -> ProblemId
theConstraint :: ProblemConstraint -> Closure Constraint
data Constraint
ValueCmp :: Comparison -> Type -> Term -> Term -> Constraint
ElimCmp :: [Polarity] -> Type -> Term -> [Elim] -> [Elim] -> Constraint
TypeCmp :: Comparison -> Type -> Type -> Constraint

-- | the two types are for the error message only
TelCmp :: Type -> Type -> Comparison -> Telescope -> Telescope -> Constraint
SortCmp :: Comparison -> Sort -> Sort -> Constraint
LevelCmp :: Comparison -> Level -> Level -> Constraint
UnBlock :: MetaId -> Constraint
Guarded :: Constraint -> ProblemId -> Constraint

-- | the range is the one of the absurd pattern
IsEmpty :: Range -> Type -> Constraint
FindInScope :: MetaId -> (Maybe [(Term, Type)]) -> Constraint
data Comparison
CmpEq :: Comparison
CmpLeq :: Comparison

-- | An extension of <a>Comparison</a> to <tt>&gt;=</tt>.
data CompareDirection
DirEq :: CompareDirection
DirLeq :: CompareDirection
DirGeq :: CompareDirection

-- | Embed <a>Comparison</a> into <a>CompareDirection</a>.
fromCmp :: Comparison -> CompareDirection

-- | Flip the direction of comparison.
flipCmp :: CompareDirection -> CompareDirection

-- | Turn a <a>Comparison</a> function into a <a>CompareDirection</a>
--   function.
--   
--   Property: <tt>dirToCmp f (fromCmp cmp) = f cmp</tt>
dirToCmp :: (Comparison -> a -> a -> c) -> CompareDirection -> a -> a -> c

-- | A thing tagged with the context it came from.
data Open a
OpenThing :: [CtxId] -> a -> Open a
openThingCtxIds :: Open a -> [CtxId]
openThing :: Open a -> a
data Judgement t a
HasType :: a -> t -> Judgement t a
jMetaId :: Judgement t a -> a
jMetaType :: Judgement t a -> t
IsSort :: a -> t -> Judgement t a
jMetaId :: Judgement t a -> a
jMetaType :: Judgement t a -> t
data MetaVariable
MetaVar :: MetaInfo -> MetaPriority -> Permutation -> Judgement Type MetaId -> MetaInstantiation -> Set Listener -> Frozen -> MetaVariable
mvInfo :: MetaVariable -> MetaInfo

-- | some metavariables are more eager to be instantiated
mvPriority :: MetaVariable -> MetaPriority

-- | a metavariable doesn't have to depend on all variables in the context,
--   this "permutation" will throw away the ones it does not depend on
mvPermutation :: MetaVariable -> Permutation
mvJudgement :: MetaVariable -> Judgement Type MetaId
mvInstantiation :: MetaVariable -> MetaInstantiation

-- | meta variables scheduled for eta-expansion but blocked by this one
mvListeners :: MetaVariable -> Set Listener

-- | are we past the point where we can instantiate this meta variable?
mvFrozen :: MetaVariable -> Frozen
data Listener
EtaExpand :: MetaId -> Listener
CheckConstraint :: Nat -> ProblemConstraint -> Listener

-- | Frozen meta variable cannot be instantiated by unification. This
--   serves to prevent the completion of a definition by its use outside of
--   the current block. (See issues 118, 288, 399).
data Frozen

-- | Do not instantiate.
Frozen :: Frozen
Instantiable :: Frozen
data MetaInstantiation

-- | solved by term (abstracted over some free variables)
InstV :: [Arg String] -> Term -> MetaInstantiation

-- | solved by <tt>Lam .. Sort s</tt>
InstS :: Term -> MetaInstantiation

-- | unsolved
Open :: MetaInstantiation

-- | open, to be instantiated as "implicit from scope"
OpenIFS :: MetaInstantiation

-- | solution blocked by unsolved constraints
BlockedConst :: Term -> MetaInstantiation
PostponedTypeCheckingProblem :: (Closure TypeCheckingProblem) -> (TCM Bool) -> MetaInstantiation
data TypeCheckingProblem
CheckExpr :: Expr -> Type -> TypeCheckingProblem
CheckArgs :: ExpandHidden -> ExpandInstances -> Range -> [NamedArg Expr] -> Type -> Type -> (Args -> Type -> TCM Term) -> TypeCheckingProblem

-- | Meta variable priority: When we have an equation between
--   meta-variables, which one should be instantiated?
--   
--   Higher value means higher priority to be instantiated.
newtype MetaPriority
MetaPriority :: Int -> MetaPriority
data RunMetaOccursCheck
RunMetaOccursCheck :: RunMetaOccursCheck
DontRunMetaOccursCheck :: RunMetaOccursCheck

-- | <tt>MetaInfo</tt> is cloned from one meta to the next during pruning.
data MetaInfo
MetaInfo :: Closure Range -> RunMetaOccursCheck -> MetaNameSuggestion -> MetaInfo
miClosRange :: MetaInfo -> Closure Range

-- | Run the extended occurs check that goes in definitions?
miMetaOccursCheck :: MetaInfo -> RunMetaOccursCheck

-- | Used for printing. <tt>Just x</tt> if meta-variable comes from omitted
--   argument with name <tt>x</tt>.
miNameSuggestion :: MetaInfo -> MetaNameSuggestion

-- | Name suggestion for meta variable. Empty string means no suggestion.
type MetaNameSuggestion = String

-- | For printing, we couple a meta with its name suggestion.
data NamedMeta
NamedMeta :: MetaNameSuggestion -> MetaId -> NamedMeta
nmSuggestion :: NamedMeta -> MetaNameSuggestion
nmid :: NamedMeta -> MetaId
type MetaStore = Map MetaId MetaVariable
normalMetaPriority :: MetaPriority
lowMetaPriority :: MetaPriority
highMetaPriority :: MetaPriority
getMetaInfo :: MetaVariable -> Closure Range
getMetaScope :: MetaVariable -> ScopeInfo
getMetaEnv :: MetaVariable -> TCEnv
getMetaSig :: MetaVariable -> Signature
getMetaRelevance :: MetaVariable -> Relevance
getMetaColors :: MetaVariable -> [Color]

-- | Interaction points are created by the scope checker who sets the
--   range. The meta variable is created by the type checker and then
--   hooked up to the interaction point.
data InteractionPoint
InteractionPoint :: Range -> Maybe MetaId -> InteractionPoint

-- | The position of the interaction point.
ipRange :: InteractionPoint -> Range

-- | The meta variable, if any, holding the type etc.
ipMeta :: InteractionPoint -> Maybe MetaId

-- | Data structure managing the interaction points.
type InteractionPoints = Map InteractionId InteractionPoint
data Signature
Sig :: Sections -> Definitions -> Signature
sigSections :: Signature -> Sections
sigDefinitions :: Signature -> Definitions
type Sections = Map ModuleName Section
type Definitions = HashMap QName Definition
data Section
Section :: Telescope -> Nat -> Section
secTelescope :: Section -> Telescope

-- | This is the number of parameters when we're inside the section and 0
--   outside. It's used to know how much of the context to apply function
--   from the section to when translating from abstract to internal syntax.
secFreeVars :: Section -> Nat
emptySignature :: Signature

-- | A <tt>DisplayForm</tt> is in essence a rewrite rule <tt> q ts --&gt;
--   dt </tt> for a defined symbol (could be a constructor as well)
--   <tt>q</tt>. The right hand side is a <a>DisplayTerm</a> which is used
--   to <tt>reify</tt> to a more readable <a>Syntax</a>.
--   
--   The patterns <tt>ts</tt> are just terms, but <tt>var 0</tt> is
--   interpreted as a hole. Each occurrence of <tt>var 0</tt> is a new hole
--   (pattern var). For each *occurrence* of <tt>var0</tt> the rhs
--   <tt>dt</tt> has a free variable. These are instantiated when matching
--   a display form against a term <tt>q vs</tt> succeeds.
data DisplayForm
Display :: Nat -> [Term] -> DisplayTerm -> DisplayForm

-- | Number <tt>n</tt> of free variables in <a>dfRHS</a>.
dfFreeVars :: DisplayForm -> Nat

-- | Left hand side patterns, where <tt>var 0</tt> stands for a pattern
--   variable. There should be <tt>n</tt> occurrences of <tt>var0</tt> in
--   <a>dfPats</a>.
dfPats :: DisplayForm -> [Term]

-- | Right hand side, with <tt>n</tt> free variables.
dfRHS :: DisplayForm -> DisplayTerm

-- | A structured presentation of a <a>Term</a> for reification into
--   <a>Syntax</a>.
data DisplayTerm

-- | <tt>(f vs | ws) us</tt>. The first <a>DisplayTerm</a> is the parent
--   function <tt>f</tt> with its args <tt>vs</tt>. The list of
--   <a>DisplayTerm</a>s are the with expressions <tt>ws</tt>. The
--   <a>Args</a> are additional arguments <tt>us</tt> (possible in case the
--   with-application is of function type).
DWithApp :: DisplayTerm -> [DisplayTerm] -> Args -> DisplayTerm

-- | <tt>c vs</tt>.
DCon :: ConHead -> [Arg DisplayTerm] -> DisplayTerm

-- | <tt>d vs</tt>.
DDef :: QName -> [Arg DisplayTerm] -> DisplayTerm

-- | <tt>.v</tt>.
DDot :: Term -> DisplayTerm

-- | <tt>v</tt>.
DTerm :: Term -> DisplayTerm

-- | By default, we have no display form.
defaultDisplayForm :: QName -> [Open DisplayForm]
defRelevance :: Definition -> Relevance
defColors :: Definition -> [Color]
type RewriteRules = [RewriteRule]

-- | Rewrite rules can be added independently from function clauses.
data RewriteRule
RewriteRule :: QName -> Telescope -> Term -> Term -> Type -> RewriteRule

-- | Name of rewrite rule <tt>q : Γ → lhs ≡ rhs</tt> where <tt>≡</tt> is
--   the rewrite relation.
rewName :: RewriteRule -> QName

-- | <tt>Γ</tt>.
rewContext :: RewriteRule -> Telescope

-- | <tt>Γ ⊢ lhs : t</tt>.
rewLHS :: RewriteRule -> Term

-- | <tt>Γ ⊢ rhs : t</tt>.
rewRHS :: RewriteRule -> Term

-- | <tt>Γ ⊢ t</tt>.
rewType :: RewriteRule -> Type
data Definition
Defn :: ArgInfo -> QName -> Type -> [Polarity] -> [Occurrence] -> [Open DisplayForm] -> MutualId -> CompiledRepresentation -> RewriteRules -> Maybe QName -> Defn -> Definition

-- | Hiding should not be used.
defArgInfo :: Definition -> ArgInfo
defName :: Definition -> QName

-- | Type of the lifted definition.
defType :: Definition -> Type
defPolarity :: Definition -> [Polarity]
defArgOccurrences :: Definition -> [Occurrence]
defDisplay :: Definition -> [Open DisplayForm]
defMutual :: Definition -> MutualId
defCompiledRep :: Definition -> CompiledRepresentation

-- | Rewrite rules for this symbol, (additional to function clauses).
defRewriteRules :: Definition -> RewriteRules

-- | <tt>Just q</tt> when this definition is an instance of class q
defInstance :: Definition -> Maybe QName
theDef :: Definition -> Defn

-- | Create a definition with sensible defaults.
defaultDefn :: ArgInfo -> QName -> Type -> Defn -> Definition
type HaskellCode = String
type HaskellType = String
type EpicCode = String
type JSCode = Exp
data HaskellRepresentation
HsDefn :: HaskellType -> HaskellCode -> HaskellRepresentation
HsType :: HaskellType -> HaskellRepresentation
data HaskellExport
HsExport :: HaskellType -> String -> HaskellExport

-- | Polarity for equality and subtype checking.
data Polarity

-- | monotone
Covariant :: Polarity

-- | antitone
Contravariant :: Polarity

-- | no information (mixed variance)
Invariant :: Polarity

-- | constant
Nonvariant :: Polarity
data CompiledRepresentation
CompiledRep :: Maybe HaskellRepresentation -> Maybe HaskellExport -> Maybe EpicCode -> Maybe JSCode -> CompiledRepresentation
compiledHaskell :: CompiledRepresentation -> Maybe HaskellRepresentation
exportHaskell :: CompiledRepresentation -> Maybe HaskellExport
compiledEpic :: CompiledRepresentation -> Maybe EpicCode
compiledJS :: CompiledRepresentation -> Maybe JSCode
noCompiledRep :: CompiledRepresentation

-- | Subterm occurrences for positivity checking. The constructors are
--   listed in increasing information they provide: <tt>Mixed &lt;= JustPos
--   &lt;= StrictPos &lt;= GuardPos &lt;= Unused</tt> <tt>Mixed &lt;=
--   JustNeg &lt;= Unused</tt>.
data Occurrence

-- | Arbitrary occurrence (positive and negative).
Mixed :: Occurrence

-- | Negative occurrence.
JustNeg :: Occurrence

-- | Positive occurrence, but not strictly positive.
JustPos :: Occurrence

-- | Strictly positive occurrence.
StrictPos :: Occurrence

-- | Guarded strictly positive occurrence (i.e., under ∞). For checking
--   recursive records.
GuardPos :: Occurrence
Unused :: Occurrence

-- | Additional information for projection <a>Function</a>s.
data Projection
Projection :: Maybe QName -> QName -> Int -> Term -> ArgInfo -> Projection

-- | <tt>Nothing</tt> if only projection-like, <tt>Just q</tt> if record
--   projection, where <tt>q</tt> is the original projection name (current
--   name could be from module app).
projProper :: Projection -> Maybe QName

-- | Type projected from. Record type if <tt>projProper = Just{}</tt>.
projFromType :: Projection -> QName

-- | Index of the record argument. Start counting with 1, because 0 means
--   that it is already applied to the record. (Can happen in module
--   instantiation.)
projIndex :: Projection -> Int

-- | Term <tt>t</tt> to be be applied to record parameters and record
--   value. The parameters will be dropped. In case of a proper projection,
--   a postfix projection application will be created: <tt>t = pars r -&gt;
--   r .p</tt> In case of a projection-like function, just the function
--   symbol is returned as <a>Def</a>: <tt>t = pars -&gt; f</tt>.
projDropPars :: Projection -> Term

-- | The info of the principal (record) argument.
projArgInfo :: Projection -> ArgInfo
data Defn

-- | Postulate.
Axiom :: Defn
Function :: [Clause] -> Maybe CompiledClauses -> FunctionInverse -> [QName] -> IsAbstract -> Delayed -> Maybe Projection -> Bool -> Bool -> Maybe Bool -> Maybe (Int, Int) -> Maybe QName -> Bool -> Defn
funClauses :: Defn -> [Clause]

-- | <a>Nothing</a> while function is still type-checked. <tt>Just cc</tt>
--   after type and coverage checking and translation to case trees.
funCompiled :: Defn -> Maybe CompiledClauses
funInv :: Defn -> FunctionInverse

-- | Mutually recursive functions, <tt>data</tt>s and <tt>record</tt>s.
--   Does not include this function.
funMutual :: Defn -> [QName]
funAbstr :: Defn -> IsAbstract

-- | Are the clauses of this definition delayed?
funDelayed :: Defn -> Delayed

-- | Is it a record projection? If yes, then return the name of the record
--   type and index of the record argument. Start counting with 1, because
--   0 means that it is already applied to the record. (Can happen in
--   module instantiation.) This information is used in the termination
--   checker.
funProjection :: Defn -> Maybe Projection

-- | Should calls to this function be normalised at compile-time?
funStatic :: Defn -> Bool

-- | Has this function been created by a module instantiation?
funCopy :: Defn -> Bool

-- | Has this function been termination checked? Did it pass?
funTerminates :: Defn -> Maybe Bool

-- | Is this function generated from an extended lambda? If yes, then
--   return the number of hidden and non-hidden lambda-lifted arguments
funExtLam :: Defn -> Maybe (Int, Int)

-- | Is this a generated with-function? If yes, then what's the name of the
--   parent function.
funWith :: Defn -> Maybe QName

-- | Is this a function defined by copatterns?
funCopatternLHS :: Defn -> Bool
Datatype :: Nat -> Permutation -> Drop Permutation -> Nat -> Induction -> (Maybe Clause) -> [QName] -> Sort -> [QName] -> IsAbstract -> Defn

-- | Number of parameters.
dataPars :: Defn -> Nat

-- | Parameters that are maybe small.
dataSmallPars :: Defn -> Permutation

-- | Parameters that appear in indices.
dataNonLinPars :: Defn -> Drop Permutation

-- | Number of indices.
dataIxs :: Defn -> Nat

-- | <tt>data</tt> or <tt>codata</tt> (legacy).
dataInduction :: Defn -> Induction

-- | This might be in an instantiated module.
dataClause :: Defn -> (Maybe Clause)

-- | Constructor names.
dataCons :: Defn -> [QName]
dataSort :: Defn -> Sort

-- | Mutually recursive functions, <tt>data</tt>s and <tt>record</tt>s.
--   Does not include this data type.
dataMutual :: Defn -> [QName]
dataAbstr :: Defn -> IsAbstract
Record :: Nat -> Maybe Clause -> ConHead -> Bool -> Type -> [Arg QName] -> Telescope -> [QName] -> Bool -> Maybe Induction -> Bool -> IsAbstract -> Defn

-- | Number of parameters.
recPars :: Defn -> Nat
recClause :: Defn -> Maybe Clause

-- | Constructor name and fields.
recConHead :: Defn -> ConHead
recNamedCon :: Defn -> Bool

-- | The record constructor's type. (Includes record parameters.)
recConType :: Defn -> Type
recFields :: Defn -> [Arg QName]

-- | The record field telescope. (Includes record parameters.) Note:
--   <tt>TelV recTel _ == telView' recConType</tt>. Thus, <tt>recTel</tt>
--   is redundant.
recTel :: Defn -> Telescope

-- | Mutually recursive functions, <tt>data</tt>s and <tt>record</tt>s.
--   Does not include this record.
recMutual :: Defn -> [QName]

-- | Eta-expand at this record type. <tt>False</tt> for unguarded recursive
--   records and coinductive records.
recEtaEquality :: Defn -> Bool

-- | <a>Inductive</a> or <a>CoInductive</a>? Matters only for recursive
--   records. <a>Nothing</a> means that the user did not specify it, which
--   is an error for recursive records.
recInduction :: Defn -> Maybe Induction

-- | Recursive record. Implies <tt>recEtaEquality = False</tt>. Projections
--   are not size-preserving.
recRecursive :: Defn -> Bool
recAbstr :: Defn -> IsAbstract
Constructor :: Nat -> ConHead -> QName -> IsAbstract -> Induction -> Defn

-- | Number of parameters.
conPars :: Defn -> Nat

-- | Name of (original) constructor and fields. (This might be in a module
--   instance.)
conSrcCon :: Defn -> ConHead

-- | Name of datatype or record type.
conData :: Defn -> QName
conAbstr :: Defn -> IsAbstract

-- | Inductive or coinductive?
conInd :: Defn -> Induction

-- | Primitive or builtin functions.
Primitive :: IsAbstract -> String -> [Clause] -> Maybe CompiledClauses -> Defn
primAbstr :: Defn -> IsAbstract
primName :: Defn -> String

-- | <a>null</a> for primitive functions, <tt>not null</tt> for builtin
--   functions.
primClauses :: Defn -> [Clause]

-- | <a>Nothing</a> for primitive functions, <tt><a>Just</a> something</tt>
--   for builtin functions.
primCompiled :: Defn -> Maybe CompiledClauses

-- | A template for creating <a>Function</a> definitions, with sensible
--   defaults.
emptyFunction :: Defn
isCopatternLHS :: [Clause] -> Bool
recCon :: Defn -> QName
defIsRecord :: Defn -> Bool
defIsDataOrRecord :: Defn -> Bool
newtype Fields
Fields :: [(Name, Type)] -> Fields

-- | Did we encounter a simplifying reduction? In terms of CIC, that would
--   be a iota-reduction. In terms of Agda, this is a constructor or
--   literal pattern that matched. Just beta-reduction (substitution) or
--   delta-reduction (unfolding of definitions) does not count as
--   simplifying?
data Simplification
YesSimplification :: Simplification
NoSimplification :: Simplification
data Reduced no yes
NoReduction :: no -> Reduced no yes
YesReduction :: Simplification -> yes -> Reduced no yes

-- | Three cases: 1. not reduced, 2. reduced, but blocked, 3. reduced, not
--   blocked.
data IsReduced
NotReduced :: IsReduced
Reduced :: (Blocked ()) -> IsReduced
data MaybeReduced a
MaybeRed :: IsReduced -> a -> MaybeReduced a
isReduced :: MaybeReduced a -> IsReduced
ignoreReduced :: MaybeReduced a -> a
type MaybeReducedArgs = [MaybeReduced (Arg Term)]
type MaybeReducedElims = [MaybeReduced Elim]
notReduced :: a -> MaybeReduced a
reduced :: Blocked (Arg Term) -> MaybeReduced (Arg Term)

-- | Controlling <tt>reduce</tt>.
data AllowedReduction

-- | (Projection and) projection-like functions may be reduced.
ProjectionReductions :: AllowedReduction

-- | Functions which are not projections may be reduced.
FunctionReductions :: AllowedReduction

-- | Reduce <tt><a>Level</a></tt> terms.
LevelReductions :: AllowedReduction

-- | Functions that have not passed termination checking.
NonTerminatingReductions :: AllowedReduction
type AllowedReductions = [AllowedReduction]

-- | Not quite all reductions (skip non-terminating reductions)
allReductions :: AllowedReductions
data PrimFun
PrimFun :: QName -> Arity -> ([Arg Term] -> ReduceM (Reduced MaybeReducedArgs Term)) -> PrimFun
primFunName :: PrimFun -> QName
primFunArity :: PrimFun -> Arity
primFunImplementation :: PrimFun -> [Arg Term] -> ReduceM (Reduced MaybeReducedArgs Term)
defClauses :: Definition -> [Clause]
defCompiled :: Definition -> Maybe CompiledClauses
defJSDef :: Definition -> Maybe JSCode
defEpicDef :: Definition -> Maybe EpicCode

-- | Are the clauses of this definition delayed?
defDelayed :: Definition -> Delayed

-- | Has the definition failed the termination checker?
defNonterminating :: Definition -> Bool

-- | Is the definition just a copy created by a module instantiation?
defCopy :: Definition -> Bool
defAbstract :: Definition -> IsAbstract
type FunctionInverse = FunctionInverse' Clause
data FunctionInverse' c
NotInjective :: FunctionInverse' c
Inverse :: (Map TermHead c) -> FunctionInverse' c
data TermHead
SortHead :: TermHead
PiHead :: TermHead
ConsHead :: QName -> TermHead
newtype MutualId
MutId :: Int32 -> MutualId
type Statistics = Map String Integer
data Call
CheckClause :: Type -> SpineClause -> (Maybe Clause) -> Call
CheckPattern :: Pattern -> Telescope -> Type -> (Maybe a) -> Call
CheckLetBinding :: LetBinding -> (Maybe ()) -> Call
InferExpr :: Expr -> (Maybe (Term, Type)) -> Call
CheckExprCall :: Expr -> Type -> (Maybe Term) -> Call
CheckDotPattern :: Expr -> Term -> (Maybe Constraints) -> Call
CheckPatternShadowing :: SpineClause -> (Maybe ()) -> Call
IsTypeCall :: Expr -> Sort -> (Maybe Type) -> Call
IsType_ :: Expr -> (Maybe Type) -> Call
InferVar :: Name -> (Maybe (Term, Type)) -> Call
InferDef :: Range -> QName -> (Maybe (Term, Type)) -> Call
CheckArguments :: Range -> [NamedArg Expr] -> Type -> Type -> (Maybe (Args, Type)) -> Call
CheckDataDef :: Range -> Name -> [LamBinding] -> [Constructor] -> (Maybe ()) -> Call
CheckRecDef :: Range -> Name -> [LamBinding] -> [Constructor] -> (Maybe ()) -> Call
CheckConstructor :: QName -> Telescope -> Sort -> Constructor -> (Maybe ()) -> Call
CheckFunDef :: Range -> Name -> [Clause] -> (Maybe ()) -> Call
CheckPragma :: Range -> Pragma -> (Maybe ()) -> Call
CheckPrimitive :: Range -> Name -> Expr -> (Maybe ()) -> Call
CheckIsEmpty :: Range -> Type -> (Maybe ()) -> Call
CheckWithFunctionType :: Expr -> (Maybe ()) -> Call
CheckSectionApplication :: Range -> ModuleName -> ModuleApplication -> (Maybe ()) -> Call
ScopeCheckExpr :: Expr -> (Maybe Expr) -> Call
ScopeCheckDeclaration :: NiceDeclaration -> (Maybe [Declaration]) -> Call
ScopeCheckLHS :: Name -> Pattern -> (Maybe LHS) -> Call
NoHighlighting :: (Maybe a) -> Call

-- | used by <tt>setCurrentRange</tt>
SetRange :: Range -> (Maybe a) -> Call

-- | The instance table is a <tt>Map</tt> associating to every name of
--   record<i>data type</i>postulate its list of instances
type InstanceTable = Map QName [QName]

-- | When typechecking something of the following form:
--   
--   instance x : _ x = y
--   
--   it's not yet known where to add <tt>x</tt>, so we add it to a list of
--   unresolved instances and we'll deal with it later.
type TempInstanceTable = (InstanceTable, [QName])
data BuiltinDescriptor
BuiltinData :: (TCM Type) -> [String] -> BuiltinDescriptor
BuiltinDataCons :: (TCM Type) -> BuiltinDescriptor
BuiltinPrim :: String -> (Term -> TCM ()) -> BuiltinDescriptor
BuiltinPostulate :: Relevance -> (TCM Type) -> BuiltinDescriptor

-- | Builtin of any kind. Type can be checked (<tt>Just t</tt>) or inferred
--   (<tt>Nothing</tt>). The second argument is the hook for the
--   verification function.
BuiltinUnknown :: (Maybe (TCM Type)) -> (Term -> Type -> TCM ()) -> BuiltinDescriptor
data BuiltinInfo
BuiltinInfo :: String -> BuiltinDescriptor -> BuiltinInfo
builtinName :: BuiltinInfo -> String
builtinDesc :: BuiltinInfo -> BuiltinDescriptor
type BuiltinThings pf = Map String (Builtin pf)
data Builtin pf
Builtin :: Term -> Builtin pf
Prim :: pf -> Builtin pf

-- | How much highlighting should be sent to the user interface?
data HighlightingLevel
None :: HighlightingLevel
NonInteractive :: HighlightingLevel

-- | This includes both non-interactive highlighting and interactive
--   highlighting of the expression that is currently being type-checked.
Interactive :: HighlightingLevel

-- | How should highlighting be sent to the user interface?
data HighlightingMethod

-- | Via stdout.
Direct :: HighlightingMethod

-- | Both via files and via stdout.
Indirect :: HighlightingMethod

-- | <tt>ifTopLevelAndHighlightingLevelIs l m</tt> runs <tt>m</tt> when
--   we're type-checking the top-level module and the highlighting level is
--   <i>at least</i> <tt>l</tt>.
ifTopLevelAndHighlightingLevelIs :: MonadTCM tcm => HighlightingLevel -> tcm () -> tcm ()
data TCEnv
TCEnv :: Context -> LetBindings -> ModuleName -> AbsolutePath -> [(ModuleName, Nat)] -> [TopLevelModuleName] -> Maybe MutualId -> TerminationCheck () -> Bool -> Bool -> [ProblemId] -> AbstractMode -> Relevance -> [Color] -> Bool -> Bool -> Bool -> Range -> Range -> Maybe (Closure Call) -> HighlightingLevel -> HighlightingMethod -> Integer -> Bool -> ExpandHidden -> Maybe QName -> Simplification -> AllowedReductions -> Bool -> Bool -> Bool -> Bool -> TCEnv
envContext :: TCEnv -> Context
envLetBindings :: TCEnv -> LetBindings
envCurrentModule :: TCEnv -> ModuleName

-- | The path to the file that is currently being type-checked.
envCurrentPath :: TCEnv -> AbsolutePath

-- | anonymous modules and their number of free variables
envAnonymousModules :: TCEnv -> [(ModuleName, Nat)]

-- | to detect import cycles
envImportPath :: TCEnv -> [TopLevelModuleName]

-- | the current (if any) mutual block
envMutualBlock :: TCEnv -> Maybe MutualId

-- | are we inside the scope of a termination pragma
envTerminationCheck :: TCEnv -> TerminationCheck ()

-- | Are we currently in the process of solving active constraints?
envSolvingConstraints :: TCEnv -> Bool

-- | Are we allowed to assign metas?
envAssignMetas :: TCEnv -> Bool
envActiveProblems :: TCEnv -> [ProblemId]

-- | When checking the typesignature of a public definition or the body of
--   a non-abstract definition this is true. To prevent information about
--   abstract things leaking outside the module.
envAbstractMode :: TCEnv -> AbstractMode

-- | Are we checking an irrelevant argument? (=<tt>Irrelevant</tt>) Then
--   top-level irrelevant declarations are enabled. Other value:
--   <tt>Relevant</tt>, then only relevant decls. are avail.
envRelevance :: TCEnv -> Relevance
envColors :: TCEnv -> [Color]

-- | Sometimes we want to disable display forms.
envDisplayFormsEnabled :: TCEnv -> Bool

-- | should we try to recover interaction points when reifying? disabled
--   when generating types for with functions
envReifyInteractionPoints :: TCEnv -> Bool

-- | it's safe to eta contract implicit lambdas as long as we're not going
--   to reify and retypecheck (like when doing with abstraction)
envEtaContractImplicit :: TCEnv -> Bool
envRange :: TCEnv -> Range

-- | Interactive highlighting uses this range rather than <a>envRange</a>.
envHighlightingRange :: TCEnv -> Range

-- | what we're doing at the moment
envCall :: TCEnv -> Maybe (Closure Call)

-- | Set to <a>None</a> when imported modules are type-checked.
envHighlightingLevel :: TCEnv -> HighlightingLevel
envHighlightingMethod :: TCEnv -> HighlightingMethod

-- | This number indicates how far away from the top-level module Agda has
--   come when chasing modules. The level of a given module is not
--   necessarily the same as the length, in the module dependency graph, of
--   the shortest path from the top-level module; it depends on in which
--   order Agda chooses to chase dependencies.
envModuleNestingLevel :: TCEnv -> Integer

-- | When True, allows destructively shared updating terms during
--   evaluation or unification. This is disabled when doing speculative
--   checking, like solve instance metas, or when updating might break
--   abstraction, as is the case when checking abstract definitions.
envAllowDestructiveUpdate :: TCEnv -> Bool

-- | When type-checking an alias f=e, we do not want to insert hidden
--   arguments in the end, because these will become unsolved metas.
envExpandLast :: TCEnv -> ExpandHidden

-- | We are reducing an application of this function. (For debugging of
--   incomplete matches only.)
envAppDef :: TCEnv -> Maybe QName

-- | Did we encounter a simplification (proper match) during the current
--   reduction process?
envSimplification :: TCEnv -> Simplification
envAllowedReductions :: TCEnv -> AllowedReductions

-- | Can we compare blocked things during conversion? No by default. Yes
--   for rewriting feature.
envCompareBlocked :: TCEnv -> Bool

-- | When True types will be omitted from printed pi types if they can be
--   inferred
envPrintDomainFreePi :: TCEnv -> Bool

-- | Used by the scope checker to make sure that certain forms of
--   expressions are not used inside dot patterns: extended lambdas and
--   let-expressions.
envInsideDotPattern :: TCEnv -> Bool

-- | The rules for translating internal to abstract syntax are slightly
--   different when the internal term comes from an unquote.
envReifyUnquoted :: TCEnv -> Bool
initEnv :: TCEnv

-- | The <tt>Context</tt> is a stack of <a>ContextEntry</a>s.
type Context = [ContextEntry]
data ContextEntry
Ctx :: CtxId -> Dom (Name, Type) -> ContextEntry
ctxId :: ContextEntry -> CtxId
ctxEntry :: ContextEntry -> Dom (Name, Type)
newtype CtxId
CtxId :: Nat -> CtxId
type LetBindings = Map Name (Open (Term, Dom Type))
data AbstractMode

-- | Abstract things in the current module can be accessed.
AbstractMode :: AbstractMode

-- | No abstract things can be accessed.
ConcreteMode :: AbstractMode

-- | All abstract things can be accessed.
IgnoreAbstractMode :: AbstractMode
data ExpandHidden

-- | Add implicit arguments in the end until type is no longer hidden
--   <a>Pi</a>.
ExpandLast :: ExpandHidden

-- | Do not append implicit arguments.
DontExpandLast :: ExpandHidden
data ExpandInstances
ExpandInstanceArguments :: ExpandInstances
DontExpandInstanceArguments :: ExpandInstances
data Occ
OccCon :: QName -> QName -> OccPos -> Occ
occDatatype :: Occ -> QName
occConstructor :: Occ -> QName
occPosition :: Occ -> OccPos
OccClause :: QName -> Int -> OccPos -> Occ
occFunction :: Occ -> QName
occClause :: Occ -> Int
occPosition :: Occ -> OccPos
data OccPos
NonPositively :: OccPos
ArgumentTo :: Nat -> QName -> OccPos

-- | Information about a call.
data CallInfo
CallInfo :: QName -> Range -> Closure Term -> CallInfo

-- | Target function name pretty-printed.
callInfoTarget :: CallInfo -> QName

-- | Range of the target function.
callInfoRange :: CallInfo -> Range

-- | To be formatted representation of the call.
callInfoCall :: CallInfo -> Closure Term

-- | We only <a>show</a> the name of the callee.

-- | Information about a mutual block which did not pass the termination
--   checker.
data TerminationError
TerminationError :: [QName] -> [CallInfo] -> TerminationError

-- | The functions which failed to check. (May not include automatically
--   generated functions.)
termErrFunctions :: TerminationError -> [QName]

-- | The problematic call sites.
termErrCalls :: TerminationError -> [CallInfo]
data SplitError

-- | neither data type nor record
NotADatatype :: (Closure Type) -> SplitError

-- | data type, but in irrelevant position
IrrelevantDatatype :: (Closure Type) -> SplitError

-- | coinductive data type
CoinductiveDatatype :: (Closure Type) -> SplitError
CantSplit :: QName -> Telescope -> Args -> Args -> [Term] -> SplitError
GenericSplitError :: String -> SplitError
data UnquoteError
BadVisibility :: String -> (Arg Term) -> UnquoteError
ConInsteadOfDef :: QName -> String -> String -> UnquoteError
DefInsteadOfCon :: QName -> String -> String -> UnquoteError

-- | <pre>
--   NotAConstructor kind term
--   </pre>
NotAConstructor :: String -> Term -> UnquoteError
NotALiteral :: String -> Term -> UnquoteError
RhsUsesDottedVar :: [Int] -> Term -> UnquoteError
BlockedOnMeta :: MetaId -> UnquoteError
UnquotePanic :: String -> UnquoteError
data TypeError
InternalError :: String -> TypeError
NotImplemented :: String -> TypeError
NotSupported :: String -> TypeError
CompilationError :: String -> TypeError
TerminationCheckFailed :: [TerminationError] -> TypeError
PropMustBeSingleton :: TypeError
DataMustEndInSort :: Term -> TypeError

-- | The target of a constructor isn't an application of its datatype. The
--   <a>Type</a> records what it does target.
ShouldEndInApplicationOfTheDatatype :: Type -> TypeError

-- | The target of a constructor isn't its datatype applied to something
--   that isn't the parameters. First term is the correct target and the
--   second term is the actual target.
ShouldBeAppliedToTheDatatypeParameters :: Term -> Term -> TypeError

-- | Expected a type to be an application of a particular datatype.
ShouldBeApplicationOf :: Type -> QName -> TypeError

-- | constructor, datatype
ConstructorPatternInWrongDatatype :: QName -> QName -> TypeError

-- | Indices.
IndicesNotConstructorApplications :: [Arg Term] -> TypeError

-- | Variables, indices.
IndexVariablesNotDistinct :: [Nat] -> [Arg Term] -> TypeError

-- | Indices (variables), index expressions (with constructors applied to
--   reconstructed parameters), parameters.
IndicesFreeInParameters :: [Nat] -> [Arg Term] -> [Arg Term] -> TypeError

-- | Datatype, constructors.
CantResolveOverloadedConstructorsTargetingSameDatatype :: QName -> [QName] -> TypeError

-- | constructor, type
DoesNotConstructAnElementOf :: QName -> Type -> TypeError

-- | Varying number of arguments for a function.
DifferentArities :: TypeError

-- | The left hand side of a function definition has a hidden argument
--   where a non-hidden was expected.
WrongHidingInLHS :: TypeError

-- | Expected a non-hidden function and found a hidden lambda.
WrongHidingInLambda :: Type -> TypeError

-- | A function is applied to a hidden argument where a non-hidden was
--   expected.
WrongHidingInApplication :: Type -> TypeError

-- | A function is applied to a hidden named argument it does not have.
WrongNamedArgument :: (NamedArg Expr) -> TypeError

-- | Expected a relevant function and found an irrelevant lambda.
WrongIrrelevanceInLambda :: Type -> TypeError

-- | The given hiding does not correspond to the expected hiding.
HidingMismatch :: Hiding -> Hiding -> TypeError

-- | The given relevance does not correspond to the expected relevane.
RelevanceMismatch :: Relevance -> Relevance -> TypeError

-- | The given color does not correspond to the expected color.
ColorMismatch :: [Color] -> [Color] -> TypeError

-- | The term does not correspond to an inductive data type.
NotInductive :: Term -> TypeError
UninstantiatedDotPattern :: Expr -> TypeError
IlltypedPattern :: Pattern -> Type -> TypeError
IllformedProjectionPattern :: Pattern -> TypeError
CannotEliminateWithPattern :: (NamedArg Pattern) -> Type -> TypeError
TooManyArgumentsInLHS :: Type -> TypeError
WrongNumberOfConstructorArguments :: QName -> Nat -> Nat -> TypeError
ShouldBeEmpty :: Type -> [Pattern] -> TypeError

-- | The given type should have been a sort.
ShouldBeASort :: Type -> TypeError

-- | The given type should have been a pi.
ShouldBePi :: Type -> TypeError
ShouldBeRecordType :: Type -> TypeError
ShouldBeRecordPattern :: Pattern -> TypeError
NotAProjectionPattern :: (NamedArg Pattern) -> TypeError
NotAProperTerm :: TypeError
SetOmegaNotValidType :: TypeError

-- | This term is not a type expression.
InvalidType :: Term -> TypeError
SplitOnIrrelevant :: Pattern -> (Dom Type) -> TypeError
DefinitionIsIrrelevant :: QName -> TypeError
VariableIsIrrelevant :: Name -> TypeError
UnequalTerms :: Comparison -> Term -> Term -> Type -> TypeError
UnequalTypes :: Comparison -> Type -> Type -> TypeError

-- | The two function types have different relevance.
UnequalRelevance :: Comparison -> Term -> Term -> TypeError

-- | The two function types have different hiding.
UnequalHiding :: Term -> Term -> TypeError

-- | The two function types have different color.
UnequalColors :: Term -> Term -> TypeError
UnequalSorts :: Sort -> Sort -> TypeError
UnequalBecauseOfUniverseConflict :: Comparison -> Term -> Term -> TypeError

-- | We ended up with an equality constraint where the terms have different
--   types. This is not supported.
HeterogeneousEquality :: Term -> Type -> Term -> Type -> TypeError
NotLeqSort :: Sort -> Sort -> TypeError

-- | The arguments are the meta variable, the parameters it can depend on
--   and the paratemeter that it wants to depend on.
MetaCannotDependOn :: MetaId -> [Nat] -> Nat -> TypeError
MetaOccursInItself :: MetaId -> TypeError
GenericError :: String -> TypeError
GenericDocError :: Doc -> TypeError
BuiltinMustBeConstructor :: String -> Expr -> TypeError
NoSuchBuiltinName :: String -> TypeError
DuplicateBuiltinBinding :: String -> Term -> Term -> TypeError
NoBindingForBuiltin :: String -> TypeError
NoSuchPrimitiveFunction :: String -> TypeError
ShadowedModule :: Name -> [ModuleName] -> TypeError
BuiltinInParameterisedModule :: String -> TypeError
IllegalLetInTelescope :: TypedBinding -> TypeError
NoRHSRequiresAbsurdPattern :: [NamedArg Pattern] -> TypeError
AbsurdPatternRequiresNoRHS :: [NamedArg Pattern] -> TypeError
TooFewFields :: QName -> [Name] -> TypeError
TooManyFields :: QName -> [Name] -> TypeError
DuplicateFields :: [Name] -> TypeError
DuplicateConstructors :: [Name] -> TypeError
WithOnFreeVariable :: Expr -> TypeError
UnexpectedWithPatterns :: [Pattern] -> TypeError
WithClausePatternMismatch :: Pattern -> Pattern -> TypeError
FieldOutsideRecord :: TypeError
ModuleArityMismatch :: ModuleName -> Telescope -> [NamedArg Expr] -> TypeError
IncompletePatternMatching :: Term -> [Elim] -> TypeError
CoverageFailure :: QName -> [[Arg Pattern]] -> TypeError
UnreachableClauses :: QName -> [[Arg Pattern]] -> TypeError
CoverageCantSplitOn :: QName -> Telescope -> Args -> Args -> TypeError
CoverageCantSplitIrrelevantType :: Type -> TypeError
CoverageCantSplitType :: Type -> TypeError
WithoutKError :: Type -> Term -> Term -> TypeError
SplitError :: SplitError -> TypeError
NotStrictlyPositive :: QName -> [Occ] -> TypeError
LocalVsImportedModuleClash :: ModuleName -> TypeError
UnsolvedMetas :: [Range] -> TypeError
UnsolvedConstraints :: Constraints -> TypeError

-- | Some interaction points (holes) have not be filled by user. There are
--   not <a>UnsolvedMetas</a> since unification solved them. This is an
--   error, since interaction points are never filled without user
--   interaction.
SolvedButOpenHoles :: TypeError
CyclicModuleDependency :: [TopLevelModuleName] -> TypeError
FileNotFound :: TopLevelModuleName -> [AbsolutePath] -> TypeError
OverlappingProjects :: AbsolutePath -> TopLevelModuleName -> TopLevelModuleName -> TypeError
AmbiguousTopLevelModuleName :: TopLevelModuleName -> [AbsolutePath] -> TypeError
ModuleNameDoesntMatchFileName :: TopLevelModuleName -> [AbsolutePath] -> TypeError
ClashingFileNamesFor :: ModuleName -> [AbsolutePath] -> TypeError

-- | Module name, file from which it was loaded, file which the include
--   path says contains the module. Scope errors
ModuleDefinedInOtherFile :: TopLevelModuleName -> AbsolutePath -> AbsolutePath -> TypeError
BothWithAndRHS :: TypeError
NotInScope :: [QName] -> TypeError
NoSuchModule :: QName -> TypeError
AmbiguousName :: QName -> [QName] -> TypeError
AmbiguousModule :: QName -> [ModuleName] -> TypeError
UninstantiatedModule :: QName -> TypeError
ClashingDefinition :: QName -> QName -> TypeError
ClashingModule :: ModuleName -> ModuleName -> TypeError
ClashingImport :: Name -> QName -> TypeError
ClashingModuleImport :: Name -> ModuleName -> TypeError
PatternShadowsConstructor :: Name -> QName -> TypeError
ModuleDoesntExport :: QName -> [ImportedName] -> TypeError
DuplicateImports :: QName -> [ImportedName] -> TypeError
InvalidPattern :: Pattern -> TypeError
RepeatedVariablesInPattern :: [Name] -> TypeError

-- | The expr was used in the right hand side of an implicit module
--   definition, but it wasn't of the form <tt>m Delta</tt>.
NotAModuleExpr :: Expr -> TypeError
NotAnExpression :: Expr -> TypeError
NotAValidLetBinding :: NiceDeclaration -> TypeError
NothingAppliedToHiddenArg :: Expr -> TypeError
NothingAppliedToInstanceArg :: Expr -> TypeError
BadArgumentsToPatternSynonym :: QName -> TypeError
TooFewArgumentsToPatternSynonym :: QName -> TypeError
UnusedVariableInPatternSynonym :: TypeError
NoParseForApplication :: [Expr] -> TypeError
AmbiguousParseForApplication :: [Expr] -> [Expr] -> TypeError
NoParseForLHS :: LHSOrPatSyn -> Pattern -> TypeError
AmbiguousParseForLHS :: LHSOrPatSyn -> Pattern -> [Pattern] -> TypeError
IFSNoCandidateInScope :: Type -> TypeError
UnquoteFailed :: UnquoteError -> TypeError
SafeFlagPostulate :: Name -> TypeError
SafeFlagPragma :: [String] -> TypeError
SafeFlagNoTerminationCheck :: TypeError
SafeFlagNonTerminating :: TypeError
SafeFlagTerminating :: TypeError
SafeFlagPrimTrustMe :: TypeError
NeedOptionCopatterns :: TypeError

-- | Distinguish error message when parsing lhs or pattern synonym, resp.
data LHSOrPatSyn
IsLHS :: LHSOrPatSyn
IsPatSyn :: LHSOrPatSyn

-- | Type-checking errors.
data TCErr
TypeError :: TCState -> (Closure TypeError) -> TCErr
Exception :: Range -> String -> TCErr
IOException :: Range -> IOException -> TCErr
PatternErr :: TCErr

-- | Environment of the reduce monad.
data ReduceEnv
ReduceEnv :: TCEnv -> TCState -> ReduceEnv

-- | Read only access to environment.
redEnv :: ReduceEnv -> TCEnv

-- | Read only access to state (signature, metas...).
redSt :: ReduceEnv -> TCState
mapRedEnv :: (TCEnv -> TCEnv) -> ReduceEnv -> ReduceEnv
mapRedSt :: (TCState -> TCState) -> ReduceEnv -> ReduceEnv
mapRedEnvSt :: (TCEnv -> TCEnv) -> (TCState -> TCState) -> ReduceEnv -> ReduceEnv
newtype ReduceM a
ReduceM :: Reader ReduceEnv a -> ReduceM a
unReduceM :: ReduceM a -> Reader ReduceEnv a
runReduceM :: ReduceM a -> TCM a
runReduceF :: (a -> ReduceM b) -> TCM (a -> b)
newtype TCMT m a
TCM :: (IORef TCState -> TCEnv -> m a) -> TCMT m a
unTCM :: TCMT m a -> IORef TCState -> TCEnv -> m a
type TCM = TCMT IO
class (Applicative tcm, MonadIO tcm, MonadReader TCEnv tcm, MonadState TCState tcm) => MonadTCM tcm
liftTCM :: MonadTCM tcm => TCM a -> tcm a

-- | Preserve the state of the failing computation.
catchError_ :: TCM a -> (TCErr -> TCM a) -> TCM a
mapTCMT :: (forall a. m a -> n a) -> TCMT m a -> TCMT n a
pureTCM :: MonadIO m => (TCState -> TCEnv -> a) -> TCMT m a
returnTCMT :: MonadIO m => a -> TCMT m a
bindTCMT :: MonadIO m => TCMT m a -> (a -> TCMT m b) -> TCMT m b
thenTCMT :: MonadIO m => TCMT m a -> TCMT m b -> TCMT m b
fmapTCMT :: MonadIO m => (a -> b) -> TCMT m a -> TCMT m b
apTCMT :: MonadIO m => TCMT m (a -> b) -> TCMT m a -> TCMT m b
patternViolation :: TCM a
internalError :: MonadTCM tcm => String -> tcm a
typeError :: MonadTCM tcm => TypeError -> tcm a
typeError_ :: MonadTCM tcm => TypeError -> tcm TCErr

-- | Running the type checking monad (most general form).
runTCM :: MonadIO m => TCEnv -> TCState -> TCMT m a -> m (a, TCState)

-- | Running the type checking monad on toplevel (with initial state).
runTCMTop :: TCM a -> IO (Either TCErr a)
runTCMTop' :: MonadIO m => TCMT m a -> m a

-- | <a>runSafeTCM</a> runs a safe <a>TCM</a> action (a <a>TCM</a> action
--   which cannot fail) in the initial environment.
runSafeTCM :: TCM a -> TCState -> IO (a, TCState)

-- | Runs the given computation in a separate thread, with <i>a copy</i> of
--   the current state and environment.
--   
--   Note that Agda sometimes uses actual, mutable state. If the
--   computation given to <tt>forkTCM</tt> tries to <i>modify</i> this
--   state, then bad things can happen, because accesses are not mutually
--   exclusive. The <tt>forkTCM</tt> function has been added mainly to
--   allow the thread to <i>read</i> (a snapshot of) the current state in a
--   convenient way.
--   
--   Note also that exceptions which are raised in the thread are not
--   propagated to the parent, so the thread should not do anything
--   important.
forkTCM :: TCM a -> TCM ()

-- | Base name for extended lambda patterns
extendedLambdaName :: String

-- | Name of absurdLambda definitions.
absurdLambdaName :: String

-- | Check whether we have an definition from an absurd lambda.
isAbsurdLambdaName :: QName -> Bool
instance Typeable Comparison
instance Typeable CompareDirection
instance Typeable Judgement
instance Typeable Polarity
instance Typeable Occurrence
instance Typeable Simplification
instance Typeable MutualId
instance Typeable AbstractMode
instance Typeable TCEnv
instance Typeable Open
instance Typeable CtxId
instance Typeable ContextEntry
instance Typeable Call
instance Typeable ProblemConstraint
instance Typeable Constraint
instance Typeable ProblemId
instance Typeable Closure
instance Typeable Signature
instance Typeable Definition
instance Typeable Defn
instance Typeable FunctionInverse'
instance Typeable TermHead
instance Typeable Projection
instance Typeable CompiledRepresentation
instance Typeable HaskellExport
instance Typeable HaskellRepresentation
instance Typeable RewriteRule
instance Typeable DisplayForm
instance Typeable DisplayTerm
instance Typeable Section
instance Typeable Interface
instance Typeable Builtin
instance Typeable PrimFun
instance Typeable Reduced
instance Typeable MetaVariable
instance Typeable MetaInstantiation
instance Typeable TypeCheckingProblem
instance Typeable Listener
instance Typeable Fields
instance Typeable CallInfo
instance Typeable TerminationError
instance Typeable TypeError
instance Typeable TCErr
instance Eq Comparison
instance Eq CompareDirection
instance Functor (Judgement t)
instance Foldable (Judgement t)
instance Traversable (Judgement t)
instance Eq Frozen
instance Show Frozen
instance Eq MetaPriority
instance Ord MetaPriority
instance Show MetaPriority
instance Eq RunMetaOccursCheck
instance Ord RunMetaOccursCheck
instance Show RunMetaOccursCheck
instance Show Polarity
instance Eq Polarity
instance Show Occurrence
instance Eq Occurrence
instance Ord Occurrence
instance Eq Simplification
instance Show Simplification
instance Show AllowedReduction
instance Eq AllowedReduction
instance Ord AllowedReduction
instance Enum AllowedReduction
instance Bounded AllowedReduction
instance Eq MutualId
instance Ord MutualId
instance Show MutualId
instance Num MutualId
instance Enum MutualId
instance Eq HighlightingLevel
instance Ord HighlightingLevel
instance Show HighlightingLevel
instance Read HighlightingLevel
instance Eq HighlightingMethod
instance Show HighlightingMethod
instance Read HighlightingMethod
instance Show AbstractMode
instance Eq ExpandHidden
instance Eq ExpandInstances
instance Eq LHSOrPatSyn
instance Show LHSOrPatSyn
instance Show a => Show (Open a)
instance Functor Open
instance Eq CtxId
instance Ord CtxId
instance Show CtxId
instance Enum CtxId
instance Real CtxId
instance Integral CtxId
instance Num CtxId
instance Show ProblemConstraint
instance Show Constraint
instance Eq ProblemId
instance Ord ProblemId
instance Enum ProblemId
instance Real ProblemId
instance Integral ProblemId
instance Num ProblemId
instance Show Signature
instance Show Definition
instance Show Defn
instance Show c => Show (FunctionInverse' c)
instance Functor FunctionInverse'
instance Eq TermHead
instance Ord TermHead
instance Show TermHead
instance Show Projection
instance Show CompiledRepresentation
instance Show HaskellExport
instance Show HaskellRepresentation
instance Show RewriteRule
instance Show DisplayForm
instance Show DisplayTerm
instance Show Section
instance Show Interface
instance Show pf => Show (Builtin pf)
instance Functor Builtin
instance Foldable Builtin
instance Traversable Builtin
instance Functor ReduceM
instance Applicative ReduceM
instance Monad ReduceM
instance Functor MaybeReduced
instance Functor (Reduced no)
instance Show UnquoteError
instance Show OccPos
instance Show Occ
instance Show SplitError
instance Show TerminationError
instance Show TypeError
instance MonadIO m => MonadIO (TCMT m)
instance MonadIO m => Applicative (TCMT m)
instance MonadIO m => Functor (TCMT m)
instance MonadIO m => Monad (TCMT m)
instance MonadTrans TCMT
instance (Monoid w, MonadTCM tcm) => MonadTCM (WriterT w tcm)
instance (Error err, MonadTCM tcm) => MonadTCM (ExceptT err tcm)
instance MonadTCM tcm => MonadTCM (MaybeT tcm)
instance MonadIO m => MonadTCM (TCMT m)
instance MonadError TCErr (TCMT IO)
instance MonadIO m => MonadState TCState (TCMT m)
instance MonadIO m => MonadReader TCEnv (TCMT m)
instance MonadReader TCEnv ReduceM
instance Exception TCErr
instance HasRange TCErr
instance Show TCErr
instance Error TCErr
instance Error TypeError
instance Error UnquoteError
instance Error SplitError
instance Pretty CallInfo
instance Show CallInfo
instance HasRange Call
instance IsProjElim e => IsProjElim (MaybeReduced e)
instance Monoid Simplification
instance NFData Occurrence
instance Eq InteractionPoint
instance SetRange MetaVariable
instance SetRange MetaInfo
instance HasRange MetaVariable
instance HasRange MetaInfo
instance Show NamedMeta
instance Show MetaInstantiation
instance Ord Listener
instance Eq Listener
instance (Show t, Show a) => Show (Judgement t a)
instance Show CompareDirection
instance Show Comparison
instance HasRange Constraint
instance HasRange ProblemConstraint
instance HasRange a => HasRange (Closure a)
instance Show a => Show (Closure a)
instance FreshName ()
instance FreshName Range
instance FreshName String
instance FreshName (Range, String)
instance HasFresh ProblemId
instance Show ProblemId
instance HasFresh Int
instance HasFresh CtxId
instance HasFresh NameId
instance HasFresh InteractionId
instance HasFresh MutualId
instance HasFresh MetaId

module Agda.TypeChecking.Substitute

-- | Apply something to a bunch of arguments. Preserves blocking tags
--   (application can never resolve blocking).
class Apply t where apply t args = applyE t $ map Apply args applyE t es = apply t $ map argFromElim es
apply :: Apply t => t -> Args -> t
applyE :: Apply t => t -> Elims -> t

-- | If $v$ is a record value, <tt>canProject f v</tt> returns its field
--   <tt>f</tt>.
canProject :: QName -> Term -> Maybe (Arg Term)

-- | Eliminate a constructed term.
conApp :: ConHead -> Args -> Elims -> Term

-- | <tt>defApp f us vs</tt> applies <tt>Def f us</tt> to further arguments
--   <tt>vs</tt>, eliminating top projection redexes. If <tt>us</tt> is not
--   empty, we cannot have a projection redex, since the record argument is
--   the first one.
defApp :: QName -> Elims -> Elims -> Term
argToDontCare :: Arg c Term -> Term

-- | The type must contain the right number of pis without have to perform
--   any reduction.
piApply :: Type -> Args -> Type

-- | <tt>(abstract args v) <a>apply</a> args --&gt; v[args]</tt>.
class Abstract t
abstract :: Abstract t => Telescope -> t -> t

-- | <tt>tel ⊢ (Γ ⊢ lhs ↦ rhs : t)</tt> becomes <tt>tel, Γ ⊢ lhs ↦ rhs :
--   t)</tt> we do not need to change lhs, rhs, and t since they live in Γ.
--   See 'Abstract Clause'.
telVars :: Telescope -> [Arg Pattern]
namedTelVars :: Telescope -> [NamedArg Pattern]
abstractArgs :: Abstract a => Args -> a -> a
idS :: Substitution
wkS :: Int -> Substitution -> Substitution
raiseS :: Int -> Substitution
consS :: Term -> Substitution -> Substitution
singletonS :: Term -> Substitution
liftS :: Int -> Substitution -> Substitution
dropS :: Int -> Substitution -> Substitution

-- | <pre>
--   applySubst (ρ <a>composeS</a> σ) v == applySubst ρ (applySubst σ v)
--   </pre>
composeS :: Substitution -> Substitution -> Substitution
splitS :: Int -> Substitution -> (Substitution, Substitution)
(++#) :: [Term] -> Substitution -> Substitution
prependS :: Empty -> [Maybe Term] -> Substitution -> Substitution
parallelS :: [Term] -> Substitution
compactS :: Empty -> [Maybe Term] -> Substitution
lookupS :: Substitution -> Nat -> Term

-- | Apply a substitution.
class Subst t
applySubst :: Subst t => Substitution -> t -> t
raise :: Subst t => Nat -> t -> t
raiseFrom :: Subst t => Nat -> Nat -> t -> t
subst :: Subst t => Term -> t -> t
strengthen :: Subst t => Empty -> t -> t
substUnder :: Subst t => Nat -> Term -> t -> t
type TelView = TelV Type
data TelV a
TelV :: Tele (Dom a) -> a -> TelV a
theTel :: TelV a -> Tele (Dom a)
theCore :: TelV a -> a
type ListTel' a = [Dom (a, Type)]
type ListTel = ListTel' ArgName
telFromList' :: (a -> ArgName) -> ListTel' a -> Telescope
telFromList :: ListTel -> Telescope
telToList :: Telescope -> ListTel
telToArgs :: Telescope -> [Arg ArgName]

-- | Turn a typed binding <tt>(x1 .. xn : A)</tt> into a telescope.
bindsToTel' :: (Name -> a) -> [Name] -> Dom Type -> ListTel' a
bindsToTel :: [Name] -> Dom Type -> ListTel
telView' :: Type -> TelView

-- | <pre>
--   mkPi dom t = telePi (telFromList [dom]) t
--   </pre>
mkPi :: Dom (ArgName, Type) -> Type -> Type
mkLam :: Arg ArgName -> Term -> Term
telePi' :: (Abs Type -> Abs Type) -> Telescope -> Type -> Type

-- | Uses free variable analysis to introduce <tt>noAbs</tt> bindings.
telePi :: Telescope -> Type -> Type

-- | Everything will be a <a>Abs</a>.
telePi_ :: Telescope -> Type -> Type
teleLam :: Telescope -> Term -> Term

-- | Performs void (<tt>noAbs</tt>) abstraction over telescope.
class TeleNoAbs a
teleNoAbs :: TeleNoAbs a => a -> Term -> Term

-- | Dependent least upper bound, to assign a level to expressions like
--   <tt>forall i -&gt; Set i</tt>.
--   
--   <tt>dLub s1 i.s2 = omega</tt> if <tt>i</tt> appears in the rigid
--   variables of <tt>s2</tt>.
dLub :: Sort -> Abs Sort -> Sort

-- | Instantiate an abstraction. Strict in the term.
absApp :: Subst t => Abs t -> Term -> t

-- | Instantiate an abstraction. Lazy in the term, which allow it to be
--   <b>IMPOSSIBLE</b> in the case where the variable shouldn't be used but
--   we cannot use <a>noabsApp</a>. Used in Apply.
lazyAbsApp :: Subst t => Abs t -> Term -> t

-- | Instantiate an abstraction that doesn't use its argument.
noabsApp :: Subst t => Empty -> Abs t -> t
absBody :: Subst t => Abs t -> t
mkAbs :: (Subst a, Free a) => ArgName -> a -> Abs a
reAbs :: (Subst a, Free a) => Abs a -> Abs a

-- | <tt>underAbs k a b</tt> applies <tt>k</tt> to <tt>a</tt> and the
--   content of abstraction <tt>b</tt> and puts the abstraction back.
--   <tt>a</tt> is raised if abstraction was proper such that at point of
--   application of <tt>k</tt> and the content of <tt>b</tt> are at the
--   same context. Precondition: <tt>a</tt> and <tt>b</tt> are at the same
--   context at call time.
underAbs :: Subst a => (a -> b -> b) -> a -> Abs b -> Abs b

-- | <tt>underLambdas n k a b</tt> drops <tt>n</tt> initial <a>Lam</a>s
--   from <tt>b</tt>, performs operation <tt>k</tt> on <tt>a</tt> and the
--   body of <tt>b</tt>, and puts the <a>Lam</a>s back. <tt>a</tt> is
--   raised correctly according to the number of abstractions.
underLambdas :: Subst a => Int -> (a -> Term -> Term) -> a -> Term -> Term

-- | Methods to retrieve the <a>clauseBody</a>.
class GetBody a
getBody :: GetBody a => a -> Maybe Term
getBodyUnraised :: GetBody a => a -> Maybe Term

-- | Syntactic equality, ignores stuff below <tt>DontCare</tt>.
sLub :: Sort -> Sort -> Sort
lvlView :: Term -> Level
levelMax :: [PlusLevel] -> Level
sortTm :: Sort -> Term
levelSort :: Level -> Sort
levelTm :: Level -> Term
unLevelAtom :: LevelAtom -> Term

-- | Substitutions.
data Substitution
IdS :: Substitution
EmptyS :: Substitution
Wk :: !Int -> Substitution -> Substitution
(:#) :: Term -> Substitution -> Substitution
Strengthen :: Empty -> Substitution -> Substitution
Lift :: !Int -> Substitution -> Substitution
instance [overlap ok] Typeable TelV
instance [overlap ok] Eq Constraint
instance [overlap ok] Ord (Elim' Term)
instance [overlap ok] Eq (Elim' Term)
instance [overlap ok] Ord LevelAtom
instance [overlap ok] Eq PlusLevel
instance [overlap ok] Ord Level
instance [overlap ok] Eq Level
instance [overlap ok] Ord (Type' Term)
instance [overlap ok] Eq (Type' Term)
instance [overlap ok] Ord Sort
instance [overlap ok] Eq Sort
instance [overlap ok] Ord Substitution
instance [overlap ok] Eq Substitution
instance [overlap ok] (Subst a, Ord a) => Ord (Tele a)
instance [overlap ok] (Subst a, Eq a) => Eq (Tele a)
instance [overlap ok] Show a => Show (TelV a)
instance [overlap ok] (Eq a, Subst a) => Eq (TelV a)
instance [overlap ok] (Ord a, Subst a) => Ord (TelV a)
instance [overlap ok] Functor TelV
instance [overlap ok] KillRange Substitution
instance [overlap ok] Sized Substitution
instance [overlap ok] (Subst a, Ord a) => Ord (Abs a)
instance [overlap ok] (Subst a, Eq a) => Eq (Abs a)
instance [overlap ok] Ord Term
instance [overlap ok] Eq Term
instance [overlap ok] Eq LevelAtom
instance [overlap ok] Ord PlusLevel
instance [overlap ok] GetBody Clause
instance [overlap ok] GetBody ClauseBody
instance [overlap ok] TeleNoAbs Telescope
instance [overlap ok] TeleNoAbs ListTel
instance [overlap ok] Subst Clause
instance [overlap ok] Subst ClauseBody
instance [overlap ok] (Subst a, Subst b, Subst c, Subst d) => Subst (a, b, c, d)
instance [overlap ok] (Subst a, Subst b, Subst c) => Subst (a, b, c)
instance [overlap ok] (Subst a, Subst b) => Subst (a, b)
instance [overlap ok] Subst ()
instance [overlap ok] Subst a => Subst [a]
instance [overlap ok] Subst a => Subst (Maybe a)
instance [overlap ok] Subst a => Subst (Dom a)
instance [overlap ok] Subst a => Subst (Named name a)
instance [overlap ok] Subst a => Subst (Arg a)
instance [overlap ok] Subst a => Subst (Abs a)
instance [overlap ok] Subst Elim
instance [overlap ok] Subst Constraint
instance [overlap ok] Subst a => Subst (Tele a)
instance [overlap ok] Subst DisplayTerm
instance [overlap ok] Subst DisplayForm
instance [overlap ok] Subst t => Subst (Blocked t)
instance [overlap ok] Subst Pattern
instance [overlap ok] Subst Name
instance [overlap ok] Subst Bool
instance [overlap ok] Subst LevelAtom
instance [overlap ok] Subst PlusLevel
instance [overlap ok] Subst Level
instance [overlap ok] Subst Sort
instance [overlap ok] Subst Type
instance [overlap ok] Subst a => Subst (Ptr a)
instance [overlap ok] Subst Term
instance [overlap ok] Subst Substitution
instance [overlap ok] Abstract v => Abstract (Map k v)
instance [overlap ok] Abstract t => Abstract (Maybe t)
instance [overlap ok] Abstract t => Abstract [t]
instance [overlap ok] Abstract ClauseBody
instance [overlap ok] Abstract FunctionInverse
instance [overlap ok] Abstract a => Abstract (Case a)
instance [overlap ok] Abstract a => Abstract (WithArity a)
instance [overlap ok] Abstract CompiledClauses
instance [overlap ok] Abstract Clause
instance [overlap ok] Abstract PrimFun
instance [overlap ok] Abstract Defn
instance [overlap ok] Abstract Projection
instance [overlap ok] Abstract [Polarity]
instance [overlap ok] Abstract [Occurrence]
instance [overlap ok] Abstract RewriteRule
instance [overlap ok] Abstract Definition
instance [overlap ok] Abstract Telescope
instance [overlap ok] Abstract Sort
instance [overlap ok] Abstract Type
instance [overlap ok] Abstract Term
instance [overlap ok] Abstract Permutation
instance [overlap ok] Apply Permutation
instance [overlap ok] DoDrop a => Abstract (Drop a)
instance [overlap ok] DoDrop a => Apply (Drop a)
instance [overlap ok] (Apply a, Apply b, Apply c) => Apply (a, b, c)
instance [overlap ok] (Apply a, Apply b) => Apply (a, b)
instance [overlap ok] Apply v => Apply (Map k v)
instance [overlap ok] Apply t => Apply (Maybe t)
instance [overlap ok] Apply t => Apply (Blocked t)
instance [overlap ok] Apply t => Apply [t]
instance [overlap ok] Apply DisplayTerm
instance [overlap ok] Apply ClauseBody
instance [overlap ok] Apply FunctionInverse
instance [overlap ok] Apply a => Apply (Case a)
instance [overlap ok] Apply a => Apply (WithArity a)
instance [overlap ok] Apply CompiledClauses
instance [overlap ok] Apply Clause
instance [overlap ok] Apply PrimFun
instance [overlap ok] Apply Defn
instance [overlap ok] Apply Projection
instance [overlap ok] Apply [Polarity]
instance [overlap ok] Apply [Occurrence]
instance [overlap ok] Apply RewriteRule
instance [overlap ok] Apply Definition
instance [overlap ok] Subst a => Apply (Tele a)
instance [overlap ok] Apply a => Apply (Ptr a)
instance [overlap ok] Apply Sort
instance [overlap ok] Apply Type
instance [overlap ok] Apply Term


-- | Functions for abstracting terms over other terms.
module Agda.TypeChecking.Abstract
piAbstractTerm :: Term -> Type -> Type -> Type

-- | <tt>isPrefixOf u v = Just es</tt> if <tt>v == u <a>applyE</a> es</tt>.
class IsPrefixOf a
isPrefixOf :: IsPrefixOf a => a -> a -> Maybe Elims
class AbstractTerm a
abstractTerm :: AbstractTerm a => Term -> a -> a
instance (AbstractTerm a, AbstractTerm b) => AbstractTerm (a, b)
instance (Subst a, AbstractTerm a) => AbstractTerm (Abs a)
instance AbstractTerm a => AbstractTerm (Maybe a)
instance AbstractTerm a => AbstractTerm [a]
instance AbstractTerm a => AbstractTerm (Dom a)
instance AbstractTerm a => AbstractTerm (Arg a)
instance AbstractTerm a => AbstractTerm (Elim' a)
instance AbstractTerm LevelAtom
instance AbstractTerm PlusLevel
instance AbstractTerm Level
instance AbstractTerm Sort
instance AbstractTerm Type
instance AbstractTerm a => AbstractTerm (Ptr a)
instance AbstractTerm Term
instance IsPrefixOf Term
instance IsPrefixOf Args
instance IsPrefixOf Elims

module Agda.TypeChecking.Test.Generators
data TermConfiguration
TermConf :: [QName] -> [QName] -> [QName] -> [Nat] -> UseLiterals -> Frequencies -> Maybe Int -> Bool -> TermConfiguration
tcDefinedNames :: TermConfiguration -> [QName]
tcConstructorNames :: TermConfiguration -> [QName]
tcProjectionNames :: TermConfiguration -> [QName]
tcFreeVariables :: TermConfiguration -> [Nat]
tcLiterals :: TermConfiguration -> UseLiterals
tcFrequencies :: TermConfiguration -> Frequencies

-- | Maximum size of the generated element. When <tt>Nothing</tt> this
--   value is initialized from the <a>size</a> parameter.
tcFixSize :: TermConfiguration -> Maybe Int

-- | When this is true no lambdas, literals, or constructors are generated
tcIsType :: TermConfiguration -> Bool
data Frequencies
Freqs :: HiddenFreqs -> ElimFreqs -> SortFreqs -> TermFreqs -> Frequencies
hiddenFreqs :: Frequencies -> HiddenFreqs
elimFreqs :: Frequencies -> ElimFreqs
sortFreqs :: Frequencies -> SortFreqs
termFreqs :: Frequencies -> TermFreqs
data TermFreqs
TermFreqs :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> TermFreqs
varFreq :: TermFreqs -> Int
defFreq :: TermFreqs -> Int
conFreq :: TermFreqs -> Int
litFreq :: TermFreqs -> Int
sortFreq :: TermFreqs -> Int
lamFreq :: TermFreqs -> Int
piFreq :: TermFreqs -> Int
funFreq :: TermFreqs -> Int
data ElimFreqs
ElimFreqs :: Int -> Int -> ElimFreqs
applyFreq :: ElimFreqs -> Int
projFreq :: ElimFreqs -> Int
data HiddenFreqs
HiddenFreqs :: Int -> Int -> HiddenFreqs
hiddenFreq :: HiddenFreqs -> Int
notHiddenFreq :: HiddenFreqs -> Int
data SortFreqs
SortFreqs :: [Int] -> Int -> SortFreqs
setFreqs :: SortFreqs -> [Int]
propFreq :: SortFreqs -> Int
defaultFrequencies :: Frequencies
noProp :: TermConfiguration -> TermConfiguration
data UseLiterals
UseLit :: Bool -> Bool -> Bool -> Bool -> UseLiterals
useLitInt :: UseLiterals -> Bool
useLitFloat :: UseLiterals -> Bool
useLitString :: UseLiterals -> Bool
useLitChar :: UseLiterals -> Bool
noLiterals :: UseLiterals
fixSizeConf :: Int -> TermConfiguration -> TermConfiguration
resizeConf :: (Int -> Int) -> TermConfiguration -> TermConfiguration
decrConf :: TermConfiguration -> TermConfiguration
divConf :: TermConfiguration -> Int -> TermConfiguration
isTypeConf :: TermConfiguration -> TermConfiguration
isntTypeConf :: TermConfiguration -> TermConfiguration
extendConf :: TermConfiguration -> TermConfiguration
extendWithTelConf :: Telescope -> TermConfiguration -> TermConfiguration
makeConfiguration :: [RawName] -> [RawName] -> [RawName] -> [Nat] -> TermConfiguration
class GenC a
genC :: GenC a => TermConfiguration -> Gen a
newtype YesType a
YesType :: a -> YesType a
unYesType :: YesType a -> a
newtype NoType a
NoType :: a -> NoType a
unNoType :: NoType a -> a
newtype VarName
VarName :: Nat -> VarName
unVarName :: VarName -> Nat
newtype DefName
DefName :: QName -> DefName
unDefName :: DefName -> QName
newtype ConName
ConName :: ConHead -> ConName
unConName :: ConName -> ConHead
newtype ProjName
ProjName :: QName -> ProjName
unProjName :: ProjName -> QName
newtype SizedList a
SizedList :: [a] -> SizedList a
unSizedList :: SizedList a -> [a]
fixSize :: TermConfiguration -> Gen a -> Gen a
genArgs :: TermConfiguration -> Gen Args
genElims :: TermConfiguration -> Gen Elims

-- | Only generates default configurations. Names and free variables
--   varies.
genConf :: Gen TermConfiguration
class ShrinkC a b | a -> b
shrinkC :: ShrinkC a b => TermConfiguration -> a -> [b]
noShrink :: ShrinkC a b => a -> b
killAbs :: KillVar a => Abs a -> a
class KillVar a
killVar :: KillVar a => Nat -> a -> a
isWellScoped :: Free a => TermConfiguration -> a -> Bool

-- | Check that the generated terms don't have any out of scope variables.
prop_wellScopedVars :: TermConfiguration -> Property
instance Show TermFreqs
instance Show ElimFreqs
instance Show HiddenFreqs
instance Show SortFreqs
instance Show Frequencies
instance Show UseLiterals
instance Show TermConfiguration
instance (KillVar a, KillVar b) => KillVar (a, b)
instance KillVar a => KillVar (Maybe a)
instance KillVar a => KillVar [a]
instance KillVar a => KillVar (Abs a)
instance KillVar a => KillVar (Dom a)
instance KillVar a => KillVar (Arg a)
instance KillVar a => KillVar (Elim' a)
instance KillVar Telescope
instance KillVar Type
instance KillVar Term
instance ShrinkC Term Term
instance ShrinkC Type Type
instance ShrinkC Telescope Telescope
instance ShrinkC Sort Sort
instance ShrinkC a b => ShrinkC (Elim' a) (Elim' b)
instance ShrinkC a b => ShrinkC (Blocked a) (Blocked b)
instance ShrinkC a b => ShrinkC (Dom a) (Dom b)
instance ShrinkC a b => ShrinkC (Arg a) (Arg b)
instance ShrinkC a b => ShrinkC (Abs a) (Abs b)
instance ShrinkC Hiding Hiding
instance ShrinkC Char Char
instance ShrinkC Literal Literal
instance ShrinkC ConName ConHead
instance ShrinkC DefName QName
instance ShrinkC VarName Nat
instance (ShrinkC a a', ShrinkC b b') => ShrinkC (a, b) (a', b')
instance ShrinkC a b => ShrinkC [a] [b]
instance ShrinkC a b => ShrinkC (NoType a) b
instance ShrinkC a b => ShrinkC (YesType a) b
instance Arbitrary TermConfiguration
instance GenC Term
instance GenC Type
instance GenC Telescope
instance GenC Literal
instance GenC Integer
instance GenC Double
instance GenC Char
instance GenC Sort
instance GenC ProjName
instance GenC DefName
instance GenC a => GenC (Elim' a)
instance GenC a => GenC (Abs a)
instance (GenC c, GenC a) => GenC (Dom c a)
instance (GenC c, GenC a) => GenC (Arg c a)
instance GenC Hiding
instance GenC Range
instance (GenC a, GenC b) => GenC (a, b)
instance GenC a => GenC [a]
instance GenC a => GenC (SizedList a)


-- | Data type for all interactive responses
module Agda.Interaction.Response

-- | Responses for any interactive interface
--   
--   Note that the response is given in pieces and incrementally, so the
--   user can have timely response even during long computations.
data Response
Resp_HighlightingInfo :: HighlightingInfo -> ModuleToSource -> Response
Resp_Status :: Status -> Response
Resp_JumpToError :: FilePath -> Int32 -> Response
Resp_InteractionPoints :: [InteractionId] -> Response
Resp_GiveAction :: InteractionId -> GiveResult -> Response
Resp_MakeCase :: MakeCaseVariant -> [String] -> Response
Resp_SolveAll :: [(InteractionId, Expr)] -> Response
Resp_DisplayInfo :: DisplayInfo -> Response

-- | The integer is the message's debug level.
Resp_RunningInfo :: Int -> String -> Response
Resp_ClearRunningInfo :: Response
Resp_ClearHighlighting :: Response

-- | There are two kinds of "make case" commands.
data MakeCaseVariant
Function :: MakeCaseVariant
ExtendedLambda :: MakeCaseVariant

-- | Info to display at the end of an interactive command
data DisplayInfo
Info_CompilationOk :: DisplayInfo
Info_Constraints :: String -> DisplayInfo
Info_AllGoals :: String -> DisplayInfo

-- | When an error message is displayed this constructor should be used, if
--   appropriate.
Info_Error :: String -> DisplayInfo

-- | <a>Info_Intro</a> denotes two different types of errors TODO: split
--   these into separate constructors
Info_Intro :: Doc -> DisplayInfo

-- | <a>Info_Auto</a> denotes either an error or a success (when
--   <a>Resp_GiveAction</a> is present) TODO: split these into separate
--   constructors
Info_Auto :: String -> DisplayInfo
Info_ModuleContents :: Doc -> DisplayInfo
Info_WhyInScope :: Doc -> DisplayInfo
Info_NormalForm :: Doc -> DisplayInfo
Info_GoalType :: Doc -> DisplayInfo
Info_CurrentGoal :: Doc -> DisplayInfo
Info_InferredType :: Doc -> DisplayInfo
Info_Context :: Doc -> DisplayInfo
Info_HelperFunction :: Doc -> DisplayInfo
Info_Version :: DisplayInfo

-- | Status information.
data Status
Status :: Bool -> Bool -> Status

-- | Are implicit arguments displayed?
sShowImplicitArguments :: Status -> Bool

-- | Has the module been successfully type checked?
sChecked :: Status -> Bool

-- | Give action result
--   
--   Comment derived from agda2-mode.el
--   
--   If <a>GiveResult</a> is 'Give_String s', then the goal is replaced by
--   <tt>s</tt>, and otherwise the text inside the goal is retained
--   (parenthesised if <a>GiveResult</a> is <a>Give_Paren</a>).
data GiveResult
Give_String :: String -> GiveResult
Give_Paren :: GiveResult
Give_NoParen :: GiveResult

-- | Callback fuction to call when there is a response to give to the
--   interactive frontend.
--   
--   Note that the response is given in pieces and incrementally, so the
--   user can have timely response even during long computations.
--   
--   Typical <a>InteractionOutputCallback</a> functions:
--   
--   <ul>
--   <li>Convert the response into a <a>String</a> representation and print
--   it on standard output (suitable for inter-process
--   communication).<ul><li>Put the response into a mutable variable stored
--   in the closure of the <a>InteractionOutputCallback</a> function.
--   (suitable for intra-process communication).</li></ul></li>
--   </ul>
type InteractionOutputCallback = Response -> TCM ()

-- | The default <a>InteractionOutputCallback</a> function prints certain
--   things to stdout (other things generate internal errors).
defaultInteractionOutputCallback :: InteractionOutputCallback
instance Show DisplayInfo

module Agda.TypeChecking.Monad.Builtin
class (Functor m, Applicative m, Monad m) => HasBuiltins m
getBuiltinThing :: HasBuiltins m => String -> m (Maybe (Builtin PrimFun))
litType :: Literal -> TCM Type
setBuiltinThings :: BuiltinThings PrimFun -> TCM ()
bindBuiltinName :: String -> Term -> TCM ()
bindPrimitive :: String -> PrimFun -> TCM ()
getBuiltin :: String -> TCM Term
getBuiltin' :: HasBuiltins m => String -> m (Maybe Term)
getPrimitive' :: HasBuiltins m => String -> m (Maybe PrimFun)
getPrimitive :: String -> TCM PrimFun

-- | Rewrite a literal to constructor form if possible.
constructorForm :: Term -> TCM Term
constructorForm' :: Applicative m => m Term -> m Term -> Term -> m Term
primInteger :: TCM Term
primAgdaPatAbsurd :: TCM Term
primAgdaPatProj :: TCM Term
primAgdaPatLit :: TCM Term
primAgdaRecordDef :: TCM Term
primAgdaDataDef :: TCM Term
primAgdaPatDot :: TCM Term
primAgdaPatVar :: TCM Term
primAgdaPatCon :: TCM Term
primAgdaPattern :: TCM Term
primAgdaClauseAbsurd :: TCM Term
primAgdaClauseClause :: TCM Term
primAgdaClause :: TCM Term
primAgdaFunDefCon :: TCM Term
primAgdaFunDef :: TCM Term
primAgdaDefinitionDataConstructor :: TCM Term
primAgdaDefinitionPrimitive :: TCM Term
primAgdaDefinitionPostulate :: TCM Term
primAgdaDefinitionRecordDef :: TCM Term
primAgdaDefinitionDataDef :: TCM Term
primAgdaDefinitionFunDef :: TCM Term
primAgdaDefinition :: TCM Term
primAgdaSortUnsupported :: TCM Term
primAgdaSortLit :: TCM Term
primAgdaSortSet :: TCM Term
primAgdaSort :: TCM Term
primAgdaLitQName :: TCM Term
primAgdaLitChar :: TCM Term
primAgdaLitString :: TCM Term
primAgdaLitFloat :: TCM Term
primAgdaLitNat :: TCM Term
primAgdaLiteral :: TCM Term
primIrrelevant :: TCM Term
primRelevant :: TCM Term
primRelevance :: TCM Term
primVisible :: TCM Term
primInstance :: TCM Term
primHidden :: TCM Term
primHiding :: TCM Term
primAgdaTypeEl :: TCM Term
primAgdaType :: TCM Term
primAgdaTermUnsupported :: TCM Term
primAgdaTermLit :: TCM Term
primAgdaTermSort :: TCM Term
primAgdaTermPi :: TCM Term
primAgdaTermCon :: TCM Term
primAgdaTermDef :: TCM Term
primAgdaTermExtLam :: TCM Term
primAgdaTermLam :: TCM Term
primAgdaTermVar :: TCM Term
primAgdaTerm :: TCM Term
primArgArg :: TCM Term
primArg :: TCM Term
primArgArgInfo :: TCM Term
primArgInfo :: TCM Term
primQName :: TCM Term
primSizeMax :: TCM Term
primIrrAxiom :: TCM Term
primLevelMax :: TCM Term
primLevelSuc :: TCM Term
primLevelZero :: TCM Term
primLevel :: TCM Term
primRewrite :: TCM Term
primRefl :: TCM Term
primEquality :: TCM Term
primFlat :: TCM Term
primSharp :: TCM Term
primInf :: TCM Term
primSizeInf :: TCM Term
primSizeSuc :: TCM Term
primSizeLt :: TCM Term
primSize :: TCM Term
primNatLess :: TCM Term
primNatEquality :: TCM Term
primNatModSucAux :: TCM Term
primNatDivSucAux :: TCM Term
primNatTimes :: TCM Term
primNatMinus :: TCM Term
primNatPlus :: TCM Term
primZero :: TCM Term
primSuc :: TCM Term
primNat :: TCM Term
primIO :: TCM Term
primCons :: TCM Term
primNil :: TCM Term
primList :: TCM Term
primFalse :: TCM Term
primTrue :: TCM Term
primBool :: TCM Term
primString :: TCM Term
primChar :: TCM Term
primFloat :: TCM Term
builtinNat :: String
builtinAgdaDefinition :: String
builtinAgdaDefinitionPrimitive :: String
builtinAgdaDefinitionPostulate :: String
builtinAgdaDefinitionDataConstructor :: String
builtinAgdaDefinitionRecordDef :: String
builtinAgdaDefinitionDataDef :: String
builtinAgdaDefinitionFunDef :: String
builtinAgdaRecordDef :: String
builtinAgdaDataDef :: String
builtinAgdaPatAbsurd :: String
builtinAgdaPatProj :: String
builtinAgdaPatLit :: String
builtinAgdaPatDot :: String
builtinAgdaPatCon :: String
builtinAgdaPatVar :: String
builtinAgdaPattern :: String
builtinAgdaClauseAbsurd :: String
builtinAgdaClauseClause :: String
builtinAgdaClause :: String
builtinAgdaFunDefCon :: String
builtinAgdaFunDef :: String
builtinAgdaLitQName :: String
builtinAgdaLitString :: String
builtinAgdaLitChar :: String
builtinAgdaLitFloat :: String
builtinAgdaLitNat :: String
builtinAgdaLiteral :: String
builtinAgdaTermUnsupported :: String
builtinAgdaTermLit :: String
builtinAgdaTermSort :: String
builtinAgdaTermPi :: String
builtinAgdaTermCon :: String
builtinAgdaTermDef :: String
builtinAgdaTermExtLam :: String
builtinAgdaTermLam :: String
builtinAgdaTermVar :: String
builtinAgdaTerm :: String
builtinArgArg :: String
builtinArgArgInfo :: String
builtinArgInfo :: String
builtinArg :: String
builtinIrrelevant :: String
builtinRelevant :: String
builtinRelevance :: String
builtinVisible :: String
builtinInstance :: String
builtinHidden :: String
builtinHiding :: String
builtinAgdaTypeEl :: String
builtinAgdaType :: String
builtinAgdaSortUnsupported :: String
builtinAgdaSortLit :: String
builtinAgdaSortSet :: String
builtinAgdaSort :: String
builtinQName :: String
builtinIrrAxiom :: String
builtinLevelSuc :: String
builtinLevelZero :: String
builtinLevel :: String
builtinLevelMax :: String
builtinRewrite :: String
builtinRefl :: String
builtinEquality :: String
builtinFlat :: String
builtinSharp :: String
builtinInf :: String
builtinSizeMax :: String
builtinSizeInf :: String
builtinSizeSuc :: String
builtinSizeLt :: String
builtinSize :: String
builtinIO :: String
builtinCons :: String
builtinNil :: String
builtinList :: String
builtinFalse :: String
builtinTrue :: String
builtinBool :: String
builtinString :: String
builtinChar :: String
builtinFloat :: String
builtinInteger :: String
builtinNatLess :: String
builtinNatEquals :: String
builtinNatModSucAux :: String
builtinNatDivSucAux :: String
builtinNatTimes :: String
builtinNatMinus :: String
builtinNatPlus :: String
builtinZero :: String
builtinSuc :: String

-- | The coinductive primitives.
data CoinductionKit
CoinductionKit :: QName -> QName -> QName -> CoinductionKit
nameOfInf :: CoinductionKit -> QName
nameOfSharp :: CoinductionKit -> QName
nameOfFlat :: CoinductionKit -> QName

-- | Tries to build a <a>CoinductionKit</a>.
coinductionKit :: TCM (Maybe CoinductionKit)

-- | Get the name of the equality type.
primEqualityName :: TCM QName
instance MonadIO m => HasBuiltins (TCMT m)


-- | <a>KillRange</a> instances for data structures from <a>Base</a>.
module Agda.TypeChecking.Monad.Base.KillRange

-- | Overlaps with <tt>KillRange [a]</tt>.

-- | Remove ranges in keys and values of a map.
killRangeMap :: (KillRange k, KillRange v) => KillRangeT (Map k v)
instance [overlap ok] KillRange String
instance [overlap ok] KillRange a => KillRange (Drop a)
instance [overlap ok] KillRange CompiledClauses
instance [overlap ok] KillRange c => KillRange (Case c)
instance [overlap ok] KillRange c => KillRange (WithArity c)
instance [overlap ok] KillRange DisplayTerm
instance [overlap ok] KillRange Polarity
instance [overlap ok] KillRange DisplayForm
instance [overlap ok] KillRange a => KillRange (Open a)
instance [overlap ok] KillRange Occurrence
instance [overlap ok] KillRange Projection
instance [overlap ok] KillRange TermHead
instance [overlap ok] KillRange c => KillRange (FunctionInverse' c)
instance [overlap ok] KillRange MutualId
instance [overlap ok] KillRange Defn
instance [overlap ok] KillRange CompiledRepresentation
instance [overlap ok] KillRange RewriteRule
instance [overlap ok] KillRange Definition
instance [overlap ok] KillRange Section
instance [overlap ok] KillRange Definitions
instance [overlap ok] KillRange Sections
instance [overlap ok] KillRange Signature


-- | Lenses for <a>TCState</a> and more.
module Agda.TypeChecking.Monad.State

-- | Resets the non-persistent part of the type checking state.
resetState :: TCM ()

-- | Resets all of the type checking state.
--   
--   Keep only <a>Benchmark</a> information.
resetAllState :: TCM ()

-- | Restore <a>TCState</a> after performing subcomputation.
--   
--   In contrast to <a>localState</a>, the <a>Benchmark</a> info from the
--   subcomputation is saved.
localTCState :: TCM a -> TCM a

-- | Same as <a>localTCState</a> but also returns the state in which we
--   were just before reverting it.
localTCStateSaving :: TCM a -> TCM (a, TCState)
lensPersistentState :: Lens' PersistentTCState TCState
updatePersistentState :: (PersistentTCState -> PersistentTCState) -> (TCState -> TCState)
modifyPersistentState :: (PersistentTCState -> PersistentTCState) -> TCM ()

-- | Lens for <a>stAccumStatistics</a>.
lensAccumStatisticsP :: Lens' Statistics PersistentTCState
lensAccumStatistics :: Lens' Statistics TCState

-- | Get the current scope.
getScope :: TCM ScopeInfo

-- | Set the current scope.
setScope :: ScopeInfo -> TCM ()

-- | Modify the current scope.
modifyScope :: (ScopeInfo -> ScopeInfo) -> TCM ()

-- | Run a computation in a local scope.
withScope :: ScopeInfo -> TCM a -> TCM (a, ScopeInfo)

-- | Same as <a>withScope</a>, but discard the scope from the computation.
withScope_ :: ScopeInfo -> TCM a -> TCM a

-- | Discard any changes to the scope by a computation.
localScope :: TCM a -> TCM a

-- | Scope error.
notInScope :: QName -> TCM a

-- | Debug print the scope.
printScope :: String -> Int -> String -> TCM ()
modifySignature :: (Signature -> Signature) -> TCM ()
modifyImportedSignature :: (Signature -> Signature) -> TCM ()
getSignature :: TCM Signature
getImportedSignature :: TCM Signature
setSignature :: Signature -> TCM ()
setImportedSignature :: Signature -> TCM ()

-- | Run some computation in a different signature, restore original
--   signature.
withSignature :: Signature -> TCM a -> TCM a
lookupDefinition :: QName -> Signature -> Maybe Definition
updateDefinition :: QName -> (Definition -> Definition) -> Signature -> Signature
updateTheDef :: (Defn -> Defn) -> (Definition -> Definition)
updateDefType :: (Type -> Type) -> (Definition -> Definition)
updateDefArgOccurrences :: ([Occurrence] -> [Occurrence]) -> (Definition -> Definition)
updateDefPolarity :: ([Polarity] -> [Polarity]) -> (Definition -> Definition)
updateDefCompiledRep :: (CompiledRepresentation -> CompiledRepresentation) -> (Definition -> Definition)
updateFunClauses :: ([Clause] -> [Clause]) -> (Defn -> Defn)

-- | Set the top-level module. This affects the global module id of freshly
--   generated names.
setTopLevelModule :: QName -> TCM ()

-- | Use a different top-level module for a computation. Used when
--   generating names for imported modules.
withTopLevelModule :: QName -> TCM a -> TCM a

-- | Tell the compiler to import the given Haskell module.
addHaskellImport :: String -> TCM ()

-- | Get the Haskell imports.
getHaskellImports :: TCM (Set String)
getInteractionOutputCallback :: TCM InteractionOutputCallback
appInteractionOutputCallback :: Response -> TCM ()
setInteractionOutputCallback :: InteractionOutputCallback -> TCM ()
getPatternSyns :: TCM PatternSynDefns
setPatternSyns :: PatternSynDefns -> TCM ()

-- | Lens for <a>stPatternSyns</a>.
modifyPatternSyns :: (PatternSynDefns -> PatternSynDefns) -> TCM ()
getPatternSynImports :: TCM PatternSynDefns
lookupPatternSyn :: QName -> TCM PatternSynDefn

-- | Lens getter for <a>Benchmark</a> from <a>TCState</a>.
theBenchmark :: TCState -> Benchmark

-- | Lens map for <a>Benchmark</a>.
updateBenchmark :: (Benchmark -> Benchmark) -> TCState -> TCState

-- | Lens getter for <a>Benchmark</a> from <a>TCM</a>.
getBenchmark :: TCM Benchmark

-- | Lens modify for <a>Benchmark</a>.
modifyBenchmark :: (Benchmark -> Benchmark) -> TCM ()

-- | Run a fresh instance of the TCM (with initial state). <a>Benchmark</a>
--   info is preserved.
freshTCM :: TCM a -> TCM (Either TCErr a)

-- | Look through the signature and reconstruct the instance table.
addSignatureInstances :: Signature -> TCM ()

-- | Lens for <a>stInstanceDefs</a>.
updateInstanceDefs :: (TempInstanceTable -> TempInstanceTable) -> (TCState -> TCState)
modifyInstanceDefs :: (TempInstanceTable -> TempInstanceTable) -> TCM ()
getAllInstanceDefs :: TCM TempInstanceTable
getAnonInstanceDefs :: TCM [QName]

-- | Remove all instances whose type is still unresolved.
clearAnonInstanceDefs :: TCM ()

-- | Add an instance whose type is still unresolved.
addUnknownInstance :: QName -> TCM ()

-- | Add instance to some ``class''.
addNamedInstance :: QName -> QName -> TCM ()


-- | Measure CPU time for individual phases of the Agda pipeline.
module Agda.TypeChecking.Monad.Benchmark

-- | Lens getter for <a>Benchmark</a> from <a>TCM</a>.
getBenchmark :: TCM Benchmark

-- | Check whether benchmarking is activated.
benchmarking :: MonadTCM tcm => tcm Bool

-- | Report benchmarking results.
reportBenchmarkingLn :: String -> TCM ()

-- | Report benchmarking results.
reportBenchmarkingDoc :: TCM Doc -> TCM ()

-- | Bill a computation to a specific account.
billTo :: MonadTCM tcm => Account -> tcm a -> tcm a

-- | Bill a top account.
billTop :: MonadTCM tcm => Phase -> tcm a -> tcm a

-- | Bill a pure computation to a specific account.
billPureTo :: MonadTCM tcm => Account -> a -> tcm a

-- | Bill a sub account.
billSub :: MonadTCM tcm => Account -> tcm a -> tcm a

-- | Reimburse a specific account for computation costs.
reimburse :: MonadTCM tcm => Account -> tcm a -> tcm a

-- | Reimburse a top account.
reimburseTop :: MonadTCM tcm => Phase -> tcm a -> tcm a


-- | Functions which map between module names and file names.
--   
--   Note that file name lookups are cached in the <a>TCState</a>. The code
--   assumes that no Agda source files are added or removed from the
--   include directories while the code is being type checked.
module Agda.Interaction.FindFile

-- | Converts an Agda file name to the corresponding interface file name.
toIFile :: AbsolutePath -> AbsolutePath

-- | Errors which can arise when trying to find a source file.
--   
--   Invariant: All paths are absolute.
data FindError

-- | The file was not found. It should have had one of the given file
--   names.
NotFound :: [AbsolutePath] -> FindError

-- | Several matching files were found.
--   
--   Invariant: The list of matching files has at least two elements.
Ambiguous :: [AbsolutePath] -> FindError

-- | Given the module name which the error applies to this function
--   converts a <a>FindError</a> to a <a>TypeError</a>.
findErrorToTypeError :: TopLevelModuleName -> FindError -> TypeError

-- | Finds the source file corresponding to a given top-level module name.
--   The returned paths are absolute.
--   
--   Raises an error if the file cannot be found.
findFile :: TopLevelModuleName -> TCM AbsolutePath

-- | Tries to find the source file corresponding to a given top-level
--   module name. The returned paths are absolute.
--   
--   SIDE EFFECT: Updates <a>stModuleToSource</a>.
findFile' :: TopLevelModuleName -> TCM (Either FindError AbsolutePath)

-- | A variant of <a>findFile'</a> which does not require <a>TCM</a>.
findFile'' :: [AbsolutePath] -> TopLevelModuleName -> ModuleToSource -> IO (Either FindError AbsolutePath, ModuleToSource)

-- | Finds the interface file corresponding to a given top-level module
--   name. The returned paths are absolute.
--   
--   Raises an error if the source file cannot be found, and returns
--   <a>Nothing</a> if the source file can be found but not the interface
--   file.
findInterfaceFile :: TopLevelModuleName -> TCM (Maybe AbsolutePath)

-- | Ensures that the module name matches the file name. The file
--   corresponding to the module name (according to the include path) has
--   to be the same as the given file name.
checkModuleName :: TopLevelModuleName -> AbsolutePath -> TCM ()

-- | Computes the module name of the top-level module in the given file.
--   
--   Warning! Parses the whole file to get the module name out. Use wisely!
moduleName' :: AbsolutePath -> TCM TopLevelModuleName

-- | A variant of <a>moduleName'</a> which raises an error if the file name
--   does not match the module name.
--   
--   The file name is interpreted relative to the current working directory
--   (unless it is absolute).
moduleName :: AbsolutePath -> TCM TopLevelModuleName
tests :: IO Bool


-- | Lenses for <a>CommandLineOptions</a> and <a>PragmaOptions</a>.
--   
--   Add as needed.
--   
--   Nothing smart happening here.
module Agda.Interaction.Options.Lenses
class LensPragmaOptions a where setPragmaOptions = mapPragmaOptions . const mapPragmaOptions f a = setPragmaOptions (f $ getPragmaOptions a) a
getPragmaOptions :: LensPragmaOptions a => a -> PragmaOptions
setPragmaOptions :: LensPragmaOptions a => PragmaOptions -> a -> a
mapPragmaOptions :: LensPragmaOptions a => (PragmaOptions -> PragmaOptions) -> a -> a
modifyPragmaOptions :: (PragmaOptions -> PragmaOptions) -> TCM ()
class LensVerbosity a where setVerbosity = mapVerbosity . const mapVerbosity f a = setVerbosity (f $ getVerbosity a) a
getVerbosity :: LensVerbosity a => a -> Verbosity
setVerbosity :: LensVerbosity a => Verbosity -> a -> a
mapVerbosity :: LensVerbosity a => (Verbosity -> Verbosity) -> a -> a
modifyVerbosity :: (Verbosity -> Verbosity) -> TCM ()
putVerbosity :: Verbosity -> TCM ()
class LensCommandLineOptions a where setCommandLineOptions = mapCommandLineOptions . const mapCommandLineOptions f a = setCommandLineOptions (f $ getCommandLineOptions a) a
getCommandLineOptions :: LensCommandLineOptions a => a -> CommandLineOptions
setCommandLineOptions :: LensCommandLineOptions a => CommandLineOptions -> a -> a
mapCommandLineOptions :: LensCommandLineOptions a => (CommandLineOptions -> CommandLineOptions) -> a -> a
modifyCommandLineOptions :: (CommandLineOptions -> CommandLineOptions) -> TCM ()
type SafeMode = Bool
class LensSafeMode a where setSafeMode = mapSafeMode . const mapSafeMode f a = setSafeMode (f $ getSafeMode a) a
getSafeMode :: LensSafeMode a => a -> SafeMode
setSafeMode :: LensSafeMode a => SafeMode -> a -> a
mapSafeMode :: LensSafeMode a => (SafeMode -> SafeMode) -> a -> a
modifySafeMode :: (SafeMode -> SafeMode) -> TCM ()
putSafeMode :: SafeMode -> TCM ()
class LensIncludeDirs a where setIncludeDirs = mapIncludeDirs . const mapIncludeDirs f a = setIncludeDirs (f $ getIncludeDirs a) a
getIncludeDirs :: LensIncludeDirs a => a -> IncludeDirs
setIncludeDirs :: LensIncludeDirs a => IncludeDirs -> a -> a
mapIncludeDirs :: LensIncludeDirs a => (IncludeDirs -> IncludeDirs) -> a -> a
modifyIncludeDirs :: (IncludeDirs -> IncludeDirs) -> TCM ()
putIncludeDirs :: IncludeDirs -> TCM ()
type PersistentVerbosity = Verbosity
class LensPersistentVerbosity a where setPersistentVerbosity = mapPersistentVerbosity . const mapPersistentVerbosity f a = setPersistentVerbosity (f $ getPersistentVerbosity a) a
getPersistentVerbosity :: LensPersistentVerbosity a => a -> PersistentVerbosity
setPersistentVerbosity :: LensPersistentVerbosity a => PersistentVerbosity -> a -> a
mapPersistentVerbosity :: LensPersistentVerbosity a => (PersistentVerbosity -> PersistentVerbosity) -> a -> a
modifyPersistentVerbosity :: (PersistentVerbosity -> PersistentVerbosity) -> TCM ()
putPersistentVerbosity :: PersistentVerbosity -> TCM ()
instance LensPersistentVerbosity TCState
instance LensPersistentVerbosity PersistentTCState
instance LensPersistentVerbosity CommandLineOptions
instance LensPersistentVerbosity PragmaOptions
instance LensIncludeDirs TCState
instance LensIncludeDirs PersistentTCState
instance LensIncludeDirs CommandLineOptions
instance LensSafeMode TCState
instance LensSafeMode PersistentTCState
instance LensSafeMode CommandLineOptions
instance LensCommandLineOptions TCState
instance LensCommandLineOptions PersistentTCState
instance LensVerbosity TCState
instance LensVerbosity PragmaOptions
instance LensPragmaOptions TCState
instance LensPragmaOptions CommandLineOptions

module Agda.TypeChecking.Monad.Options

-- | Sets the pragma options.
setPragmaOptions :: PragmaOptions -> TCM ()

-- | Sets the command line options (both persistent and pragma options are
--   updated).
--   
--   Relative include directories are made absolute with respect to the
--   current working directory. If the include directories have changed
--   (thus, they are <a>Left</a> now, and were previously <tt><a>Right</a>
--   something</tt>), then the state is reset (completely, see
--   setIncludeDirs) .
--   
--   An empty list of relative include directories (<tt><a>Left</a>
--   []</tt>) is interpreted as <tt>["."]</tt>.
setCommandLineOptions :: CommandLineOptions -> TCM ()
class (Functor m, Applicative m, Monad m) => HasOptions m
pragmaOptions :: HasOptions m => m PragmaOptions
commandLineOptions :: HasOptions m => m CommandLineOptions
setOptionsFromPragma :: OptionsPragma -> TCM ()

-- | Disable display forms.
enableDisplayForms :: TCM a -> TCM a

-- | Disable display forms.
disableDisplayForms :: TCM a -> TCM a

-- | Check if display forms are enabled.
displayFormsEnabled :: TCM Bool

-- | Don't eta contract implicit
dontEtaContractImplicit :: TCM a -> TCM a

-- | Do eta contract implicit
doEtaContractImplicit :: MonadTCM tcm => tcm a -> tcm a
shouldEtaContractImplicit :: MonadReader TCEnv m => m Bool

-- | Don't reify interaction points
dontReifyInteractionPoints :: TCM a -> TCM a
shouldReifyInteractionPoints :: TCM Bool

-- | Gets the include directories.
--   
--   Precondition: <a>optIncludeDirs</a> must be <tt><a>Right</a>
--   something</tt>.
getIncludeDirs :: TCM [AbsolutePath]

-- | Which directory should form the base of relative include paths?
data RelativeTo

-- | The root directory of the "project" containing the given file. The
--   file needs to be syntactically correct, with a module name matching
--   the file name.
ProjectRoot :: AbsolutePath -> RelativeTo

-- | The current working directory.
CurrentDir :: RelativeTo

-- | Makes the given directories absolute and stores them as include
--   directories.
--   
--   If the include directories change (and they were previously
--   <tt><a>Right</a> something</tt>), then the state is reset (completely,
--   except for the include directories and
--   <a>stInteractionOutputCallback</a>).
--   
--   An empty list is interpreted as <tt>["."]</tt>.
setIncludeDirs :: [FilePath] -> RelativeTo -> TCM ()
setInputFile :: FilePath -> TCM ()

-- | Should only be run if <a>hasInputFile</a>.
getInputFile :: TCM AbsolutePath
hasInputFile :: TCM Bool
proofIrrelevance :: TCM Bool
hasUniversePolymorphism :: HasOptions m => m Bool
showImplicitArguments :: TCM Bool
showIrrelevantArguments :: TCM Bool

-- | Switch on printing of implicit and irrelevant arguments. E.g. for
--   reification in with-function generation.
withShowAllArguments :: TCM a -> TCM a
ignoreInterfaces :: TCM Bool
positivityCheckEnabled :: TCM Bool
typeInType :: TCM Bool

-- | Retrieve the current verbosity level.
getVerbosity :: HasOptions m => m (Trie String Int)
type VerboseKey = String

-- | Check whether a certain verbosity level is activated.
--   
--   Precondition: The level must be non-negative.
hasVerbosity :: HasOptions m => VerboseKey -> Int -> m Bool

-- | Displays a debug message in a suitable way.
displayDebugMessage :: MonadTCM tcm => Int -> String -> tcm ()

-- | Run a computation if a certain verbosity level is activated.
--   
--   Precondition: The level must be non-negative.
verboseS :: MonadTCM tcm => VerboseKey -> Int -> tcm () -> tcm ()

-- | Conditionally print debug string.
reportS :: MonadTCM tcm => VerboseKey -> Int -> String -> tcm ()

-- | Conditionally println debug string.
reportSLn :: MonadTCM tcm => VerboseKey -> Int -> String -> tcm ()

-- | Conditionally render debug <a>Doc</a> and print it.
reportSDoc :: MonadTCM tcm => VerboseKey -> Int -> TCM Doc -> tcm ()

-- | Print brackets around debug messages issued by a computation.
verboseBracket :: MonadTCM tcm => VerboseKey -> Int -> String -> TCM a -> tcm a
instance MonadIO m => HasOptions (TCMT m)


-- | The translation of abstract syntax to concrete syntax has two
--   purposes. First it allows us to pretty print abstract syntax values
--   without having to write a dedicated pretty printer, and second it
--   serves as a sanity check for the concrete to abstract translation:
--   translating from concrete to abstract and then back again should be
--   (more or less) the identity.
module Agda.Syntax.Translation.AbstractToConcrete
class ToConcrete a c | a -> c where toConcrete x = bindToConcrete x return bindToConcrete x ret = ret =<< toConcrete x
toConcrete :: ToConcrete a c => a -> AbsToCon c
bindToConcrete :: ToConcrete a c => a -> (c -> AbsToCon b) -> AbsToCon b

-- | Translate something in a context of the given precedence.
toConcreteCtx :: ToConcrete a c => Precedence -> a -> AbsToCon c
abstractToConcrete_ :: ToConcrete a c => a -> TCM c
abstractToConcreteEnv :: ToConcrete a c => Env -> a -> TCM c
runAbsToCon :: AbsToCon c -> TCM c
data RangeAndPragma
RangeAndPragma :: Range -> Pragma -> RangeAndPragma
abstractToConcreteCtx :: ToConcrete a c => Precedence -> a -> TCM c
withScope :: ScopeInfo -> AbsToCon a -> AbsToCon a
makeEnv :: ScopeInfo -> Env

-- | We put the translation into TCM in order to print debug messages.
type AbsToCon = ReaderT Env TCM
data DontTouchMe a
data Env
noTakenNames :: AbsToCon a -> AbsToCon a
instance ToConcrete Pattern Pattern
instance ToConcrete LHSCore Pattern
instance ToConcrete LHS LHS
instance ToConcrete SpineLHS LHS
instance ToConcrete RangeAndPragma Pragma
instance ToConcrete Declaration [Declaration]
instance ToConcrete ModuleApplication ModuleApplication
instance ToConcrete a LHS => ToConcrete (Clause' a) [Declaration]
instance ToConcrete (Constr Constructor) Declaration
instance ToConcrete (Maybe QName) (Maybe Name)
instance ToConcrete RHS (RHS, [Expr], [Expr], [Declaration])
instance ToConcrete AsWhereDecls WhereClause
instance ToConcrete LetBinding [Declaration]
instance ToConcrete TypedBinding TypedBinding
instance ToConcrete TypedBindings [TypedBindings]
instance ToConcrete LamBinding [LamBinding]
instance ToConcrete Expr Expr
instance ToConcrete ModuleName QName
instance ToConcrete QName QName
instance ToConcrete Name Name
instance ToConcrete (DontTouchMe a) a
instance ToConcrete a c => ToConcrete (Named name a) (Named name c)
instance ToConcrete a c => ToConcrete (Arg ac a) (Arg c)
instance ToConcrete (ArgInfo ac) ArgInfo
instance (ToConcrete a1 c1, ToConcrete a2 c2, ToConcrete a3 c3) => ToConcrete (a1, a2, a3) (c1, c2, c3)
instance (ToConcrete a1 c1, ToConcrete a2 c2) => ToConcrete (a1, a2) (c1, c2)
instance ToConcrete a c => ToConcrete [a] [c]


-- | The scope monad with operations.
module Agda.Syntax.Scope.Monad

-- | To simplify interaction between scope checking and type checking (in
--   particular when chasing imports), we use the same monad.
type ScopeM = TCM
isDatatypeModule :: ModuleName -> ScopeM Bool
getCurrentModule :: ScopeM ModuleName
setCurrentModule :: ModuleName -> ScopeM ()
withCurrentModule :: ModuleName -> ScopeM a -> ScopeM a
withCurrentModule' :: (MonadTrans t, Monad (t ScopeM)) => ModuleName -> t ScopeM a -> t ScopeM a
getNamedScope :: ModuleName -> ScopeM Scope
getCurrentScope :: ScopeM Scope

-- | Create a new module with an empty scope (Bool is True if it is a
--   datatype module)
createModule :: Bool -> ModuleName -> ScopeM ()

-- | Apply a function to the scope info.
modifyScopeInfo :: (ScopeInfo -> ScopeInfo) -> ScopeM ()

-- | Apply a function to the scope map.
modifyScopes :: (Map ModuleName Scope -> Map ModuleName Scope) -> ScopeM ()

-- | Apply a function to the given scope.
modifyNamedScope :: ModuleName -> (Scope -> Scope) -> ScopeM ()
setNamedScope :: ModuleName -> Scope -> ScopeM ()

-- | Apply a monadic function to the top scope.
modifyNamedScopeM :: ModuleName -> (Scope -> ScopeM Scope) -> ScopeM ()

-- | Apply a function to the current scope.
modifyCurrentScope :: (Scope -> Scope) -> ScopeM ()
modifyCurrentScopeM :: (Scope -> ScopeM Scope) -> ScopeM ()

-- | Apply a function to the public or private name space.
modifyCurrentNameSpace :: NameSpaceId -> (NameSpace -> NameSpace) -> ScopeM ()
setContextPrecedence :: Precedence -> ScopeM ()
getContextPrecedence :: ScopeM Precedence
withContextPrecedence :: Precedence -> ScopeM a -> ScopeM a
getLocalVars :: ScopeM LocalVars
modifyLocalVars :: (LocalVars -> LocalVars) -> ScopeM ()
setLocalVars :: LocalVars -> ScopeM ()

-- | Run a computation without changing the local variables.
withLocalVars :: ScopeM a -> ScopeM a

-- | Create a fresh abstract name from a concrete name.
--   
--   This function is used when we translate a concrete name in a binder.
--   The <a>Range</a> of the concrete name is saved as the
--   <a>nameBindingSite</a> of the abstract name.
freshAbstractName :: Fixity' -> Name -> ScopeM Name

-- | <pre>
--   freshAbstractName_ = freshAbstractName defaultFixity
--   </pre>
freshAbstractName_ :: Name -> ScopeM Name

-- | Create a fresh abstract qualified name.
freshAbstractQName :: Fixity' -> Name -> ScopeM QName
data ResolvedName
VarName :: Name -> ResolvedName
DefinedName :: Access -> AbstractName -> ResolvedName

-- | record fields names need to be distinguished to parse copatterns
FieldName :: AbstractName -> ResolvedName
ConstructorName :: [AbstractName] -> ResolvedName
PatternSynResName :: AbstractName -> ResolvedName
UnknownName :: ResolvedName

-- | Look up the abstract name referred to by a given concrete name.
resolveName :: QName -> ScopeM ResolvedName

-- | Look up the abstract name corresponding to a concrete name of a
--   certain kind. Sometimes we know already that we are dealing with a
--   constructor or pattern synonym (e.g. when we have parsed a pattern).
--   Then, we can ignore conflicting definitions of that name of a
--   different kind. (See issue 822.)
resolveName' :: [KindOfName] -> QName -> ScopeM ResolvedName

-- | Look up a module in the scope.
resolveModule :: QName -> ScopeM AbstractModule

-- | Get the fixity of a name. The name is assumed to be in scope.
getFixity :: QName -> ScopeM Fixity'

-- | Bind a variable. The abstract name is supplied as the second argument.
bindVariable :: Name -> Name -> ScopeM ()

-- | Bind a defined name. Must not shadow anything.
bindName :: Access -> KindOfName -> Name -> QName -> ScopeM ()

-- | Rebind a name. Use with care! Ulf, 2014-06-29: Currently used to
--   rebind the name defined by an unquoteDecl, which is a
--   <a>QuotableName</a> in the body, but a <a>DefinedName</a> later on.
rebindName :: Access -> KindOfName -> Name -> QName -> ScopeM ()

-- | Bind a module name.
bindModule :: Access -> Name -> ModuleName -> ScopeM ()

-- | Bind a qualified module name. Adds it to the imports field of the
--   scope.
bindQModule :: Access -> QName -> ModuleName -> ScopeM ()

-- | Clear the scope of any no names.
stripNoNames :: ScopeM ()
type Out = (Ren ModuleName, Ren QName)
type WSM = StateT Out ScopeM

-- | Create a new scope with the given name from an old scope. Renames
--   public names in the old scope to match the new name and returns the
--   renamings.
--   
--   Data and record types share a common abstract name with their module.
--   This invariant needs to be preserved by <tt>copyScope</tt>, since
--   constructors (fields) can be qualified by their data (record) type
--   name (as an alternative to qualification by their module). (See Issue
--   836).
copyScope :: QName -> ModuleName -> Scope -> ScopeM (Scope, (Ren ModuleName, Ren QName))

-- | Apply an import directive and check that all the names mentioned
--   actually exist.
applyImportDirectiveM :: QName -> ImportDirective -> Scope -> ScopeM Scope

-- | Open a module.
openModule_ :: QName -> ImportDirective -> ScopeM ()
instance Show ResolvedName

module Agda.TypeChecking.Monad.Sharing
updateSharedTerm :: MonadTCM tcm => (Term -> tcm Term) -> Term -> tcm Term
updateSharedTermF :: (MonadTCM tcm, Traversable f) => (Term -> tcm (f Term)) -> Term -> tcm (f Term)
updateSharedTermT :: (MonadTCM tcm, MonadTrans t, Monad (t tcm)) => (Term -> t tcm Term) -> Term -> t tcm Term
forceEqualTerms :: Term -> Term -> TCM ()
disableDestructiveUpdate :: TCM a -> TCM a

module Agda.Syntax.Abstract.Copatterns
translateCopatternClauses :: [Clause] -> ScopeM (Delayed, [Clause])
instance Eq (LHSCore' e)
instance Eq AmbiguousQName
instance Functor (Path a)
instance Eq ProjEntry
instance Ord ProjEntry
instance Eq LHS
instance Eq (Pattern' e)
instance Alpha a => Alpha [a]
instance (Eq n, Alpha a) => Alpha (Named n a)
instance Alpha a => Alpha (Arg a)
instance Alpha LHS
instance Alpha (LHSCore' e)
instance Alpha (Pattern' e)
instance Alpha Name
instance Rename a => Rename [a]
instance Rename a => Rename (Named n a)
instance Rename a => Rename (Arg a)
instance Rename Declaration
instance Rename Pattern
instance Rename LHSCore
instance Rename LHS
instance Rename RHS
instance Rename Clause
instance Rename TypedBinding
instance Rename TypedBindings
instance Rename LamBinding
instance Rename LetBinding
instance Rename Expr
instance HasRange ProjEntry

module Agda.Syntax.Concrete.Operators.Parser
data ExprView e
LocalV :: QName -> ExprView e
WildV :: e -> ExprView e
OtherV :: e -> ExprView e
AppV :: e -> (NamedArg e) -> ExprView e
OpAppV :: QName -> [NamedArg (OpApp e)] -> ExprView e
HiddenArgV :: (Named_ e) -> ExprView e
InstanceArgV :: (Named_ e) -> ExprView e
LamV :: [LamBinding] -> e -> ExprView e
ParenV :: e -> ExprView e
class HasRange e => IsExpr e
exprView :: IsExpr e => e -> ExprView e
unExprView :: IsExpr e => ExprView e -> e

-- | Parse a specific identifier as a NamePart
partP :: IsExpr e => [Name] -> RawName -> ReadP e Range
binop :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e (e -> e -> e)
preop :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e (e -> e)
postop :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e (e -> e)

-- | Parse the "operator part" of the given syntax. holes at beginning and
--   end are IGNORED.
opP :: IsExpr e => ReadP e e -> NewNotation -> ReadP e (NewNotation, Range, [e])

-- | Given a name with a syntax spec, and a list of parsed expressions
--   fitting it, rebuild the expression.
rebuild :: IsExpr e => NewNotation -> Range -> [e] -> e
rebuildBinding :: IsExpr e => ExprView e -> LamBinding

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
infixP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
nonfixP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
prefixP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
postfixP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
infixlP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e

-- | Parse using the appropriate fixity, given a parser parsing the
--   operator part, the name of the operator, and a parser of
--   subexpressions.
infixrP :: IsExpr e => ReadP e (NewNotation, Range, [e]) -> ReadP e e -> ReadP e e
argsP :: IsExpr e => ReadP e e -> ReadP e [NamedArg e]
appP :: IsExpr e => ReadP e e -> ReadP e [NamedArg e] -> ReadP e e
atomP :: IsExpr e => (QName -> Bool) -> ReadP e e
instance IsExpr e => HasRange (ExprView e)


-- | The parser doesn't know about operators and parses everything as
--   normal function application. This module contains the functions that
--   parses the operators properly. For a stand-alone implementation of
--   this see <tt>src/prototyping/mixfix/old</tt>.
--   
--   It also contains the function that puts parenthesis back given the
--   precedence of the context.
module Agda.Syntax.Concrete.Operators

-- | Parse a list of expressions into an application.
parseApplication :: [Expr] -> ScopeM Expr

-- | Parse an expression into a module application (an identifier plus a
--   list of arguments).
parseModuleApplication :: Expr -> ScopeM (QName, [NamedArg Expr])

-- | Parses a left-hand side, and makes sure that it defined the expected
--   name. TODO: check the arities of constructors. There is a possible
--   ambiguity with postfix constructors: Assume _ * is a constructor. Then
--   'true *' can be parsed as either the intended _* applied to true, or
--   as true applied to a variable *. If we check arities this problem
--   won't appear.
parseLHS :: Name -> Pattern -> ScopeM LHSCore

-- | Parses a pattern. TODO: check the arities of constructors. There is a
--   possible ambiguity with postfix constructors: Assume _ * is a
--   constructor. Then 'true *' can be parsed as either the intended _*
--   applied to true, or as true applied to a variable *. If we check
--   arities this problem won't appear.
parsePattern :: Pattern -> ScopeM Pattern
parsePatternSyn :: Pattern -> ScopeM Pattern
instance IsExpr Pattern
instance IsExpr Expr

module Agda.TypeChecking.Monad.Trace
interestingCall :: Closure Call -> Bool
traceCallM :: MonadTCM tcm => tcm (Maybe r -> Call) -> tcm a -> tcm a

-- | Record a function call in the trace.
traceCall :: MonadTCM tcm => (Maybe r -> Call) -> tcm a -> tcm a
traceCall_ :: MonadTCM tcm => (Maybe () -> Call) -> tcm r -> tcm r
traceCallCPS :: MonadTCM tcm => (Maybe r -> Call) -> (r -> tcm a) -> ((r -> tcm a) -> tcm b) -> tcm b
traceCallCPS_ :: MonadTCM tcm => (Maybe () -> Call) -> tcm a -> (tcm a -> tcm b) -> tcm b
getCurrentRange :: TCM Range
setCurrentRange :: Range -> TCM a -> TCM a

module Agda.TypeChecking.Monad.Env

-- | Get the name of the current module, if any.
currentModule :: TCM ModuleName

-- | Set the name of the current module.
withCurrentModule :: ModuleName -> TCM a -> TCM a

-- | Get the number of variables bound by anonymous modules.
getAnonymousVariables :: ModuleName -> TCM Nat

-- | Add variables bound by an anonymous module.
withAnonymousModule :: ModuleName -> Nat -> TCM a -> TCM a

-- | Set the current environment to the given
withEnv :: TCEnv -> TCM a -> TCM a

-- | Get the current environment
getEnv :: TCM TCEnv

-- | Increases the module nesting level by one in the given computation.
withIncreasedModuleNestingLevel :: TCM a -> TCM a

-- | Set highlighting level
withHighlightingLevel :: HighlightingLevel -> TCM a -> TCM a

-- | Restore setting for <a>ExpandLast</a> to default.
doExpandLast :: TCM a -> TCM a
dontExpandLast :: TCM a -> TCM a

-- | If the reduced did a proper match (constructor or literal pattern),
--   then record this as simplification step.
performedSimplification :: MonadReader TCEnv m => m a -> m a
performedSimplification' :: MonadReader TCEnv m => Simplification -> m a -> m a
getSimplification :: MonadReader TCEnv m => m Simplification

-- | Lens for <a>AllowedReductions</a>.
updateAllowedReductions :: (AllowedReductions -> AllowedReductions) -> TCEnv -> TCEnv
modifyAllowedReductions :: (AllowedReductions -> AllowedReductions) -> TCM a -> TCM a
putAllowedReductions :: AllowedReductions -> TCM a -> TCM a

-- | Reduce <tt>Def f vs</tt> only if <tt>f</tt> is a projection.
onlyReduceProjections :: TCM a -> TCM a

-- | Allow all reductions except for non-terminating functions (default).
allowAllReductions :: TCM a -> TCM a

-- | Allow all reductions including non-terminating functions.
allowNonTerminatingReductions :: TCM a -> TCM a
insideDotPattern :: TCM a -> TCM a
isInsideDotPattern :: TCM Bool
isReifyingUnquoted :: TCM Bool
nowReifyingUnquoted :: TCM a -> TCM a

module Agda.TypeChecking.LevelConstraints

-- | <tt>simplifyLevelConstraint n c cs</tt> turns an <tt>c</tt> into an
--   equality constraint if it is an inequality constraint and the reverse
--   inequality is contained in <tt>cs</tt>. Number <tt>n</tt> is the
--   length of the context <tt>c</tt> is defined in.
simplifyLevelConstraint :: Int -> Constraint -> Constraints -> Constraint
instance Show Leq
instance Eq Leq

module Agda.TypeChecking.Monad.Closure
enterClosure :: Closure a -> (a -> TCM b) -> TCM b


-- | Basically a copy of the ErrorT monad transformer. It's handy to slap
--   onto TCM and still be a MonadTCM (which isn't possible with ErrorT).
module Agda.TypeChecking.Monad.Exception
newtype ExceptionT err m a
ExceptionT :: m (Either err a) -> ExceptionT err m a
runExceptionT :: ExceptionT err m a -> m (Either err a)
class Error err => MonadException err m | m -> err
throwException :: MonadException err m => err -> m a
catchException :: MonadException err m => m a -> (err -> m a) -> m a
instance (Error err, MonadTCM tcm) => MonadTCM (ExceptionT err tcm)
instance (Error err, MonadIO m) => MonadIO (ExceptionT err m)
instance (Error err, MonadError err' m) => MonadError err' (ExceptionT err m)
instance (Error err, MonadReader r m) => MonadReader r (ExceptionT err m)
instance (Error err, MonadState s m) => MonadState s (ExceptionT err m)
instance (Error err, Applicative m, Monad m) => Applicative (ExceptionT err m)
instance Functor f => Functor (ExceptionT err f)
instance MonadTrans (ExceptionT err)
instance (Monad m, MonadException err m, Monoid w) => MonadException err (WriterT w m)
instance (Monad m, MonadException err m) => MonadException err (ReaderT r m)
instance (Monad m, Error err) => MonadException err (ExceptionT err m)
instance (Monad m, Error err) => Monad (ExceptionT err m)

module Agda.TypeChecking.Monad.Constraints

-- | Get the current problem
currentProblem :: TCM ProblemId

-- | Steal all constraints belonging to the given problem and add them to
--   the current problem.
stealConstraints :: ProblemId -> TCM ()
solvingProblem :: ProblemId -> TCM a -> TCM a
isProblemSolved :: ProblemId -> TCM Bool
getConstraintsForProblem :: ProblemId -> TCM Constraints

-- | Get the awake constraints
getAwakeConstraints :: TCM Constraints
wakeConstraints :: (ProblemConstraint -> Bool) -> TCM ()
dropConstraints :: (ProblemConstraint -> Bool) -> TCM ()
putAllConstraintsToSleep :: TCM ()
takeAwakeConstraint :: TCM (Maybe ProblemConstraint)
getAllConstraints :: TCM Constraints
withConstraint :: (Constraint -> TCM a) -> ProblemConstraint -> TCM a
buildProblemConstraint :: ProblemId -> Constraint -> TCM ProblemConstraint
buildConstraint :: Constraint -> TCM ProblemConstraint

-- | Add new a constraint
addConstraint' :: Constraint -> TCM ()

-- | Add already awake constraints
addAwakeConstraints :: Constraints -> TCM ()

-- | Start solving constraints
nowSolvingConstraints :: TCM a -> TCM a
isSolvingConstraints :: TCM Bool
mapAwakeConstraints :: (Constraints -> Constraints) -> TCState -> TCState
mapSleepingConstraints :: (Constraints -> Constraints) -> TCState -> TCState
modifyAwakeConstraints :: (Constraints -> Constraints) -> TCM ()
modifySleepingConstraints :: (Constraints -> Constraints) -> TCM ()

module Agda.TypeChecking.Monad.Open

-- | Create an open term in the current context.
makeOpen :: a -> TCM (Open a)

-- | Create an open term which is closed.
makeClosed :: a -> Open a

-- | Extract the value from an open term. Must be done in an extension of
--   the context in which the term was created.
getOpen :: Subst a => Open a -> TCM a

-- | Try to use an <a>Open</a> the current context. Returns <a>Nothing</a>
--   if current context is not an extension of the context in which the
--   <a>Open</a> was created.
tryOpen :: Subst a => Open a -> TCM (Maybe a)

module Agda.TypeChecking.Monad.Context

-- | Modify the <a>ctxEntry</a> field of a <a>ContextEntry</a>.
modifyContextEntry :: (Dom (Name, Type) -> Dom (Name, Type)) -> ContextEntry -> ContextEntry

-- | Modify all <a>ContextEntry</a>s.
modifyContextEntries :: (Dom (Name, Type) -> Dom (Name, Type)) -> Context -> Context

-- | Modify a <a>Context</a> in a computation.
modifyContext :: MonadTCM tcm => (Context -> Context) -> tcm a -> tcm a
mkContextEntry :: MonadTCM tcm => Dom (Name, Type) -> tcm ContextEntry

-- | Change the context.
inContext :: MonadTCM tcm => [Dom (Name, Type)] -> tcm a -> tcm a

-- | Change to top (=empty) context.
inTopContext :: MonadTCM tcm => tcm a -> tcm a

-- | Delete the last <tt>n</tt> bindings from the context.
escapeContext :: MonadTCM tcm => Int -> tcm a -> tcm a

-- | <tt>addCtx x arg cont</tt> add a variable to the context.
--   
--   Chooses an unused <a>Name</a>.
addCtx :: MonadTCM tcm => Name -> Dom Type -> tcm a -> tcm a

-- | Various specializations of <tt>addCtx</tt>.
class AddContext b
addContext :: (AddContext b, MonadTCM tcm) => b -> tcm a -> tcm a

-- | add a bunch of variables with the same type to the context
addCtxs :: MonadTCM tcm => [Name] -> Dom Type -> tcm a -> tcm a

-- | Turns the string into a name and adds it to the context.
addCtxString :: MonadTCM tcm => String -> Dom Type -> tcm a -> tcm a

-- | Turns the string into a name and adds it to the context, with dummy
--   type.
addCtxString_ :: MonadTCM tcm => String -> tcm a -> tcm a
addCtxStrings_ :: MonadTCM tcm => [String] -> tcm a -> tcm a

-- | Context entries without a type have this dummy type.
dummyDom :: Dom Type

-- | Go under an abstraction.
underAbstraction :: (Subst a, MonadTCM tcm) => Dom Type -> Abs a -> (a -> tcm b) -> tcm b

-- | Go under an abstract without worrying about the type to add to the
--   context.
underAbstraction_ :: (Subst a, MonadTCM tcm) => Abs a -> (a -> tcm b) -> tcm b

-- | Add a telescope to the context.
addCtxTel :: MonadTCM tcm => Telescope -> tcm a -> tcm a

-- | Add a let bound variable
addLetBinding :: MonadTCM tcm => ArgInfo -> Name -> Term -> Type -> tcm a -> tcm a

-- | Get the current context.
getContext :: MonadTCM tcm => tcm [Dom (Name, Type)]

-- | Get the size of the current context.
getContextSize :: MonadTCM tcm => tcm Nat

-- | Generate <tt>[var (n - 1), ..., var 0]</tt> for all declarations in
--   the context.
getContextArgs :: MonadTCM tcm => tcm Args

-- | Generate <tt>[var (n - 1), ..., var 0]</tt> for all declarations in
--   the context.
getContextTerms :: MonadTCM tcm => tcm [Term]

-- | Get the current context as a <a>Telescope</a>.
getContextTelescope :: MonadTCM tcm => tcm Telescope

-- | Check if we are in a compatible context, i.e. an extension of the
--   given context.
getContextId :: MonadTCM tcm => tcm [CtxId]

-- | get type of bound variable (i.e. deBruijn index)
lookupBV :: MonadTCM tcm => Nat -> tcm (Dom (Name, Type))
typeOfBV' :: MonadTCM tcm => Nat -> tcm (Dom Type)
typeOfBV :: MonadTCM tcm => Nat -> tcm Type
nameOfBV :: MonadTCM tcm => Nat -> tcm Name

-- | Get the term corresponding to a named variable. If it is a lambda
--   bound variable the deBruijn index is returned and if it is a let bound
--   variable its definition is returned.
getVarInfo :: MonadTCM tcm => Name -> tcm (Term, Dom Type)
instance [overlap ok] AddContext Telescope
instance [overlap ok] AddContext String
instance [overlap ok] AddContext Name
instance [overlap ok] AddContext (Dom (String, Type))
instance [overlap ok] AddContext (String, Dom Type)
instance [overlap ok] AddContext ([Name], Dom Type)
instance [overlap ok] AddContext (Dom (Name, Type))
instance [overlap ok] AddContext (Name, Dom Type)
instance [overlap ok] AddContext a => AddContext [a]

module Agda.TypeChecking.Monad.MetaVars

-- | Switch off assignment of metas.
dontAssignMetas :: TCM a -> TCM a

-- | Get the meta store.
getMetaStore :: TCM MetaStore
modifyMetaStore :: (MetaStore -> MetaStore) -> TCM ()

-- | Lookup a meta variable
lookupMeta :: MetaId -> TCM MetaVariable
updateMetaVar :: MetaId -> (MetaVariable -> MetaVariable) -> TCM ()
getMetaPriority :: MetaId -> TCM MetaPriority
isSortMeta :: MetaId -> TCM Bool
isSortMeta_ :: MetaVariable -> Bool
getMetaType :: MetaId -> TCM Type

-- | Given a meta, return the type applied to the current context.
getMetaTypeInContext :: MetaId -> TCM Type

-- | Check whether all metas are instantiated. Precondition: argument is a
--   meta (in some form) or a list of metas.
class IsInstantiatedMeta a
isInstantiatedMeta :: IsInstantiatedMeta a => a -> TCM Bool

-- | Does not worry about raising.
isInstantiatedMeta' :: MetaId -> TCM (Maybe Term)

-- | Create <a>MetaInfo</a> in the current environment.
createMetaInfo :: TCM MetaInfo
createMetaInfo' :: RunMetaOccursCheck -> TCM MetaInfo
setValueMetaName :: Term -> MetaNameSuggestion -> TCM ()
getMetaNameSuggestion :: MetaId -> TCM MetaNameSuggestion
setMetaNameSuggestion :: MetaId -> MetaNameSuggestion -> TCM ()
updateMetaVarRange :: MetaId -> Range -> TCM ()
modifyInteractionPoints :: (InteractionPoints -> InteractionPoints) -> TCM ()

-- | Register an interaction point during scope checking. If there is no
--   interaction id yet, create one.
registerInteractionPoint :: Range -> Maybe Nat -> TCM InteractionId

-- | Hook up meta variable to interaction point.
connectInteractionPoint :: InteractionId -> MetaId -> TCM ()

-- | Move an interaction point from the current ones to the old ones.
removeInteractionPoint :: InteractionId -> TCM ()

-- | Get a list of interaction ids.
getInteractionPoints :: TCM [InteractionId]

-- | Get all metas that correspond to interaction ids.
getInteractionMetas :: TCM [MetaId]

-- | Get all metas that correspond to interaction ids.
getInteractionIdsAndMetas :: TCM [(InteractionId, MetaId)]

-- | Does the meta variable correspond to an interaction point?
--   
--   Time: <tt>O(n)</tt> where <tt>n</tt> is the number of interaction
--   metas.
isInteractionMeta :: MetaId -> TCM (Maybe InteractionId)

-- | Get the information associated to an interaction point.
lookupInteractionPoint :: InteractionId -> TCM InteractionPoint

-- | Get <a>MetaId</a> for an interaction point. Precondition: interaction
--   point is connected.
lookupInteractionId :: InteractionId -> TCM MetaId

-- | Generate new meta variable.
newMeta :: MetaInfo -> MetaPriority -> Permutation -> Judgement Type a -> TCM MetaId

-- | Generate a new meta variable with some instantiation given. For
--   instance, the instantiation could be a
--   <a>PostponedTypeCheckingProblem</a>.
newMeta' :: MetaInstantiation -> MetaInfo -> MetaPriority -> Permutation -> Judgement Type a -> TCM MetaId

-- | Get the <a>Range</a> for an interaction point.
getInteractionRange :: InteractionId -> TCM Range

-- | Get the <a>Range</a> for a meta variable.
getMetaRange :: MetaId -> TCM Range
getInteractionScope :: InteractionId -> TCM ScopeInfo
withMetaInfo' :: MetaVariable -> TCM a -> TCM a
withMetaInfo :: Closure Range -> TCM a -> TCM a
getInstantiatedMetas :: TCM [MetaId]
getOpenMetas :: TCM [MetaId]

-- | <tt>listenToMeta l m</tt>: register <tt>l</tt> as a listener to
--   <tt>m</tt>. This is done when the type of l is blocked by <tt>m</tt>.
listenToMeta :: Listener -> MetaId -> TCM ()

-- | Unregister a listener.
unlistenToMeta :: Listener -> MetaId -> TCM ()

-- | Get the listeners to a meta.
getMetaListeners :: MetaId -> TCM [Listener]
clearMetaListeners :: MetaId -> TCM ()

-- | Freeze all meta variables.
freezeMetas :: TCM ()

-- | Thaw all meta variables.
unfreezeMetas :: TCM ()
isFrozen :: MetaId -> TCM Bool

-- | Unfreeze meta and its type if this is a meta again. Does not unfreeze
--   deep occurrences of metas.
class UnFreezeMeta a
unfreezeMeta :: UnFreezeMeta a => a -> TCM ()
instance UnFreezeMeta a => UnFreezeMeta (Abs a)
instance UnFreezeMeta a => UnFreezeMeta [a]
instance UnFreezeMeta LevelAtom
instance UnFreezeMeta PlusLevel
instance UnFreezeMeta Level
instance UnFreezeMeta Sort
instance UnFreezeMeta Term
instance UnFreezeMeta Type
instance UnFreezeMeta MetaId
instance IsInstantiatedMeta a => IsInstantiatedMeta (Abs a)
instance IsInstantiatedMeta a => IsInstantiatedMeta (Arg c a)
instance IsInstantiatedMeta a => IsInstantiatedMeta (Maybe a)
instance IsInstantiatedMeta a => IsInstantiatedMeta [a]
instance IsInstantiatedMeta LevelAtom
instance IsInstantiatedMeta PlusLevel
instance IsInstantiatedMeta Level
instance IsInstantiatedMeta Term
instance IsInstantiatedMeta MetaId


-- | Translation from <a>Agda.Syntax.Concrete</a> to
--   <a>Agda.Syntax.Abstract</a>. Involves scope analysis, figuring out
--   infix operator precedences and tidying up definitions.
module Agda.Syntax.Translation.ConcreteToAbstract

-- | Things that can be translated to abstract syntax are instances of this
--   class.
class ToAbstract concrete abstract | concrete -> abstract
toAbstract :: ToAbstract concrete abstract => concrete -> ScopeM abstract

-- | This operation does not affect the scope, i.e. the original scope is
--   restored upon completion.
localToAbstract :: ToAbstract c a => c -> (a -> ScopeM b) -> ScopeM b
concreteToAbstract_ :: ToAbstract c a => c -> ScopeM a
concreteToAbstract :: ToAbstract c a => ScopeInfo -> c -> ScopeM a
newtype NewModuleQName
NewModuleQName :: QName -> NewModuleQName
newtype OldName
OldName :: Name -> OldName

-- | Temporary data type to scope check a file.
data TopLevel a
TopLevel :: AbsolutePath -> a -> TopLevel a

-- | The file path from which we loaded this module.
topLevelPath :: TopLevel a -> AbsolutePath

-- | The file content.
topLevelTheThing :: TopLevel a -> a
data TopLevelInfo
TopLevelInfo :: [Declaration] -> ScopeInfo -> ScopeInfo -> TopLevelInfo
topLevelDecls :: TopLevelInfo -> [Declaration]
outsideScope :: TopLevelInfo -> ScopeInfo
insideScope :: TopLevelInfo -> ScopeInfo

-- | The top-level module name.
topLevelModuleName :: TopLevelInfo -> ModuleName
data AbstractRHS
data NewModuleName
data OldModuleName
data NewName a
data OldQName
data LeftHandSide
data RightHandSide
data PatName
data APatName
data LetDef
data LetDefs
instance [overlap ok] ToAbstract Pattern (Pattern' Expr)
instance [overlap ok] ToAbstract (Pattern' Expr) (Pattern' Expr)
instance [overlap ok] ToAbstract ArgInfo ArgInfo
instance [overlap ok] ToAbstract c a => ToAbstract (NamedArg c) (NamedArg a)
instance [overlap ok] ToAbstract (LHSCore' Expr) (LHSCore' Expr)
instance [overlap ok] ToAbstract c a => ToAbstract (Named name c) (Named name a)
instance [overlap ok] ToAbstract c a => ToAbstract (Arg c) (Arg a)
instance [overlap ok] ToAbstract LHSCore (LHSCore' Expr)
instance [overlap ok] ToAbstract LeftHandSide LHS
instance [overlap ok] ToAbstract RHS AbstractRHS
instance [overlap ok] ToAbstract RightHandSide AbstractRHS
instance [overlap ok] ToAbstract AbstractRHS RHS
instance [overlap ok] ToAbstract Clause Clause
instance [overlap ok] ToAbstract Pragma [Pragma]
instance [overlap ok] ToAbstract ConstrDecl Declaration
instance [overlap ok] ToAbstract NiceDeclaration Declaration
instance [overlap ok] ToAbstract (Blind a) (Blind a)
instance [overlap ok] ToAbstract LetDef [LetBinding]
instance [overlap ok] ToAbstract LetDefs [LetBinding]
instance [overlap ok] ToAbstract [Declaration] [Declaration]
instance [overlap ok] ToAbstract (TopLevel [Declaration]) TopLevelInfo
instance [overlap ok] EnsureNoLetStms a => EnsureNoLetStms [a]
instance [overlap ok] EnsureNoLetStms a => EnsureNoLetStms (TypedBindings' a)
instance [overlap ok] EnsureNoLetStms a => EnsureNoLetStms (LamBinding' a)
instance [overlap ok] EnsureNoLetStms TypedBinding
instance [overlap ok] ToAbstract TypedBinding TypedBinding
instance [overlap ok] ToAbstract TypedBindings TypedBindings
instance [overlap ok] ToAbstract LamBinding LamBinding
instance [overlap ok] ToAbstract Expr Expr
instance [overlap ok] ToAbstract OldModuleName ModuleName
instance [overlap ok] ToAbstract NewModuleQName ModuleName
instance [overlap ok] ToAbstract NewModuleName ModuleName
instance [overlap ok] ToAbstract OldName QName
instance [overlap ok] ToAbstract PatName APatName
instance [overlap ok] ToAbstract OldQName Expr
instance [overlap ok] ToAbstract (NewName BoundName) Name
instance [overlap ok] ToAbstract (NewName Name) Name
instance [overlap ok] ToAbstract c a => ToAbstract (Maybe c) (Maybe a)
instance [overlap ok] ToAbstract c a => ToAbstract [c] [a]
instance [overlap ok] (ToAbstract c1 a1, ToAbstract c2 a2, ToAbstract c3 a3) => ToAbstract (c1, c2, c3) (a1, a2, a3)
instance [overlap ok] (ToAbstract c1 a1, ToAbstract c2 a2) => ToAbstract (c1, c2) (a1, a2)

module Agda.TypeChecking.Monad.Imports
addImport :: ModuleName -> TCM ()
addImportCycleCheck :: TopLevelModuleName -> TCM a -> TCM a
getImports :: TCM (Set ModuleName)
isImported :: ModuleName -> TCM Bool
getImportPath :: TCM [TopLevelModuleName]
visitModule :: ModuleInfo -> TCM ()
setVisitedModules :: VisitedModules -> TCM ()
getVisitedModules :: TCM VisitedModules
isVisited :: TopLevelModuleName -> TCM Bool
getVisitedModule :: TopLevelModuleName -> TCM (Maybe ModuleInfo)
getDecodedModules :: TCM DecodedModules
setDecodedModules :: DecodedModules -> TCM ()
getDecodedModule :: TopLevelModuleName -> TCM (Maybe Interface)
storeDecodedModule :: Interface -> TCM ()
dropDecodedModule :: TopLevelModuleName -> TCM ()
withImportPath :: [TopLevelModuleName] -> TCM a -> TCM a

-- | Assumes that the first module in the import path is the module we are
--   worried about.
checkForImportCycle :: TCM ()

module Agda.TypeChecking.Monad.Mutual
noMutualBlock :: TCM a -> TCM a
inMutualBlock :: TCM a -> TCM a

-- | Set the mutual block for a definition
setMutualBlock :: MutualId -> QName -> TCM ()

-- | Get all mutual blocks
getMutualBlocks :: TCM [Set QName]

-- | Get the current mutual block, if any, otherwise a fresh mutual block
--   is returned.
currentOrFreshMutualBlock :: TCM MutualId
lookupMutualBlock :: MutualId -> TCM (Set QName)
findMutualBlock :: QName -> TCM (Set QName)

module Agda.TypeChecking.Monad.Signature

-- | Add a constant to the signature. Lifts the definition to top level.
addConstant :: QName -> Definition -> TCM ()

-- | Set termination info of a defined function symbol.
setTerminates :: QName -> Bool -> TCM ()

-- | Modify the clauses of a function.
modifyFunClauses :: QName -> ([Clause] -> [Clause]) -> TCM ()

-- | Lifts clauses to the top-level and adds them to definition.
addClauses :: QName -> [Clause] -> TCM ()
addHaskellCode :: QName -> HaskellType -> HaskellCode -> TCM ()
addHaskellExport :: QName -> HaskellType -> String -> TCM ()
addHaskellType :: QName -> HaskellType -> TCM ()
addEpicCode :: QName -> EpicCode -> TCM ()
addJSCode :: QName -> String -> TCM ()
markStatic :: QName -> TCM ()
unionSignatures :: [Signature] -> Signature

-- | Add a section to the signature.
addSection :: ModuleName -> Nat -> TCM ()

-- | Lookup a section. If it doesn't exist that just means that the module
--   wasn't parameterised.
lookupSection :: ModuleName -> TCM Telescope
addDisplayForms :: QName -> TCM ()

-- | Module application (followed by module parameter abstraction).
applySection :: ModuleName -> Telescope -> ModuleName -> Args -> Ren QName -> Ren ModuleName -> TCM ()
addDisplayForm :: QName -> DisplayForm -> TCM ()
canonicalName :: QName -> TCM QName
sameDef :: QName -> QName -> TCM (Maybe QName)

-- | Can be called on either a (co)datatype, a record type or a
--   (co)constructor.
whatInduction :: QName -> TCM Induction

-- | Does the given constructor come from a single-constructor type?
--   
--   Precondition: The name has to refer to a constructor.
singleConstructorType :: QName -> TCM Bool
class (Functor m, Applicative m, Monad m) => HasConstInfo m
getConstInfo :: HasConstInfo m => QName -> m Definition
getConInfo :: MonadTCM tcm => ConHead -> tcm Definition

-- | Look up the polarity of a definition.
getPolarity :: QName -> TCM [Polarity]

-- | Look up polarity of a definition and compose with polarity represented
--   by <a>Comparison</a>.
getPolarity' :: Comparison -> QName -> TCM [Polarity]

-- | Set the polarity of a definition.
setPolarity :: QName -> [Polarity] -> TCM ()

-- | Return a finite list of argument occurrences.
getArgOccurrences :: QName -> TCM [Occurrence]
getArgOccurrence :: QName -> Nat -> TCM Occurrence
setArgOccurrences :: QName -> [Occurrence] -> TCM ()

-- | Get the mutually recursive identifiers.
getMutual :: QName -> TCM [QName]

-- | Set the mutually recursive identifiers.
setMutual :: QName -> [QName] -> TCM ()

-- | Check whether two definitions are mutually recursive.
mutuallyRecursive :: QName -> QName -> TCM Bool

-- | Why Maybe? The reason is that we look up all prefixes of a module to
--   compute number of parameters, and for hierarchical top-level modules,
--   A.B.C say, A and A.B do not exist.
getSection :: ModuleName -> TCM (Maybe Section)

-- | Look up the number of free variables of a section. This is equal to
--   the number of parameters if we're currently inside the section and 0
--   otherwise.
getSecFreeVars :: ModuleName -> TCM Nat

-- | Compute the number of free variables of a module. This is the sum of
--   the free variables of its sections.
getModuleFreeVars :: ModuleName -> TCM Nat

-- | Compute the number of free variables of a defined name. This is the
--   sum of the free variables of the sections it's contained in.
getDefFreeVars :: QName -> TCM Nat

-- | Compute the context variables to apply a definition to.
freeVarsToApply :: QName -> TCM Args

-- | Instantiate a closed definition with the correct part of the current
--   context.
instantiateDef :: Definition -> TCM Definition

-- | Give the abstract view of a definition.
makeAbstract :: Definition -> Maybe Definition

-- | Enter abstract mode. Abstract definition in the current module are
--   transparent.
inAbstractMode :: TCM a -> TCM a

-- | Not in abstract mode. All abstract definitions are opaque.
inConcreteMode :: TCM a -> TCM a

-- | Ignore abstract mode. All abstract definitions are transparent.
ignoreAbstractMode :: MonadReader TCEnv m => m a -> m a

-- | Check whether a name might have to be treated abstractly (either if
--   we're <a>inAbstractMode</a> or it's not a local name). Returns true
--   for things not declared abstract as well, but for those
--   <a>makeAbstract</a> will have no effect.
treatAbstractly :: MonadReader TCEnv m => QName -> m Bool
treatAbstractly' :: QName -> TCEnv -> Bool

-- | Get type of a constant, instantiated to the current context.
typeOfConst :: QName -> TCM Type

-- | Get relevance of a constant.
relOfConst :: QName -> TCM Relevance

-- | Get colors of a constant.
colOfConst :: QName -> TCM [Color]

-- | The name must be a datatype.
sortOfConst :: QName -> TCM Sort

-- | Is it the name of a record projection?
isProjection :: QName -> TCM (Maybe Projection)
isProjection_ :: Defn -> Maybe Projection
isProperProjection :: Defn -> Bool

-- | Number of dropped initial arguments.
projectionArgs :: Defn -> Int

-- | Apply a function <tt>f</tt> to its first argument, producing the
--   proper postfix projection if <tt>f</tt> is a projection.
applyDef :: QName -> Arg Term -> TCM Term

-- | <tt>getDefType f t</tt> computes the type of (possibly
--   projection-(like)) function <tt>t</tt> whose first argument has type
--   <tt>t</tt>. The <tt>parameters</tt> for <tt>f</tt> are extracted from
--   <tt>t</tt>. <tt>Nothing</tt> if <tt>f</tt> is projection(like) but
--   <tt>t</tt> is not a data<i>record</i>axiom type.
--   
--   Precondition: <tt>t</tt> is reduced.
--   
--   See also: <a>getConType</a>
getDefType :: QName -> Type -> TCM (Maybe Type)
instance (HasConstInfo m, Error err) => HasConstInfo (ExceptionT err m)
instance HasConstInfo (TCMT IO)


-- | Stuff for sized types that does not require modules <a>Reduce</a> or
--   <a>Constraints</a> (which import <a>Monad</a>).
module Agda.TypeChecking.Monad.SizedTypes

-- | Result of querying whether size variable <tt>i</tt> is bounded by
--   another size.
data BoundedSize

-- | yes <tt>i : Size&lt; t</tt>
BoundedLt :: Term -> BoundedSize
BoundedNo :: BoundedSize

-- | Check if a type is the <a>primSize</a> type. The argument should be
--   <tt>reduce</tt>d.
isSizeType :: Type -> TCM (Maybe BoundedSize)
isSizeTypeTest :: TCM (Type -> Maybe BoundedSize)
getBuiltinDefName :: String -> TCM (Maybe QName)
getBuiltinSize :: TCM (Maybe QName, Maybe QName)
isSizeNameTest :: TCM (QName -> Bool)
isSizeNameTestRaw :: TCM (QName -> Bool)

-- | Test whether OPTIONS --sized-types and whether the size built-ins are
--   defined.
haveSizedTypes :: TCM Bool

-- | Add polarity info to a SIZE builtin.
builtinSizeHook :: String -> QName -> Term -> Type -> TCM ()

-- | The sort of built-in types <tt>SIZE</tt> and <tt>SIZELT</tt>.
sizeSort :: Sort

-- | The type of built-in types <tt>SIZE</tt> and <tt>SIZELT</tt>.
sizeUniv :: Type

-- | The built-in type <tt>SIZE</tt> with user-given name.
sizeType_ :: QName -> Type

-- | The built-in type <tt>SIZE</tt>.
sizeType :: TCM Type

-- | The name of <tt>SIZESUC</tt>.
sizeSucName :: TCM (Maybe QName)
sizeSuc :: Nat -> Term -> TCM Term
sizeSuc_ :: QName -> Term -> Term

-- | Transform list of terms into a term build from binary maximum.
sizeMax :: [Term] -> TCM Term

-- | A useful view on sizes.
data SizeView
SizeInf :: SizeView
SizeSuc :: Term -> SizeView
OtherSize :: Term -> SizeView
sizeView :: Term -> TCM SizeView
type Offset = Nat

-- | A deep view on sizes.
data DeepSizeView
DSizeInf :: DeepSizeView
DSizeVar :: Nat -> Offset -> DeepSizeView
DSizeMeta :: MetaId -> Elims -> Offset -> DeepSizeView
DOtherSize :: Term -> DeepSizeView
data SizeViewComparable a
NotComparable :: SizeViewComparable a
YesAbove :: DeepSizeView -> a -> SizeViewComparable a
YesBelow :: DeepSizeView -> a -> SizeViewComparable a

-- | <tt>sizeViewComparable v w</tt> checks whether <tt>v &gt;= w</tt>
--   (then <tt>Left</tt>) or <tt>v &lt;= w</tt> (then <tt>Right</tt>). If
--   uncomparable, it returns <tt>NotComparable</tt>.
sizeViewComparable :: DeepSizeView -> DeepSizeView -> SizeViewComparable ()
sizeViewSuc_ :: QName -> DeepSizeView -> DeepSizeView

-- | <tt>sizeViewPred k v</tt> decrements <tt>v</tt> by <tt>k</tt> (must be
--   possible!).
sizeViewPred :: Nat -> DeepSizeView -> DeepSizeView

-- | <tt>sizeViewOffset v</tt> returns the number of successors or Nothing
--   when infty.
sizeViewOffset :: DeepSizeView -> Maybe Offset

-- | Remove successors common to both sides.
removeSucs :: (DeepSizeView, DeepSizeView) -> (DeepSizeView, DeepSizeView)

-- | Turn a size view into a term.
unSizeView :: SizeView -> TCM Term
unDeepSizeView :: DeepSizeView -> TCM Term
type SizeMaxView = [DeepSizeView]
maxViewMax :: SizeMaxView -> SizeMaxView -> SizeMaxView

-- | <tt>maxViewCons v ws = max v ws</tt>. It only adds <tt>v</tt> to
--   <tt>ws</tt> if it is not subsumed by an element of <tt>ws</tt>.
maxViewCons :: DeepSizeView -> SizeMaxView -> SizeMaxView

-- | <tt>sizeViewComparableWithMax v ws</tt> tries to find <tt>w</tt> in
--   <tt>ws</tt> that compares with <tt>v</tt> and singles this out.
--   Precondition: <tt>v /= DSizeInv</tt>.
sizeViewComparableWithMax :: DeepSizeView -> SizeMaxView -> SizeViewComparable SizeMaxView
maxViewSuc_ :: QName -> SizeMaxView -> SizeMaxView
unMaxView :: SizeMaxView -> TCM Term
instance Eq BoundedSize
instance Show BoundedSize
instance Functor SizeViewComparable


-- | Collect statistics.
module Agda.TypeChecking.Monad.Statistics

-- | Increase specified counter by <tt>1</tt>.
tick :: String -> TCM ()

-- | Increase specified counter by <tt>n</tt>.
tickN :: String -> Integer -> TCM ()

-- | Set the specified counter to the maximum of its current value and
--   <tt>n</tt>.
tickMax :: String -> Integer -> TCM ()

-- | Get the statistics.
getStatistics :: TCM Statistics

-- | Modify the statistics via given function.
modifyStatistics :: (Statistics -> Statistics) -> TCM ()

-- | Print the given statistics if verbosity "profile" is given.
printStatistics :: Int -> Maybe TopLevelModuleName -> Statistics -> TCM ()

module Agda.TypeChecking.Monad

module Agda.Interaction.Monad

-- | Interaction monad.
type IM = TCMT (InputT IO)

-- | Line reader. The line reader history is not stored between sessions.
readline :: String -> IM (Maybe String)
runIM :: IM a -> TCM a
instance MonadError TCErr IM


-- | Generate an import dependency graph for a given module.
module Agda.Interaction.Highlighting.Dot

-- | Internal module identifiers for construction of dependency graph.
type ModuleId = String
data DotState
DotState :: Map ModuleName ModuleId -> [ModuleId] -> Set (ModuleId, ModuleId) -> DotState

-- | Records already processed modules and maps them to an internal
--   identifier.
dsModules :: DotState -> Map ModuleName ModuleId

-- | Supply of internal identifiers.
dsNameSupply :: DotState -> [ModuleId]

-- | Edges of dependency graph.
dsConnection :: DotState -> Set (ModuleId, ModuleId)
initialDotState :: DotState
type DotM = StateT DotState TCM

-- | Translate a <a>ModuleName</a> to an internal <a>ModuleId</a>. Returns
--   <tt>True</tt> if the <a>ModuleName</a> is new, i.e., has not been
--   encountered before and is thus added to the map of processed modules.
addModule :: ModuleName -> DotM (ModuleId, Bool)

-- | Add an arc from importer to imported.
addConnection :: ModuleId -> ModuleId -> DotM ()

-- | Recursively build import graph, starting from given <a>Interface</a>.
--   Modifies the state in <a>DotM</a> and returns the <a>ModuleId</a> of
--   the <a>Interface</a>.
dottify :: Interface -> DotM ModuleId

-- | Generate a .dot file for the import graph starting with the given
--   <a>Interface</a> and write it to the file specified by the command
--   line option.
generateDot :: Interface -> TCM ()


-- | Function for generating highlighted, hyperlinked HTML from Agda
--   sources.
module Agda.Interaction.Highlighting.HTML

-- | Generates HTML files from all the sources which have been visited
--   during the type checking phase.
--   
--   This function should only be called after type checking has completed
--   successfully.
generateHTML :: TCM ()


-- | Irrelevant function types.
module Agda.TypeChecking.Irrelevance

-- | data <a>Relevance</a> see <a>Common</a>
irrelevantOrUnused :: Relevance -> Bool

-- | <tt>unusableRelevance rel == True</tt> iff we cannot use a variable of
--   <tt>rel</tt>.
unusableRelevance :: Relevance -> Bool

-- | <a>Relevance</a> composition. <a>Irrelevant</a> is dominant,
--   <a>Relevant</a> is neutral.
composeRelevance :: Relevance -> Relevance -> Relevance

-- | <tt>inverseComposeRelevance r x</tt> returns the most irrelevant
--   <tt>y</tt> such that forall <tt>x</tt>, <tt>y</tt> we have <tt>x
--   `moreRelevant` (r `composeRelevance` y)</tt> iff <tt>(r
--   `inverseComposeRelevance` x) `moreRelevant` y</tt> (Galois
--   connection).
inverseComposeRelevance :: Relevance -> Relevance -> Relevance

-- | For comparing <tt>Relevance</tt> ignoring <tt>Forced</tt> and
--   <tt>UnusedArg</tt>.
ignoreForced :: Relevance -> Relevance

-- | Irrelevant function arguments may appear non-strictly in the codomain
--   type.
irrToNonStrict :: Relevance -> Relevance
nonStrictToIrr :: Relevance -> Relevance

-- | Prepare parts of a parameter telescope for abstraction in constructors
--   and projections.
hideAndRelParams :: Dom a -> Dom a

-- | Used to modify context when going into a <tt>rel</tt> argument.
inverseApplyRelevance :: Relevance -> Dom a -> Dom a

-- | Compose two relevance flags. This function is used to update the
--   relevance information on pattern variables <tt>a</tt> after a match
--   against something <tt>rel</tt>.
applyRelevance :: Relevance -> Dom a -> Dom a

-- | Modify the context whenever going from the l.h.s. (term side) of the
--   typing judgement to the r.h.s. (type side).
workOnTypes :: TCM a -> TCM a

-- | Call me if --experimental-irrelevance is set.
doWorkOnTypes :: TCM a -> TCM a

-- | Internal workhorse, expects value of --experimental-irrelevance flag
--   as argument.
workOnTypes' :: Bool -> TCM a -> TCM a

-- | (Conditionally) wake up irrelevant variables and make them relevant.
--   For instance, in an irrelevant function argument otherwise irrelevant
--   variables may be used, so they are awoken before type checking the
--   argument.
applyRelevanceToContext :: Relevance -> TCM a -> TCM a

-- | Wake up irrelevant variables and make them relevant. For instance, in
--   an irrelevant function argument otherwise irrelevant variables may be
--   used, so they are awoken before type checking the argument.
wakeIrrelevantVars :: TCM a -> TCM a
prop_galois :: Relevance -> Relevance -> Relevance -> Bool
tests :: IO Bool


-- | Functions which give precise syntax highlighting info to Emacs.
module Agda.Interaction.Highlighting.Emacs

-- | Turns syntax highlighting information into a list of S-expressions.
lispifyHighlightingInfo :: HighlightingInfo -> ModuleToSource -> TCM (Lisp String)

-- | All the properties.
tests :: IO Bool

module Agda.Syntax.Abstract.Pretty
showA :: (Show c, ToConcrete a c) => a -> TCM String
prettyA :: (Pretty c, ToConcrete a c) => a -> TCM Doc
prettyAs :: (Pretty c, ToConcrete a [c]) => a -> TCM Doc

-- | Variant of <a>showA</a> which does not insert outermost parentheses.
showATop :: (Show c, ToConcrete a c) => a -> TCM String

-- | Variant of <a>prettyA</a> which does not insert outermost parentheses.
prettyATop :: (Pretty c, ToConcrete a c) => a -> TCM Doc


-- | A command which calls a compiler
module Agda.Compiler.CallCompiler

-- | Calls a compiler:
--   
--   <ul>
--   <li>Checks the exit code to see if the compiler exits successfully. If
--   not, then an exception is raised, containing the text the compiler
--   printed to stderr (if any).</li>
--   <li>Uses the debug printout machinery to relay any progress
--   information the compiler prints to stdout.</li>
--   </ul>
callCompiler :: FilePath -> [String] -> TCM ()

-- | Generalisation of <tt>callCompiler</tt> where the raised exception is
--   returned.
callCompiler' :: FilePath -> [String] -> TCM (Maybe String)


-- | Function for generating highlighted and aligned LaTeX from literate
--   Agda source.
module Agda.Interaction.Highlighting.LaTeX

-- | The only exported function. It's (only) called in <tt>Main.hs</tt>.
generateLaTeX :: TopLevelModuleName -> HighlightingInfo -> TCM ()
instance Show Token
instance Eq Debug
instance Show Debug


-- | Structure-sharing serialisation of Agda interface files.
module Agda.TypeChecking.Serialise

-- | Encodes something. To ensure relocatability file paths in positions
--   are replaced with module names.
encode :: EmbPrj a => a -> TCM ByteString

-- | Encodes something. To ensure relocatability file paths in positions
--   are replaced with module names.
encodeFile :: FilePath -> Interface -> TCM ()
encodeInterface :: Interface -> TCM ByteString

-- | Decodes something. The result depends on the include path.
--   
--   Returns <a>Nothing</a> if the input does not start with the right
--   magic number or some other decoding error is encountered.
decode :: EmbPrj a => ByteString -> TCM (Maybe a)
decodeFile :: FilePath -> TCM (Maybe Interface)

-- | Decodes something. The result depends on the include path.
--   
--   Returns <a>Nothing</a> if the file does not start with the right magic
--   number or some other decoding error is encountered.
decodeInterface :: ByteString -> TCM (Maybe Interface)
decodeHashes :: ByteString -> Maybe (Hash, Hash)
class Typeable a => EmbPrj a where icode a = do { tickICode a; icod_ a }
instance [overlap ok] EmbPrj Tag
instance [overlap ok] EmbPrj Forced
instance [overlap ok] EmbPrj Relevance
instance [overlap ok] EmbPrj InjectiveFun
instance [overlap ok] EmbPrj EInterface
instance [overlap ok] EmbPrj Interface
instance [overlap ok] EmbPrj CompressedFile
instance [overlap ok] EmbPrj ScopeInfo
instance [overlap ok] EmbPrj Precedence
instance [overlap ok] EmbPrj Aspects
instance [overlap ok] EmbPrj OtherAspect
instance [overlap ok] EmbPrj Aspect
instance [overlap ok] EmbPrj NameKind
instance [overlap ok] EmbPrj a => EmbPrj (Builtin a)
instance [overlap ok] EmbPrj Pattern
instance [overlap ok] EmbPrj Delayed
instance [overlap ok] EmbPrj ClauseBody
instance [overlap ok] EmbPrj Clause
instance [overlap ok] EmbPrj IsAbstract
instance [overlap ok] EmbPrj TermHead
instance [overlap ok] EmbPrj FunctionInverse
instance [overlap ok] EmbPrj CompiledClauses
instance [overlap ok] EmbPrj a => EmbPrj (Case a)
instance [overlap ok] EmbPrj a => EmbPrj (WithArity a)
instance [overlap ok] EmbPrj Defn
instance [overlap ok] EmbPrj CompiledRepresentation
instance [overlap ok] EmbPrj Occurrence
instance [overlap ok] EmbPrj Polarity
instance [overlap ok] EmbPrj MemberId
instance [overlap ok] EmbPrj GlobalId
instance [overlap ok] EmbPrj LocalId
instance [overlap ok] EmbPrj Exp
instance [overlap ok] EmbPrj HaskellRepresentation
instance [overlap ok] EmbPrj HaskellExport
instance [overlap ok] EmbPrj Projection
instance [overlap ok] EmbPrj RewriteRule
instance [overlap ok] EmbPrj Definition
instance [overlap ok] EmbPrj MutualId
instance [overlap ok] EmbPrj DisplayTerm
instance [overlap ok] EmbPrj CtxId
instance [overlap ok] EmbPrj a => EmbPrj (Open a)
instance [overlap ok] EmbPrj DisplayForm
instance [overlap ok] EmbPrj Literal
instance [overlap ok] EmbPrj Sort
instance [overlap ok] EmbPrj LevelAtom
instance [overlap ok] EmbPrj PlusLevel
instance [overlap ok] EmbPrj Level
instance [overlap ok] EmbPrj Term
instance [overlap ok] EmbPrj a => EmbPrj (Abs a)
instance [overlap ok] EmbPrj Type
instance [overlap ok] EmbPrj ConHead
instance [overlap ok] EmbPrj Relevance
instance [overlap ok] EmbPrj Hiding
instance [overlap ok] EmbPrj Induction
instance [overlap ok] (EmbPrj a, EmbPrj c) => EmbPrj (Dom c a)
instance [overlap ok] (EmbPrj a, EmbPrj c) => EmbPrj (Arg c a)
instance [overlap ok] EmbPrj a => EmbPrj (Elim' a)
instance [overlap ok] EmbPrj a => EmbPrj (Drop a)
instance [overlap ok] EmbPrj Permutation
instance [overlap ok] EmbPrj Telescope
instance [overlap ok] EmbPrj Section
instance [overlap ok] (Eq k, Hashable k, EmbPrj k, EmbPrj v) => EmbPrj (HashMap k v)
instance [overlap ok] EmbPrj Signature
instance [overlap ok] EmbPrj NameId
instance [overlap ok] EmbPrj c => EmbPrj (ArgInfo c)
instance [overlap ok] EmbPrj TypedBinding
instance [overlap ok] EmbPrj TypedBindings
instance [overlap ok] EmbPrj LetBinding
instance [overlap ok] EmbPrj LamBinding
instance [overlap ok] EmbPrj Pattern
instance [overlap ok] EmbPrj Expr
instance [overlap ok] EmbPrj LocalVar
instance [overlap ok] EmbPrj a => EmbPrj (Ranged a)
instance [overlap ok] (EmbPrj s, EmbPrj t) => EmbPrj (Named s t)
instance [overlap ok] EmbPrj Name
instance [overlap ok] EmbPrj ModuleName
instance [overlap ok] EmbPrj AmbiguousQName
instance [overlap ok] EmbPrj QName
instance [overlap ok] EmbPrj GenPart
instance [overlap ok] EmbPrj Fixity'
instance [overlap ok] EmbPrj Fixity
instance [overlap ok] EmbPrj KindOfName
instance [overlap ok] EmbPrj AbstractModule
instance [overlap ok] EmbPrj AbstractName
instance [overlap ok] EmbPrj WhyInScope
instance [overlap ok] EmbPrj NameSpace
instance [overlap ok] EmbPrj Access
instance [overlap ok] EmbPrj NameSpaceId
instance [overlap ok] EmbPrj Scope
instance [overlap ok] EmbPrj QName
instance [overlap ok] EmbPrj NamePart
instance [overlap ok] EmbPrj Name
instance [overlap ok] EmbPrj Range
instance [overlap ok] EmbPrj Range
instance [overlap ok] EmbPrj Interval
instance [overlap ok] (Ord a, EmbPrj a) => EmbPrj (Set a)
instance [overlap ok] (Ord a, EmbPrj a, EmbPrj b) => EmbPrj (Map a b)
instance [overlap ok] (Ord a, Ord b, EmbPrj a, EmbPrj b) => EmbPrj (BiMap a b)
instance [overlap ok] EmbPrj a => EmbPrj [a]
instance [overlap ok] EmbPrj TopLevelModuleName
instance [overlap ok] EmbPrj Position
instance [overlap ok] EmbPrj AbsolutePath
instance [overlap ok] EmbPrj Bool
instance [overlap ok] EmbPrj a => EmbPrj (Maybe a)
instance [overlap ok] (EmbPrj a, EmbPrj b, EmbPrj c) => EmbPrj (a, b, c)
instance [overlap ok] (EmbPrj a, EmbPrj b) => EmbPrj (a, b)
instance [overlap ok] EmbPrj ()
instance [overlap ok] EmbPrj Double
instance [overlap ok] EmbPrj Char
instance [overlap ok] EmbPrj Int
instance [overlap ok] EmbPrj Int32
instance [overlap ok] EmbPrj Word64
instance [overlap ok] EmbPrj Integer
instance [overlap ok] EmbPrj String

module Agda.Compiler.MAlonzo.Misc
setInterface :: Interface -> TCM ()
curIF :: TCM Interface
curSig :: TCM Signature
curMName :: TCM ModuleName
curHsMod :: TCM ModuleName
curDefs :: TCM Definitions
sigMName :: Signature -> ModuleName
ihname :: String -> Nat -> Name
unqhname :: String -> QName -> Name
tlmodOf :: ModuleName -> TCM ModuleName
tlmname :: ModuleName -> TCM ModuleName
xqual :: QName -> Name -> TCM QName
xhqn :: String -> QName -> TCM QName
conhqn :: QName -> TCM QName
bltQual :: String -> String -> TCM QName
dsubname :: QName -> Nat -> Name
hsVarUQ :: Name -> Exp
mazstr :: String
mazName :: Name
mazMod' :: String -> ModuleName
mazMod :: ModuleName -> ModuleName
mazerror :: String -> a
mazCoerce :: Exp
mazIncompleteMatch :: Exp
rtmIncompleteMatch :: QName -> Exp
mazRTE :: ModuleName
rtmMod :: ModuleName
rtmQual :: String -> QName
rtmVar :: String -> Exp
rtmError :: String -> Exp
unsafeCoerceMod :: ModuleName
fakeD :: Name -> String -> Decl
fakeDS :: String -> String -> Decl
fakeDQ :: QName -> String -> Decl
fakeType :: String -> Type
fakeExp :: String -> Exp
dummy :: a

module Agda.Compiler.MAlonzo.Encode

-- | Haskell module names have to satisfy the Haskell (including the
--   hierarchical module namespace extension) lexical syntax:
--   
--   <pre>
--   modid -&gt; [modid.] large {small | large | digit | ' }
--   </pre>
--   
--   <a>encodeModuleName</a> is an injective function into the set of
--   module names defined by <tt>modid</tt>. The function preserves
--   <tt>.</tt>s, and it also preserves module names whose first name part
--   is not <a>mazstr</a>.
--   
--   Precondition: The input must not start or end with <tt>.</tt>, and no
--   two <tt>.</tt>s may be adjacent.
encodeModuleName :: ModuleName -> ModuleName

-- | All the properties.
tests :: IO Bool
instance Show M
instance Arbitrary M

module Agda.Compiler.MAlonzo.Pretty

-- | Encodes module names just before pretty-printing.
prettyPrint :: (Pretty a, TransformBi ModuleName (Wrap a)) => a -> String

-- | A wrapper type used to avoid orphan instances.
newtype Wrap a
Wrap :: a -> Wrap a
unwrap :: Wrap a -> a
instance TransformBi ModuleName (Wrap QName)
instance TransformBi ModuleName (Wrap ModuleName)
instance TransformBi ModuleName (Wrap Module)
instance TransformBi ModuleName (Wrap Exp)

module Agda.Interaction.Highlighting.Vim
vimFile :: FilePath -> FilePath
escape :: String -> String
wordBounded :: String -> String
keyword :: String -> [String] -> String
match :: String -> [String] -> String
matches :: [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String]
toVim :: NamesInScope -> String
generateVimFile :: FilePath -> TCM ()

module Agda.TypeChecking.DropArgs

-- | When making a function projection-like, we drop the first <tt>n</tt>
--   arguments.
class DropArgs a
dropArgs :: DropArgs a => Int -> a -> a

-- | NOTE: This creates telescopes with unbound de Bruijn indices.

-- | NOTE: does not go into the body, so does not work for recursive
--   functions.

-- | NOTE: does not work for recursive functions.

-- | To drop the first <tt>n</tt> arguments in a compiled clause, we reduce
--   the split argument indices by <tt>n</tt> and drop <tt>n</tt> arguments
--   from the bodies. NOTE: this only works for non-recursive functions, we
--   are not dropping arguments to recursive calls in bodies.
instance DropArgs CompiledClauses
instance DropArgs FunctionInverse
instance DropArgs Clause
instance DropArgs ClauseBody
instance DropArgs Permutation
instance DropArgs Telescope
instance DropArgs a => DropArgs (Maybe a)

module Agda.Termination.RecCheck
recursive :: [QName] -> TCM Bool

-- | <tt>anysDef names a</tt> returns all definitions from <tt>names</tt>
--   that are used in <tt>a</tt>.
anyDefs :: GetDefs a => [QName] -> a -> TCM [QName]

module Agda.TypeChecking.Reduce.Monad
constructorForm :: Term -> ReduceM Term
enterClosure :: Closure a -> (a -> ReduceM b) -> ReduceM b
underAbstraction_ :: Subst a => Abs a -> (a -> ReduceM b) -> ReduceM b

-- | Lookup the definition of a name. The result is a closed thing, all
--   free variables have been abstracted over.
getConstInfo :: HasConstInfo m => QName -> m Definition
isInstantiatedMeta :: MetaId -> ReduceM Bool
lookupMeta :: MetaId -> ReduceM MetaVariable
reportSDoc :: VerboseKey -> Int -> TCM Doc -> ReduceM ()
reportSLn :: VerboseKey -> Int -> String -> ReduceM ()
traceSLn :: HasOptions m => VerboseKey -> Int -> String -> m a -> m a
traceSDoc :: VerboseKey -> Int -> TCM Doc -> ReduceM a -> ReduceM a
instance HasConstInfo ReduceM
instance HasBuiltins ReduceM
instance HasOptions ReduceM


-- | Compute eta short normal forms.
module Agda.TypeChecking.EtaContract
data BinAppView
App :: Term -> (Arg Term) -> BinAppView
NoApp :: Term -> BinAppView
binAppView :: Term -> BinAppView

-- | Contracts all eta-redexes it sees without reducing.
etaContract :: TermLike a => a -> TCM a
etaOnce :: (MonadReader TCEnv m, HasConstInfo m) => Term -> m Term

module Agda.TypeChecking.Forcing
addForcingAnnotations :: Type -> TCM Type
forcedVariables :: Term -> TCM [Nat]
force :: [Nat] -> Type -> Type

module Agda.TypeChecking.MetaVars.Mention
class MentionsMeta t
mentionsMeta :: MentionsMeta t => MetaId -> t -> Bool
instance MentionsMeta Constraint
instance MentionsMeta ProblemConstraint
instance MentionsMeta a => MentionsMeta (Tele a)
instance MentionsMeta Elim
instance MentionsMeta a => MentionsMeta (Closure a)
instance (MentionsMeta a, MentionsMeta b, MentionsMeta c) => MentionsMeta (a, b, c)
instance (MentionsMeta a, MentionsMeta b) => MentionsMeta (a, b)
instance MentionsMeta t => MentionsMeta (Maybe t)
instance MentionsMeta t => MentionsMeta [t]
instance MentionsMeta t => MentionsMeta (Dom t)
instance MentionsMeta t => MentionsMeta (Arg t)
instance MentionsMeta t => MentionsMeta (Abs t)
instance MentionsMeta Sort
instance MentionsMeta Type
instance MentionsMeta LevelAtom
instance MentionsMeta PlusLevel
instance MentionsMeta Level
instance MentionsMeta Term


-- | Tools to manipulate patterns in abstract syntax in the TCM (type
--   checking monad).
module Agda.TypeChecking.Patterns.Abstract

-- | Expand literal integer pattern into suc/zero constructor patterns.
expandLitPattern :: NamedArg Pattern -> TCM (NamedArg Pattern)

-- | Expand away (deeply) all pattern synonyms in a pattern.
class ExpandPatternSynonyms a
expandPatternSynonyms :: ExpandPatternSynonyms a => a -> TCM a
instance ExpandPatternSynonyms Pattern
instance ExpandPatternSynonyms a => ExpandPatternSynonyms (Named n a)
instance ExpandPatternSynonyms a => ExpandPatternSynonyms (Arg c a)
instance ExpandPatternSynonyms a => ExpandPatternSynonyms [a]
instance ExpandPatternSynonyms a => ExpandPatternSynonyms (Maybe a)

module Agda.TypeChecking.Reduce
instantiate :: Instantiate a => a -> TCM a
instantiateFull :: InstantiateFull a => a -> TCM a
reduce :: Reduce a => a -> TCM a
reduceB :: Reduce a => a -> TCM (Blocked a)
normalise :: Normalise a => a -> TCM a
simplify :: Simplify a => a -> TCM a

-- | Instantiate something. Results in an open meta variable or a non meta.
--   Doesn't do any reduction, and preserves blocking tags (when blocking
--   meta is uninstantiated).
class Instantiate t
instantiate' :: Instantiate t => t -> ReduceM t
ifBlocked :: MonadTCM tcm => Term -> (MetaId -> Term -> tcm a) -> (Term -> tcm a) -> tcm a
ifBlockedType :: MonadTCM tcm => Type -> (MetaId -> Type -> tcm a) -> (Type -> tcm a) -> tcm a
class Reduce t where reduce' t = ignoreBlocking <$> reduceB' t reduceB' t = notBlocked <$> reduce' t
reduce' :: Reduce t => t -> ReduceM t
reduceB' :: Reduce t => t -> ReduceM (Blocked t)

-- | If the first argument is <a>True</a>, then a single delayed clause may
--   be unfolded.
unfoldDefinition :: Bool -> (Term -> ReduceM (Blocked Term)) -> Term -> QName -> Args -> ReduceM (Blocked Term)
unfoldDefinitionE :: Bool -> (Term -> ReduceM (Blocked Term)) -> Term -> QName -> Elims -> ReduceM (Blocked Term)
unfoldDefinition' :: Bool -> (Term -> ReduceM (Simplification, Blocked Term)) -> Term -> QName -> Elims -> ReduceM (Simplification, Blocked Term)

-- | Reduce a non-primitive definition if it is a copy linking to another
--   def.
reduceDefCopy :: QName -> Args -> TCM (Reduced () Term)

-- | Reduce simple (single clause) definitions.
reduceHead :: Term -> TCM (Blocked Term)
reduceHead' :: Term -> ReduceM (Blocked Term)

-- | Apply a definition using the compiled clauses, or fall back to
--   ordinary clauses if no compiled clauses exist.
appDef_ :: QName -> Term -> [Clause] -> Maybe CompiledClauses -> MaybeReducedArgs -> ReduceM (Reduced (Blocked Term) Term)
appDefE_ :: QName -> Term -> [Clause] -> Maybe CompiledClauses -> MaybeReducedElims -> ReduceM (Reduced (Blocked Term) Term)

-- | Apply a defined function to it's arguments, using the compiled
--   clauses. The original term is the first argument applied to the third.
appDef :: Term -> CompiledClauses -> MaybeReducedArgs -> ReduceM (Reduced (Blocked Term) Term)
appDefE :: Term -> CompiledClauses -> MaybeReducedElims -> ReduceM (Reduced (Blocked Term) Term)

-- | Apply a defined function to it's arguments, using the original
--   clauses.
appDef' :: Term -> [Clause] -> MaybeReducedArgs -> ReduceM (Reduced (Blocked Term) Term)
appDefE' :: Term -> [Clause] -> MaybeReducedElims -> ReduceM (Reduced (Blocked Term) Term)

-- | Only unfold definitions if this leads to simplification which means
--   that a constructor/literal pattern is matched.
class Simplify t
simplify' :: Simplify t => t -> ReduceM t
simplifyBlocked' :: Simplify t => Blocked t -> ReduceM t
class Normalise t
normalise' :: Normalise t => t -> ReduceM t

-- | <tt>instantiateFull'</tt> <a>instantiate</a>s metas everywhere (and
--   recursively) but does not <a>reduce</a>.
class InstantiateFull t
instantiateFull' :: InstantiateFull t => t -> ReduceM t
instance InstantiateFull a => InstantiateFull (Maybe a)
instance InstantiateFull QName
instance InstantiateFull a => InstantiateFull (Builtin a)
instance InstantiateFull Interface
instance InstantiateFull Clause
instance InstantiateFull CompiledClauses
instance InstantiateFull a => InstantiateFull (Case a)
instance InstantiateFull a => InstantiateFull (WithArity a)
instance InstantiateFull FunctionInverse
instance InstantiateFull Defn
instance InstantiateFull DisplayTerm
instance InstantiateFull DisplayForm
instance InstantiateFull a => InstantiateFull (Open a)
instance InstantiateFull RewriteRule
instance InstantiateFull Definition
instance InstantiateFull Char
instance (Subst a, InstantiateFull a) => InstantiateFull (Tele a)
instance InstantiateFull Section
instance InstantiateFull Signature
instance InstantiateFull Scope
instance InstantiateFull ModuleName
instance (Eq k, Hashable k, InstantiateFull e) => InstantiateFull (HashMap k e)
instance (Ord k, InstantiateFull e) => InstantiateFull (Map k e)
instance InstantiateFull Elim
instance InstantiateFull Constraint
instance InstantiateFull ProblemConstraint
instance InstantiateFull a => InstantiateFull (Closure a)
instance (InstantiateFull a, InstantiateFull b, InstantiateFull c) => InstantiateFull (a, b, c)
instance (InstantiateFull a, InstantiateFull b) => InstantiateFull (a, b)
instance InstantiateFull t => InstantiateFull [t]
instance InstantiateFull t => InstantiateFull (Dom t)
instance InstantiateFull t => InstantiateFull (Named name t)
instance InstantiateFull t => InstantiateFull (Arg t)
instance (Subst t, InstantiateFull t) => InstantiateFull (Abs t)
instance InstantiateFull ClauseBody
instance InstantiateFull Pattern
instance InstantiateFull Bool
instance InstantiateFull Substitution
instance InstantiateFull LevelAtom
instance InstantiateFull PlusLevel
instance InstantiateFull Level
instance InstantiateFull Term
instance InstantiateFull Type
instance InstantiateFull Sort
instance InstantiateFull Name
instance Normalise a => Normalise (Maybe a)
instance (Ord k, Normalise e) => Normalise (Map k e)
instance Normalise DisplayForm
instance Normalise Pattern
instance Normalise Bool
instance Normalise Constraint
instance Normalise ProblemConstraint
instance (Subst a, Normalise a) => Normalise (Tele a)
instance Normalise a => Normalise (Closure a)
instance (Normalise a, Normalise b, Normalise c) => Normalise (a, b, c)
instance (Normalise a, Normalise b) => Normalise (a, b)
instance Normalise t => Normalise [t]
instance Normalise t => Normalise (Dom t)
instance Normalise t => Normalise (Named name t)
instance Normalise t => Normalise (Arg t)
instance (Subst t, Normalise t) => Normalise (Abs t)
instance Normalise ClauseBody
instance Normalise LevelAtom
instance Normalise PlusLevel
instance Normalise Level
instance Normalise Elim
instance Normalise Term
instance Normalise Type
instance Normalise Sort
instance Simplify DisplayForm
instance Simplify ClauseBody
instance Simplify Pattern
instance Simplify Bool
instance Simplify Constraint
instance Simplify ProblemConstraint
instance (Subst a, Simplify a) => Simplify (Tele a)
instance Simplify a => Simplify (Closure a)
instance (Simplify a, Simplify b, Simplify c) => Simplify (a, b, c)
instance (Simplify a, Simplify b) => Simplify (a, b)
instance Simplify a => Simplify (Maybe a)
instance (Ord k, Simplify e) => Simplify (Map k e)
instance Simplify t => Simplify [t]
instance Simplify t => Simplify (Dom t)
instance Simplify t => Simplify (Named name t)
instance Simplify t => Simplify (Arg t)
instance (Subst t, Simplify t) => Simplify (Abs t)
instance Simplify LevelAtom
instance Simplify PlusLevel
instance Simplify Level
instance Simplify Sort
instance Simplify Elim
instance Simplify Type
instance Simplify Term
instance (Ord k, Reduce e) => Reduce (Map k e)
instance Reduce Constraint
instance Reduce Telescope
instance Reduce a => Reduce (Closure a)
instance Reduce Term
instance (Reduce a, Reduce b, Reduce c) => Reduce (a, b, c)
instance (Reduce a, Reduce b) => Reduce (a, b)
instance Reduce t => Reduce (Dom t)
instance Reduce t => Reduce (Arg t)
instance Reduce t => Reduce [t]
instance (Subst t, Reduce t) => Reduce (Abs t)
instance Reduce LevelAtom
instance Reduce PlusLevel
instance Reduce Level
instance Reduce Elim
instance Reduce Sort
instance Reduce Type
instance (Ord k, Instantiate e) => Instantiate (Map k e)
instance Instantiate Constraint
instance Instantiate Telescope
instance Instantiate a => Instantiate (Closure a)
instance (Instantiate a, Instantiate b, Instantiate c) => Instantiate (a, b, c)
instance (Instantiate a, Instantiate b) => Instantiate (a, b)
instance Instantiate t => Instantiate [t]
instance Instantiate t => Instantiate (Dom t)
instance Instantiate t => Instantiate (Arg t)
instance Instantiate t => Instantiate (Abs t)
instance Instantiate Elim
instance Instantiate Sort
instance Instantiate Type
instance Instantiate a => Instantiate (Blocked a)
instance Instantiate LevelAtom
instance Instantiate PlusLevel
instance Instantiate Level
instance Instantiate Term

module Agda.TypeChecking.Telescope
data OutputTypeName
OutputTypeName :: QName -> OutputTypeName
OutputTypeNameNotYetKnown :: OutputTypeName
NoOutputTypeName :: OutputTypeName

-- | Strips all Pi's and return the head definition name, if possible.
getOutputTypeName :: Type -> TCM OutputTypeName

-- | The permutation should permute the corresponding telescope.
--   (left-to-right list)
renameP :: Subst t => Permutation -> t -> t

-- | If <tt>permute π : [a]Γ -&gt; [a]Δ</tt>, then <tt>applySubst (renaming
--   π) : Term Γ -&gt; Term Δ</tt>
renaming :: Permutation -> Substitution

-- | If <tt>permute π : [a]Γ -&gt; [a]Δ</tt>, then <tt>substs (renamingR π)
--   : Term Δ -&gt; Term Γ</tt>
renamingR :: Permutation -> Substitution

-- | Flatten telescope: (Γ : Tel) -&gt; [Type Γ]
flattenTel :: Telescope -> [Dom Type]

-- | Order a flattened telescope in the correct dependeny order: Γ -&gt;
--   Permutation (Γ -&gt; Γ~)
--   
--   Since <tt>reorderTel tel</tt> uses free variable analysis of type in
--   <tt>tel</tt>, the telescope should be <a>normalise</a>d.
reorderTel :: [Dom Type] -> Maybe Permutation
reorderTel_ :: [Dom Type] -> Permutation

-- | Unflatten: turns a flattened telescope into a proper telescope. Must
--   be properly ordered.
unflattenTel :: [ArgName] -> [Dom Type] -> Telescope

-- | Get the suggested names from a telescope
teleNames :: Telescope -> [ArgName]
teleArgNames :: Telescope -> [Arg ArgName]
teleArgs :: Telescope -> Args

-- | A telescope split in two.
data SplitTel
SplitTel :: Telescope -> Telescope -> Permutation -> SplitTel
firstPart :: SplitTel -> Telescope
secondPart :: SplitTel -> Telescope

-- | The permutation takes us from the original telescope to <tt>firstPart
--   ++ secondPart</tt>.
splitPerm :: SplitTel -> Permutation

-- | Split a telescope into the part that defines the given variables and
--   the part that doesn't.
--   
--   See <a>prop_splitTelescope</a>.
splitTelescope :: VarSet -> Telescope -> SplitTel
telView :: Type -> TCM TelView

-- | <tt>telViewUpTo n t</tt> takes off the first <tt>n</tt> function types
--   of <tt>t</tt>. Takes off all if <tt>n &lt; 0</tt>.
telViewUpTo :: Int -> Type -> TCM TelView

-- | <tt>telViewUpTo' n p t</tt> takes off $t$ the first <tt>n</tt> (or
--   arbitrary many if <tt>n &lt; 0</tt>) function domains as long as they
--   satify <tt>p</tt>.
telViewUpTo' :: Int -> (Dom Type -> Bool) -> Type -> TCM TelView

-- | A safe variant of piApply.
piApplyM :: Type -> Args -> TCM Type
addTypedInstance :: QName -> Type -> TCM ()
resolveUnknownInstanceDefs :: TCM ()

-- | Try to solve the instance definitions whose type is not yet known,
--   report an error if it doesn't work and return the instance table
--   otherwise.
getInstanceDefs :: TCM InstanceTable

module Agda.TypeChecking.Datatypes

-- | Get true constructor with record fields.
getConHead :: QName -> TCM ConHead

-- | Get true constructor as term.
getConTerm :: QName -> TCM Term

-- | Get true constructor with fields, expanding literals to constructors
--   if possible.
getConForm :: QName -> TCM ConHead

-- | Augment constructor with record fields (preserve constructor name).
--   The true constructor might only surface via <tt>reduce</tt>.
getOrigConHead :: QName -> TCM ConHead

-- | Analogous to <a>getConTerm</a>.
getOrigConTerm :: QName -> TCM Term

-- | Get the name of the datatype constructed by a given constructor.
--   Precondition: The argument must refer to a constructor
getConstructorData :: HasConstInfo m => QName -> m QName

-- | <tt>getConType c t</tt> computes the constructor parameters from type
--   <tt>t</tt> and returns the instantiated type of constructor
--   <tt>c</tt>. <tt>Nothing</tt> if <tt>t</tt> is not a data/record type
--   or does not have a constructor <tt>c</tt>. Precondition: <tt>t</tt> is
--   reduced.
getConType :: ConHead -> Type -> TCM (Maybe Type)

-- | Return the number of non-parameter arguments to a data constructor, or
--   the field names of a record constructor.
--   
--   For getting just the arity of constructor <tt>c</tt>, use <tt>either
--   id size <a>$</a> getConstructorArity c</tt>.
getConstructorArity :: QName -> TCM (Either Nat [Arg QName])

-- | Check if a name refers to a datatype or a record with a named
--   constructor.
isDatatype :: QName -> TCM Bool
data DataOrRecord
IsData :: DataOrRecord
IsRecord :: DataOrRecord

-- | Check if a name refers to a datatype or a record.
isDataOrRecordType :: QName -> TCM (Maybe DataOrRecord)

-- | Precodition: <a>Term</a> is <tt>reduce</tt>d.
isDataOrRecord :: Term -> TCM (Maybe QName)
getNumberOfParameters :: QName -> TCM (Maybe Nat)
instance Eq DataOrRecord
instance Ord DataOrRecord
instance Show DataOrRecord

module Agda.TypeChecking.Tests

-- | <pre>
--   telFromList . telToList == id
--   </pre>
prop_telToListInv :: TermConfiguration -> Property

-- | All elements of <a>flattenTel</a> are well-scoped under the original
--   telescope.
prop_flattenTelScope :: TermConfiguration -> Property

-- | <pre>
--   unflattenTel . flattenTel == id
--   </pre>
prop_flattenTelInv :: TermConfiguration -> Property

-- | <a>reorderTel</a> is stable.
prop_reorderTelStable :: TermConfiguration -> Property

-- | The result of splitting a telescope is well-scoped.
prop_splitTelescopeScope :: TermConfiguration -> Property

-- | The permutation generated when splitting a telescope preserves
--   scoping.
prop_splitTelescopePermScope :: TermConfiguration -> Property
tests :: IO Bool


-- | Contains the state monad that the compiler works in and some functions
--   for tampering with the state.
module Agda.Compiler.Epic.CompileState

-- | Stuff we need in our compiler
data CompileState
CompileState :: [Var] -> Map TopLevelModuleName (EInterface, Set FilePath) -> EInterface -> EInterface -> String -> CompileState
nameSupply :: CompileState -> [Var]
compiledModules :: CompileState -> Map TopLevelModuleName (EInterface, Set FilePath)
curModule :: CompileState -> EInterface
importedModules :: CompileState -> EInterface
curFun :: CompileState -> String

-- | The initial (empty) state
initCompileState :: CompileState

-- | Compiler monad
type Compile = StateT CompileState

-- | When normal errors are not enough
epicError :: String -> Compile TCM a

-- | Modify the state of the current module's Epic Interface
modifyEI :: (EInterface -> EInterface) -> Compile TCM ()

-- | Get the state of the current module's Epic Interface
getsEI :: (EInterface -> a) -> Compile TCM a

-- | Returns the type of a definition given its name
getType :: QName -> Compile TCM Type

-- | Create a name which can be used in Epic code from a QName.
unqname :: QName -> Var
resetNameSupply :: Compile TCM ()
getDelayed :: QName -> Compile TCM Bool
putDelayed :: QName -> Bool -> Compile TCM ()
newName :: Compile TCM Var
putConstrTag :: QName -> Tag -> Compile TCM ()
assignConstrTag :: QName -> Compile TCM Tag
assignConstrTag' :: QName -> [QName] -> Compile TCM Tag
getConData :: QName -> Compile TCM QName
getDataCon :: QName -> Compile TCM [QName]
getConstrTag :: QName -> Compile TCM Tag
getConstrTag' :: QName -> Compile TCM (Maybe Tag)
addDefName :: QName -> Compile TCM ()
topBindings :: Compile TCM (Set Var)
getConArity :: QName -> Compile TCM Int
putConArity :: QName -> Int -> Compile TCM ()
putMain :: QName -> Compile TCM ()
getMain :: Compile TCM Var
lookInterface :: (EInterface -> Maybe a) -> Compile TCM a -> Compile TCM a
constrInScope :: QName -> Compile TCM Bool
getForcedArgs :: QName -> Compile TCM ForcedArgs
putForcedArgs :: QName -> ForcedArgs -> Compile TCM ()
replaceAt :: Int -> [a] -> [a] -> [a]

-- | Copy pasted from MAlonzo, HAHA!!! Move somewhere else!
constructorArity :: Num a => QName -> TCM a

-- | Bind an expression to a fresh variable name
bindExpr :: Expr -> (Var -> Compile TCM Expr) -> Compile TCM Expr
instance Show CompileState


-- | Perform simple optimisations based on case-laws
module Agda.Compiler.Epic.CaseOpts
caseOpts :: [Fun] -> Compile TCM [Fun]

-- | Run the case-opts on an expression
caseOptsExpr :: Expr -> Compile TCM Expr


-- | Remove forced arguments from constructors.
module Agda.Compiler.Epic.ForceConstrs

-- | Check which arguments are forced
makeForcedArgs :: Type -> ForcedArgs

-- | Remove forced arguments from constructors and branches
forceConstrs :: [Fun] -> Compile TCM [Fun]
forceFun :: Fun -> Compile TCM Fun


-- | Pretty-print the AuxAST to valid Epic code.
module Agda.Compiler.Epic.Epic

-- | Print a function to an Epic string
prettyEpicFun :: MonadTCM m => Fun -> Compile m String

-- | Print expression to Epic expression
prettyEpic :: Expr -> String


-- | Detect if a datatype could be represented as a primitive integer. If
--   it has one constructor with no arguments and one with a recursive
--   argument this is true. This is done using IrrFilters which filter out
--   forced arguments, so for example Fin becomes primitive.
module Agda.Compiler.Epic.NatDetection

-- | Get a list of all the datatypes that look like nats. The [QName] is on
--   the form [zeroConstr, sucConstr]
getNatish :: Compile TCM [(ForcedArgs, [QName])]
isNatish :: QName -> Defn -> Compile TCM (Maybe (ForcedArgs, [QName]))

-- | Count the number of relevant arguments
nrRel :: ForcedArgs -> Integer

-- | Check if argument n is recursive
isRec :: Int -> Type -> QName -> Bool
argIsDef :: Type -> QName -> Bool


-- | Change constructors and cases on builtins and natish datatypes to use
--   primitive data
module Agda.Compiler.Epic.Primitive
data PrimTransform
PrimTF :: Map QName Var -> (Expr -> [Branch] -> Expr) -> PrimTransform
mapCon :: PrimTransform -> Map QName Var
translateCase :: PrimTransform -> Expr -> [Branch] -> Expr
prZero :: Var
prNatEquality :: Var
prPred :: Var
prFalse :: Var
prTrue :: Var
prSuc :: Var

-- | Change constructors and cases on builtins and natish datatypes to use
--   primitive data
primitivise :: [Fun] -> Compile TCM [Fun]

-- | Map primitive constructors to primitive tags
initialPrims :: Compile TCM ()

-- | Build transforms using the names of builtins
getBuiltins :: Compile TCM [PrimTransform]
defName :: Term -> QName

-- | Translation to primitive integer functions
natPrimTF :: ForcedArgs -> [QName] -> PrimTransform

-- | Corresponds to a case for natural numbers
primNatCaseZS :: Expr -> Expr -> Var -> Expr -> Expr

-- | Corresponds to a case with a zero and default branch
primNatCaseZD :: Expr -> Expr -> Expr -> Expr

-- | Translation to primitive bool functions
boolPrimTF :: [QName] -> PrimTransform

-- | Change all the primitives in the function using the PrimTransform
primFun :: [PrimTransform] -> Fun -> Compile TCM Fun

-- | Change all the primitives in an expression using PrimTransform
primExpr :: [PrimTransform] -> Expr -> Compile TCM Expr

module Agda.TypeChecking.Level
data LevelKit
LevelKit :: Term -> (Term -> Term) -> (Term -> Term -> Term) -> Term -> QName -> QName -> QName -> QName -> LevelKit
lvlType :: LevelKit -> Term
lvlSuc :: LevelKit -> Term -> Term
lvlMax :: LevelKit -> Term -> Term -> Term
lvlZero :: LevelKit -> Term
typeName :: LevelKit -> QName
sucName :: LevelKit -> QName
maxName :: LevelKit -> QName
zeroName :: LevelKit -> QName

-- | Get the 'primLevel as a <a>Term</a>, if present.
mlevel :: TCM (Maybe Term)

-- | Get the <a>primLevel</a> as a <a>Type</a>.
levelType :: TCM Type
levelSucFunction :: TCM (Term -> Term)
builtinLevelKit :: TCM (Maybe LevelKit)

-- | Raises an error if no level kit is available.
requireLevels :: TCM LevelKit
unLevel :: Term -> TCM Term
reallyUnLevelView :: MonadTCM tcm => Level -> tcm Term
unlevelWithKit :: LevelKit -> Level -> Term
unPlusV :: Term -> (Term -> Term) -> PlusLevel -> Term
maybePrimCon :: TCM Term -> TCM (Maybe ConHead)
maybePrimDef :: TCM Term -> TCM (Maybe QName)
levelView :: Term -> TCM Level
levelView' :: Term -> ReduceM Level
levelLub :: Level -> Level -> Level

module Agda.TypeChecking.DisplayForm

-- | Find a matching display form for <tt>q vs</tt>. In essence this tries
--   to reqwrite <tt>q vs</tt> with any display form <tt>q ps --&gt;
--   dt</tt> and returns the instantiated <tt>dt</tt> if successful. First
--   match wins.
displayForm :: QName -> Args -> TCM (Maybe DisplayTerm)

-- | Match a <a>DisplayForm</a> <tt>q ps = v</tt> against <tt>q vs</tt>.
--   Return the <a>DisplayTerm</a> <tt>v[us]</tt> if the match was
--   successful, i.e., <tt>vs / ps = Just us</tt>.
matchDisplayForm :: DisplayForm -> Args -> MaybeT TCM DisplayTerm

-- | Class <tt>Match</tt> for matching a term <tt>p</tt> in the role of a
--   pattern against a term <tt>v</tt>.
--   
--   The 0th variable in <tt>p</tt> plays the role of a place holder
--   (pattern variable). Each occurrence of <tt>var 0</tt> in <tt>p</tt>
--   stands for a different pattern variable.
--   
--   The result of matching, if successful, is a list of solutions for the
--   pattern variables, in left-to-right order.
--   
--   The 0th variable is in scope in the input <tt>v</tt>, but should not
--   actually occur! In the output solution, the <tt>0th</tt> variable is
--   no longer in scope. (It has been substituted by <b>IMPOSSIBLE</b>
--   which corresponds to a raise by -1).
class Match a
match :: Match a => a -> a -> MaybeT TCM [Term]
instance Match Level
instance Match Sort
instance Match Term
instance Match a => Match (Elim' a)
instance Match a => Match (Arg a)
instance Match a => Match [a]


-- | Translating from internal syntax to abstract syntax. Enables nice
--   pretty printing of internal syntax.
--   
--   TODO
--   
--   <ul>
--   <li>numbers on metas</li>
--   <li>fake dependent functions to independent functions</li>
--   <li>meta parameters</li>
--   <li>shadowing</li>
--   </ul>
module Agda.Syntax.Translation.InternalToAbstract
class Reify i a | i -> a where reifyWhen _ = reify
reify :: Reify i a => i -> TCM a
reifyWhen :: Reify i a => Bool -> i -> TCM a
type NamedClause = QNamed Clause
reifyPatterns :: Telescope -> Permutation -> [NamedArg Pattern] -> TCM [NamedArg Pattern]
instance Show DotBind
instance Eq DoBind
instance Show DoBind
instance (Reify t t', Reify a a') => Reify (Judgement t a) (Judgement t' a')
instance (Reify i1 a1, Reify i2 a2, Reify i3 a3, Reify i4 a4) => Reify (i1, i2, i3, i4) (a1, a2, a3, a4)
instance (Reify i1 a1, Reify i2 a2, Reify i3 a3) => Reify (i1, i2, i3) (a1, a2, a3)
instance (Reify i1 a1, Reify i2 a2) => Reify (i1, i2) (a1, a2)
instance Reify i a => Reify [i] [a]
instance Reify i a => Reify (Dom i) (Arg a)
instance Reify ArgInfo ArgInfo
instance Reify Telescope Telescope
instance (Free i, Reify i a) => Reify (Abs i) (Name, a)
instance Reify Level Expr
instance Reify Sort Expr
instance Reify Type Expr
instance Reify NamedClause Clause
instance DotVars TypedBinding
instance DotVars TypedBindings
instance DotVars RHS
instance DotVars Expr
instance DotVars Pattern
instance DotVars Clause
instance (DotVars a, DotVars b) => DotVars (a, b)
instance DotVars a => DotVars [a]
instance DotVars a => DotVars (Named s a)
instance DotVars a => DotVars (Arg a)
instance (Ord k, Monoid v) => Monoid (MonoidMap k v)
instance Reify ClauseBody RHS
instance Reify Elim Expr
instance Reify i a => Reify (Arg i) (Arg a)
instance Reify i a => Reify (Named n i) (Named n a)
instance Reify Term Expr
instance Reify Literal Expr
instance Reify DisplayTerm Expr
instance Reify MetaId Expr
instance Reify Expr Expr
instance Reify Name Name
instance Underscore Expr

module Agda.TypeChecking.Pretty
type Doc = Doc
empty :: TCM Doc
equals :: TCM Doc
colon :: TCM Doc
comma :: TCM Doc
pretty :: Pretty a => a -> TCM Doc
prettyA :: (Pretty c, ToConcrete a c) => a -> TCM Doc
prettyAs :: (Pretty c, ToConcrete a [c]) => a -> TCM Doc
text :: String -> TCM Doc
pwords :: String -> [TCM Doc]
fwords :: String -> TCM Doc
sep :: [TCM Doc] -> TCM Doc
vcat :: [TCM Doc] -> TCM Doc
hcat :: [TCM Doc] -> TCM Doc
hsep :: [TCM Doc] -> TCM Doc
fsep :: [TCM Doc] -> TCM Doc
($$) :: TCM Doc -> TCM Doc -> TCM Doc
(<+>) :: TCM Doc -> TCM Doc -> TCM Doc
(<>) :: TCM Doc -> TCM Doc -> TCM Doc
($+$) :: TCM Doc -> TCM Doc -> TCM Doc
nest :: Int -> TCM Doc -> TCM Doc
braces :: TCM Doc -> TCM Doc
parens :: TCM Doc -> TCM Doc
brackets :: TCM Doc -> TCM Doc
dbraces :: TCM Doc -> TCM Doc
prettyList :: [TCM Doc] -> TCM Doc
punctuate :: TCM Doc -> [TCM Doc] -> [TCM Doc]
class PrettyTCM a
prettyTCM :: PrettyTCM a => a -> TCM Doc
newtype PrettyContext
PrettyContext :: Context -> PrettyContext
instance PrettyTCM RewriteRule
instance PrettyTCM Pattern
instance PrettyTCM Context
instance PrettyTCM PrettyContext
instance PrettyTCM Telescope
instance PrettyTCM ConHead
instance PrettyTCM ModuleName
instance PrettyTCM QName
instance PrettyTCM Name
instance PrettyTCM Literal
instance PrettyTCM TypeCheckingProblem
instance PrettyTCM Constraint
instance PrettyTCM ProblemConstraint
instance PrettyTCM Comparison
instance PrettyTCM Relevance
instance PrettyTCM Name
instance PrettyTCM Expr
instance PrettyTCM a => PrettyTCM (MaybeReduced a)
instance PrettyTCM Elim
instance (Reify a e, ToConcrete e c, Pretty c) => PrettyTCM (Dom a)
instance (Reify a e, ToConcrete e c, Pretty c) => PrettyTCM (Arg a)
instance (Reify a e, ToConcrete e c, Pretty c) => PrettyTCM (Named_ a)
instance PrettyTCM a => PrettyTCM (Blocked a)
instance PrettyTCM MetaId
instance (PrettyTCM a, PrettyTCM b) => PrettyTCM (Judgement a b)
instance PrettyTCM ClauseBody
instance PrettyTCM Range
instance PrettyTCM Interval
instance PrettyTCM Position
instance PrettyTCM Permutation
instance PrettyTCM Level
instance PrettyTCM NamedClause
instance PrettyTCM DisplayTerm
instance PrettyTCM Sort
instance PrettyTCM Type
instance PrettyTCM Term
instance PrettyTCM Bool
instance PrettyTCM Nat
instance (PrettyTCM a, PrettyTCM b) => PrettyTCM (a, b)
instance PrettyTCM a => PrettyTCM [a]
instance PrettyTCM a => PrettyTCM (Closure a)

module Agda.TypeChecking.Errors
prettyError :: MonadTCM tcm => TCErr -> tcm String
class PrettyTCM a
prettyTCM :: PrettyTCM a => a -> TCM Doc
tcErrString :: TCErr -> String

-- | Warnings.
--   
--   Invariant: The fields are never empty at the same time.
data Warnings
Warnings :: [Range] -> Constraints -> Warnings

-- | Meta-variable problems are reported as type errors unless
--   <tt>optAllowUnsolved</tt> is <a>True</a>.
unsolvedMetaVariables :: Warnings -> [Range]

-- | Same as <a>unsolvedMetaVariables</a>.
unsolvedConstraints :: Warnings -> Constraints

-- | Turns warnings into an error. Even if several errors are possible only
--   one is raised.
warningsToError :: Warnings -> TCM a
instance Verbalize a => Verbalize (Indefinite a)
instance Verbalize Relevance
instance Verbalize Hiding
instance PrettyTCM Call
instance PrettyTCM SplitError
instance PrettyUnequal Type
instance PrettyUnequal Term
instance PrettyTCM TypeError
instance PrettyTCM CallInfo
instance PrettyTCM TCErr

module Agda.TypeChecking.Records

-- | Order the fields of a record construction. Use the second argument for
--   missing fields.
orderFields :: QName -> a -> [Name] -> [(Name, a)] -> TCM [a]

-- | The name of the module corresponding to a record.
recordModule :: QName -> ModuleName

-- | Get the definition for a record. Throws an exception if the name does
--   not refer to a record or the record is abstract.
getRecordDef :: QName -> TCM Defn

-- | Get the record name belonging to a field name.
getRecordOfField :: QName -> TCM (Maybe QName)

-- | Get the field names of a record.
getRecordFieldNames :: QName -> TCM [Arg Name]
recordFieldNames :: Defn -> [Arg Name]

-- | Find all records with at least the given fields.
findPossibleRecords :: [Name] -> TCM [QName]

-- | Get the field types of a record.
getRecordFieldTypes :: QName -> TCM Telescope

-- | Get the field names belonging to a record type.
getRecordTypeFields :: Type -> TCM [Arg QName]

-- | Get the type of the record constructor.
getRecordConstructorType :: QName -> TCM Type

-- | Returns the given record type's constructor name (with an empty
--   range).
getRecordConstructor :: QName -> TCM ConHead

-- | Check if a name refers to a record. If yes, return record definition.
isRecord :: HasConstInfo m => QName -> m (Maybe Defn)

-- | Reduce a type and check whether it is a record type. Succeeds only if
--   type is not blocked by a meta var. If yes, return its name,
--   parameters, and definition.
isRecordType :: Type -> TCM (Maybe (QName, Args, Defn))

-- | Reduce a type and check whether it is a record type. Succeeds only if
--   type is not blocked by a meta var. If yes, return its name,
--   parameters, and definition. If no, return the reduced type (unless it
--   is blocked).
tryRecordType :: Type -> TCM (Either (Maybe Type) (QName, Args, Defn))

-- | The analogue of <a>piApply</a>. If <tt>v</tt> is a value of record
--   type <tt>T</tt> with field <tt>f</tt>, then <tt>projectType T f</tt>
--   returns the type of <tt>f v</tt>.
projectType :: Type -> QName -> TCM (Maybe Type)

-- | Check if a name refers to an eta expandable record.
isEtaRecord :: HasConstInfo m => QName -> m Bool
isEtaCon :: HasConstInfo m => QName -> m Bool

-- | Check if a name refers to a record which is not coinductive.
--   (Projections are then size-preserving)
isInductiveRecord :: QName -> TCM Bool

-- | Check if a type is an eta expandable record and return the record
--   identifier and the parameters.
isEtaRecordType :: Type -> TCM (Maybe (QName, Args))

-- | Check if a name refers to a record constructor. If yes, return record
--   definition.
isRecordConstructor :: QName -> TCM (Maybe (QName, Defn))

-- | Check if a constructor name is the internally generated record
--   constructor.
isGeneratedRecordConstructor :: QName -> TCM Bool

-- | Mark record type as unguarded. No eta-expansion. Projections do not
--   preserve guardedness.
unguardedRecord :: QName -> TCM ()

-- | Mark record type as recursive. Projections do not preserve
--   guardedness.
recursiveRecord :: QName -> TCM ()

-- | Check whether record type is marked as recursive.
--   
--   Precondition: record type identifier exists in signature.
isRecursiveRecord :: QName -> TCM Bool

-- | Version of <tt>recRecursive</tt> with proper internal error.
recRecursive_ :: Defn -> Bool

-- | <pre>
--   etaExpandBoundVar i = (Δ, σ, τ)
--   </pre>
--   
--   Precondition: The current context is <tt>Γ = Γ₁, x:R pars, Γ₂</tt>
--   where <tt>|Γ₂| = i</tt> and <tt>R</tt> is a eta-expandable record type
--   with constructor <tt>c</tt> and fields <tt>Γ'</tt>.
--   
--   Postcondition: <tt>Δ = Γ₁, Γ', Γ₂[c Γ']</tt> and <tt>Γ ⊢ σ : Δ</tt>
--   and <tt>Δ ⊢ τ : Γ</tt>.
etaExpandBoundVar :: Int -> TCM (Maybe (Telescope, Substitution, Substitution))

-- | <pre>
--   curryAt v (Γ (y : R pars) -&gt; B) n =
--        (  v -&gt; λ Γ ys → v Γ (c ys)            {- curry   -}
--        ,  v -&gt; λ Γ y → v Γ (p1 y) ... (pm y)  {- uncurry -}
--        , Γ (ys : As) → B[c ys / y]
--        )
--   </pre>
--   
--   where <tt>n = size Γ</tt>.
curryAt :: Type -> Int -> TCM (Term -> Term, Term -> Term, Type)

-- | <tt>etaExpand r pars u</tt> computes the eta expansion of record value
--   <tt>u</tt> at record type <tt>r pars</tt>.
--   
--   The first argument <tt>r</tt> should be the name of a record type.
--   Given
--   
--   <pre>
--   record R : Set where field x : A; y : B; .z : C
--   </pre>
--   
--   and <tt>r : R</tt>,
--   
--   <pre>
--   etaExpand R [] r = (tel, [R.x r, R.y r, R.z r])
--   </pre>
--   
--   where <tt>tel</tt> is the record telescope instantiated at the
--   parameters <tt>pars</tt>.
etaExpandRecord :: QName -> Args -> Term -> TCM (Telescope, Args)
etaExpandRecord_ :: QName -> Args -> Defn -> Term -> TCM (Telescope, ConHead, Args)
etaExpandAtRecordType :: Type -> Term -> TCM (Telescope, Term)

-- | The fields should be eta contracted already.
--   
--   We can eta contract if all fields <tt>f = ...</tt> are irrelevant or
--   all fields <tt>f</tt> are the projection <tt>f v</tt> of the same
--   value <tt>v</tt>, but we need at least one relevant field to find the
--   value <tt>v</tt>.
--   
--   TODO: this can be moved out of TCM (but only if ConHead stores also
--   the Arg-decoration of the record fields.
etaContractRecord :: HasConstInfo m => QName -> ConHead -> Args -> m Term

-- | Is the type a hereditarily singleton record type? May return a
--   blocking metavariable.
--   
--   Precondition: The name should refer to a record type, and the
--   arguments should be the parameters to the type.
isSingletonRecord :: QName -> Args -> TCM (Either MetaId Bool)
isSingletonRecordModuloRelevance :: QName -> Args -> TCM (Either MetaId Bool)

-- | Return the unique (closed) inhabitant if exists. In case of counting
--   irrelevance in, the returned inhabitant contains garbage.
isSingletonRecord' :: Bool -> QName -> Args -> TCM (Either MetaId (Maybe Term))

-- | Check whether a type has a unique inhabitant and return it. Can be
--   blocked by a metavar.
isSingletonType :: Type -> TCM (Either MetaId (Maybe Term))

-- | Check whether a type has a unique inhabitant (irrelevant parts
--   ignored). Can be blocked by a metavar.
isSingletonTypeModuloRelevance :: MonadTCM tcm => Type -> tcm (Either MetaId Bool)
isSingletonType' :: Bool -> Type -> TCM (Either MetaId (Maybe Term))

-- | Auxiliary function.
emap :: (a -> b) -> Either c (Maybe a) -> Either c (Maybe b)


-- | Translating Agda types to Haskell types. Used to ensure that imported
--   Haskell functions have the right type.
module Agda.Compiler.HaskellTypes
type HaskellKind = String
hsStar :: HaskellKind
hsKFun :: HaskellKind -> HaskellKind -> HaskellKind
hsFun :: HaskellKind -> HaskellKind -> HaskellKind
hsUnit :: HaskellType
hsVar :: Name -> HaskellType
hsApp :: String -> [HaskellType] -> HaskellType
hsForall :: String -> HaskellType -> HaskellType
notAHaskellKind :: Type -> TCM a
notAHaskellType :: Type -> TCM a
getHsType :: QName -> TCM HaskellType
getHsVar :: Nat -> TCM HaskellCode
isHaskellKind :: Type -> TCM Bool
haskellKind :: Type -> TCM HaskellKind

-- | Note that <tt>Inf a b</tt>, where <tt>Inf</tt> is the INFINITY
--   builtin, is translated to <tt><a>of b</a></tt> (assuming that all
--   coinductive builtins are defined).
--   
--   Note that if <tt>haskellType</tt> supported universe polymorphism then
--   the special treatment of INFINITY might not be needed.
haskellType :: Type -> TCM HaskellType


-- | Some arguments to functions (types in particular) will not be used in
--   the body. Wouldn't it be useful if these wasn't passed around at all?
--   Fear not, we here perform some analysis and try to remove as many of
--   these occurences as possible.
--   
--   We employ the worker/wrapper transform, so if f x1 .. xn = e and we
--   notice that some is not needed we create: f' xj .. xk = e [xi := unit]
--   and f x1 .. xn = f' xj .. xk. i.e we erase them in f' and replace by
--   unit, and the original f function calls the new f'. The idea is that f
--   should be inlined and then peace on earth.
module Agda.Compiler.Epic.Erasure
isIrr :: Relevance -> Bool
isRel :: Relevance -> Bool

-- | Relevance "or"
(||-) :: Relevance -> Relevance -> Relevance

-- | Relevance "and"
(&&-) :: Relevance -> Relevance -> Relevance
data ErasureState
ErasureState :: Map Var [Relevance] -> Map Var Fun -> ErasureState
relevancies :: ErasureState -> Map Var [Relevance]
funs :: ErasureState -> Map Var Fun
type Erasure = StateT ErasureState

-- | Try to find as many unused variables as possible
erasure :: [Fun] -> Compile TCM [Fun]
removeUnused :: Map Var [Relevance] -> Expr -> Expr

-- | Initiate a function's relevancies
initiate :: Fun -> Erasure (Compile TCM) ()
initialRels :: Type -> Relevance -> [Relevance]
ignoreForced :: Relevance -> Bool

-- | Calculate if a variable is relevant in an expression
relevant :: (Functor m, Monad m) => Var -> Expr -> Erasure m Relevance

-- | Try to find a fixpoint for all the functions relevance.
step :: Integer -> Erasure (Compile TCM) (Map Var [Relevance])
diff :: (Ord k, Eq a) => Map k a -> Map k a -> [(k, (a, a))]

module Agda.Compiler.Epic.Injection

-- | Find potentially injective functions, solve constraints to fix some
--   constructor tags and make functions whose constraints are fulfilled
--   injections
findInjection :: [(QName, Definition)] -> Compile TCM [(QName, Definition)]
replaceFunCC :: QName -> CompiledClauses -> Compile TCM ()

-- | If the pairs of constructor names have the same tags, the function is
--   injective. If Nothing, the function is not injective.
type InjConstraints = Maybe [(QName, QName)]
isInjective :: QName -> [Clause] -> Compile TCM (Maybe ((QName, InjectiveFun), [(QName, QName)]))
patternToTerm :: Nat -> Pattern -> Term
nrBinds :: Num i => Pattern -> i
substForDot :: [NamedArg Pattern] -> Substitution
isInjectiveHere :: QName -> Int -> Clause -> Compile TCM InjConstraints

-- | Turn NATURAL literal n into suc^n zero.
litToCon :: Literal -> TCM Term
litInt :: Literal -> Bool
insertAt :: (Nat, Term) -> Term -> Term
solve :: [QName] -> [((QName, InjectiveFun), [(QName, QName)])] -> Compile TCM [(QName, InjectiveFun)]
emptyC :: InjConstraints
addConstraint :: QName -> QName -> InjConstraints -> InjConstraints
unionConstraints :: [InjConstraints] -> InjConstraints

-- | Are two terms injectible? Tries to find a mapping between constructors
--   that equates the terms.
--   
--   Precondition: t1 is normalised, t2 is in WHNF When reducing t2, it may
--   become a literal, which makes this not work in some cases...
class Injectible a
(<:) :: Injectible a => a -> a -> ReaderT (Map QName InjectiveFun) (Compile TCM) InjConstraints
data TagEq
Same :: Int -> TagEq
IsTag :: Tag -> TagEq
data Tags
Tags :: IntMap (Set QName) -> Map QName TagEq -> Tags
eqGroups :: Tags -> IntMap (Set QName)
constrGroup :: Tags -> Map QName TagEq
initialTags :: Map QName Tag -> [QName] -> Tags
unify :: QName -> QName -> Tags -> Compile TCM (Maybe Tags)
setTag :: Int -> Tag -> Tags -> Compile TCM (Maybe Tags)
mergeGroups :: Int -> Int -> Tags -> Compile TCM (Maybe Tags)
unifiable :: QName -> QName -> Compile TCM Bool
(!!!!) :: Ord k => Map k v -> k -> v
instance [overlap ok] Eq TagEq
instance [overlap ok] Injectible Term
instance [overlap ok] Injectible a => Injectible (Elim' a)
instance [overlap ok] Injectible a => Injectible [a]
instance [overlap ok] Injectible a => Injectible (Arg a)


-- | Smash functions which return something that can be inferred (something
--   of a type with only one element)
module Agda.Compiler.Epic.Smashing
defnPars :: Integral n => Defn -> n

-- | Main function, smash as much as possible
smash'em :: [Fun] -> Compile TCM [Fun]
(+++) :: Telescope -> Telescope -> Telescope

-- | Can a datatype be inferred? If so, return the only possible value.
inferable :: Set QName -> QName -> [Arg Term] -> Compile TCM (Maybe Expr)
inferableTerm :: Set QName -> Term -> Compile TCM (Maybe Expr)

-- | Find the only possible value for a certain type. If we fail return
--   Nothing
smashable :: Int -> Type -> Compile TCM (Maybe Expr)
buildLambda :: (Ord n, Num n) => n -> Expr -> Expr

module Agda.TypeChecking.Rules.LHS.Problem
type Substitution = [Maybe Term]
type FlexibleVars = [FlexibleVar Nat]

-- | When we encounter a flexible variable in the unifier, where did it
--   come from? The alternatives are ordered such that we will assign the
--   higher one first, i.e., first we try to assign a <tt>DotFlex</tt>,
--   then...
data FlexibleVarKind

-- | From a record pattern (<a>ConP</a>).
RecordFlex :: FlexibleVarKind

-- | From a hidden formal argument (<tt>ImplicitP</tt>).
ImplicitFlex :: FlexibleVarKind

-- | From a dot pattern (<a>DotP</a>).
DotFlex :: FlexibleVarKind

-- | Flexible variables are equipped with information where they come from,
--   in order to make a choice which one to assign when two flexibles are
--   unified.
data FlexibleVar a
FlexibleVar :: Hiding -> FlexibleVarKind -> a -> FlexibleVar a
flexHiding :: FlexibleVar a -> Hiding
flexKind :: FlexibleVar a -> FlexibleVarKind
flexVar :: FlexibleVar a -> a
defaultFlexibleVar :: a -> FlexibleVar a
flexibleVarFromHiding :: Hiding -> a -> FlexibleVar a

-- | State of typechecking a LHS; input to <tt>split</tt>. [Ulf Norell's
--   PhD, page. 35]
--   
--   In <tt>Problem ps p delta</tt>, <tt>ps</tt> are the user patterns of
--   supposed type <tt>delta</tt>. <tt>p</tt> is the pattern resulting from
--   the splitting.
data Problem' p
Problem :: [NamedArg Pattern] -> p -> Telescope -> ProblemRest -> Problem' p

-- | User patterns.
problemInPat :: Problem' p -> [NamedArg Pattern]

-- | Patterns after splitting.
problemOutPat :: Problem' p -> p

-- | Type of patterns.
problemTel :: Problem' p -> Telescope

-- | Patterns that cannot be typed yet.
problemRest :: Problem' p -> ProblemRest

-- | The permutation should permute <tt>allHoles</tt> of the patterns to
--   correspond to the abstract patterns in the problem.
type Problem = Problem' (Permutation, [NamedArg Pattern])
type ProblemPart = Problem' ()

-- | User patterns that could not be given a type yet.
--   
--   Example: <tt> f : (b : Bool) -&gt; if b then Nat else Nat -&gt; Nat f
--   true = zero f false zero = zero f false (suc n) = n </tt> In this
--   sitation, for clause 2, we construct an initial problem <tt>
--   problemInPat = [false] problemTel = (b : Bool) problemRest.restPats =
--   [zero] problemRest.restType = if b then Nat else Nat -&gt; Nat </tt>
--   As we instantiate <tt>b</tt> to <tt>false</tt>, the <a>restType</a>
--   reduces to <tt>Nat -&gt; Nat</tt> and we can move pattern
--   <tt>zero</tt> over to <tt>problemInPat</tt>.
data ProblemRest
ProblemRest :: [NamedArg Pattern] -> Arg Type -> ProblemRest

-- | List of user patterns which could not yet be typed.
restPats :: ProblemRest -> [NamedArg Pattern]

-- | Type eliminated by <a>restPats</a>. Can be <a>Irrelevant</a> to
--   indicate that we came by an irrelevant projection and, hence, the rhs
--   must be type-checked in irrelevant mode.
restType :: ProblemRest -> Arg Type
data Focus
Focus :: QName -> Bool -> [NamedArg Pattern] -> Range -> OneHolePatterns -> Int -> QName -> [Arg Term] -> [Arg Term] -> Type -> Focus
focusCon :: Focus -> QName

-- | Do we come from an implicit record pattern?
focusImplicit :: Focus -> Bool
focusConArgs :: Focus -> [NamedArg Pattern]
focusRange :: Focus -> Range
focusOutPat :: Focus -> OneHolePatterns

-- | Index of focused variable in the out patterns.
focusHoleIx :: Focus -> Int
focusDatatype :: Focus -> QName
focusParams :: Focus -> [Arg Term]
focusIndices :: Focus -> [Arg Term]

-- | Type of variable we are splitting, kept for record patterns.
focusType :: Focus -> Type
LitFocus :: Literal -> OneHolePatterns -> Int -> Type -> Focus

-- | Result of <tt>splitProblem</tt>: Determines position for the next
--   split.
data SplitProblem

-- | Split on constructor pattern.
Split :: ProblemPart -> [Name] -> Arg Focus -> Abs ProblemPart -> SplitProblem

-- | The typed user patterns left of the split position. Invariant:
--   <tt><a>problemRest</a> == empty</tt>.
splitLPats :: SplitProblem -> ProblemPart

-- | The as-bindings for the focus.
splitAsNames :: SplitProblem -> [Name]

-- | How to split the variable at the split position.
splitFocus :: SplitProblem -> Arg Focus

-- | The typed user patterns right of the split position.
splitRPats :: SplitProblem -> Abs ProblemPart

-- | Split on projection pattern.
SplitRest :: Arg QName -> Type -> SplitProblem

-- | The projection could be belonging to an irrelevant record field.
splitProjection :: SplitProblem -> Arg QName
splitRestType :: SplitProblem -> Type

-- | Put a typed pattern on the very left of a <tt>SplitProblem</tt>.
consSplitProblem :: NamedArg Pattern -> ArgName -> Dom Type -> SplitProblem -> SplitProblem
data SplitError
NothingToSplit :: SplitError

-- | <b>IMPOSSIBLE</b>, only there to make this instance of <a>Error</a>.
SplitPanic :: String -> SplitError
data DotPatternInst
DPI :: Expr -> Term -> (Dom Type) -> DotPatternInst
data AsBinding
AsB :: Name -> Term -> Type -> AsBinding

-- | State worked on during the main loop of checking a lhs.
data LHSState
LHSState :: Problem -> Substitution -> [DotPatternInst] -> [AsBinding] -> LHSState
lhsProblem :: LHSState -> Problem
lhsSubst :: LHSState -> Substitution
lhsDPI :: LHSState -> [DotPatternInst]
lhsAsB :: LHSState -> [AsBinding]
instance Eq FlexibleVarKind
instance Ord FlexibleVarKind
instance Show FlexibleVarKind
instance Eq a => Eq (FlexibleVar a)
instance Show a => Show (FlexibleVar a)
instance Functor FlexibleVar
instance Foldable FlexibleVar
instance Traversable FlexibleVar
instance Show ProblemRest
instance Show p => Show (Problem' p)
instance Null a => Null (Problem' a)
instance Null ProblemRest
instance Error SplitError
instance PrettyTCM AsBinding
instance PrettyTCM DotPatternInst
instance Subst AsBinding
instance Subst DotPatternInst
instance Subst (Problem' p)
instance Subst ProblemRest
instance Ord (FlexibleVar Nat)
instance LensHiding (FlexibleVar a)


-- | The monad for the termination checker.
--   
--   The termination monad <tt>TerM</tt> is an extension of the type
--   checking monad <a>TCM</a> by an environment with information needed by
--   the termination checker.
module Agda.Termination.Monad

-- | The mutual block we are checking.
--   
--   The functions are numbered according to their order of appearance in
--   this list.
type MutualNames = [QName]

-- | The target of the function we are checking.
type Target = QName

-- | The current guardedness level.
type Guarded = Order

-- | The termination environment.
data TerEnv
TerEnv :: Bool -> Bool -> Bool -> Maybe QName -> Maybe QName -> CutOff -> QName -> MutualNames -> [QName] -> Maybe Target -> Delayed -> [Bool] -> Bool -> [DeBruijnPat] -> !Int -> !Guarded -> Bool -> VarSet -> TerEnv

-- | Are we mining dot patterns to find evindence of structal descent?
terUseDotPatterns :: TerEnv -> Bool

-- | Do we assume that record and data type constructors preserve
--   guardedness?
terGuardingTypeConstructors :: TerEnv -> Bool

-- | Do we inline with functions to enhance termination checking of with?
terInlineWithFunctions :: TerEnv -> Bool

-- | The name of size successor, if any.
terSizeSuc :: TerEnv -> Maybe QName

-- | The name of the delay constructor (sharp), if any.
terSharp :: TerEnv -> Maybe QName

-- | Depth at which to cut off the structural order.
terCutOff :: TerEnv -> CutOff

-- | The name of the function we are currently checking.
terCurrent :: TerEnv -> QName

-- | The names of the functions in the mutual block we are checking. This
--   includes the internally generated functions (with, extendedlambda,
--   coinduction).
terMutual :: TerEnv -> MutualNames

-- | The list of name actually appearing in the file (abstract syntax).
--   Excludes the internally generated functions.
terUserNames :: TerEnv -> [QName]

-- | Target type of the function we are currently termination checking.
--   Only the constructors of <a>Target</a> are considered guarding.
terTarget :: TerEnv -> Maybe Target

-- | Are we checking a delayed definition?
terDelayed :: TerEnv -> Delayed

-- | Only consider the <a>True</a> arguments for establishing termination.
terMaskArgs :: TerEnv -> [Bool]

-- | Only consider guardedness if <a>True</a>.
terMaskResult :: TerEnv -> Bool

-- | The patterns of the clause we are checking.
terPatterns :: TerEnv -> [DeBruijnPat]

-- | Number of additional binders we have gone under (and consequently need
--   to raise the patterns to compare to terms). Updated during call graph
--   extraction, hence strict.
terPatternsRaise :: TerEnv -> !Int

-- | The current guardedness status. Changes as we go deeper into the term.
--   Updated during call graph extraction, hence strict.
terGuarded :: TerEnv -> !Guarded

-- | When extracting usable size variables during construction of the call
--   matrix, can we take the variable for use with SIZELT constraints from
--   the context? Yes, if we are under an inductive constructor. No, if we
--   are under a record constructor.
terUseSizeLt :: TerEnv -> Bool

-- | Pattern variables that can be compared to argument variables using
--   SIZELT.
terUsableVars :: TerEnv -> VarSet

-- | An empty termination environment.
--   
--   Values are set to a safe default meaning that with these initial
--   values the termination checker will not miss termination errors it
--   would have seen with better settings of these values.
--   
--   Values that do not have a safe default are set to <tt>IMPOSSIBLE</tt>.
defaultTerEnv :: TerEnv

-- | Termination monad service class.
class (Functor m, Monad m) => MonadTer m where terAsks f = f <$> terAsk
terAsk :: MonadTer m => m TerEnv
terLocal :: MonadTer m => (TerEnv -> TerEnv) -> m a -> m a
terAsks :: MonadTer m => (TerEnv -> a) -> m a

-- | Termination monad.
newtype TerM a
TerM :: ReaderT TerEnv TCM a -> TerM a
terM :: TerM a -> ReaderT TerEnv TCM a

-- | Generic run method for termination monad.
runTer :: TerEnv -> TerM a -> TCM a

-- | Run TerM computation in default environment (created from options).
runTerDefault :: TerM a -> TCM a
terGetGuardingTypeConstructors :: TerM Bool
terGetInlineWithFunctions :: TerM Bool
terGetUseDotPatterns :: TerM Bool
terSetUseDotPatterns :: Bool -> TerM a -> TerM a
terGetSizeSuc :: TerM (Maybe QName)
terGetCurrent :: TerM QName
terSetCurrent :: QName -> TerM a -> TerM a
terGetSharp :: TerM (Maybe QName)
terGetCutOff :: TerM CutOff
terGetMutual :: TerM MutualNames
terGetUserNames :: TerM [QName]
terGetTarget :: TerM (Maybe Target)
terSetTarget :: Maybe Target -> TerM a -> TerM a
terGetDelayed :: TerM Delayed
terSetDelayed :: Delayed -> TerM a -> TerM a
terGetMaskArgs :: TerM [Bool]
terSetMaskArgs :: [Bool] -> TerM a -> TerM a
terGetMaskResult :: TerM Bool
terSetMaskResult :: Bool -> TerM a -> TerM a
terGetPatterns :: TerM DeBruijnPats
terSetPatterns :: DeBruijnPats -> TerM a -> TerM a
terRaise :: TerM a -> TerM a
terGetGuarded :: TerM Guarded
terModifyGuarded :: (Order -> Order) -> TerM a -> TerM a
terSetGuarded :: Order -> TerM a -> TerM a
terUnguarded :: TerM a -> TerM a

-- | Should the codomain part of a function type preserve guardedness?
terPiGuarded :: TerM a -> TerM a

-- | Lens for <a>terUsableVars</a>.
terGetUsableVars :: TerM VarSet
terModifyUsableVars :: (VarSet -> VarSet) -> TerM a -> TerM a
terSetUsableVars :: VarSet -> TerM a -> TerM a

-- | Lens for <a>terUseSizeLt</a>.
terGetUseSizeLt :: TerM Bool
terModifyUseSizeLt :: (Bool -> Bool) -> TerM a -> TerM a
terSetUseSizeLt :: Bool -> TerM a -> TerM a

-- | Compute usable vars from patterns and run subcomputation.
withUsableVars :: UsableSizeVars a => a -> TerM b -> TerM b

-- | Set <a>terUseSizeLt</a> when going under constructor <tt>c</tt>.
conUseSizeLt :: QName -> TerM a -> TerM a

-- | Set <a>terUseSizeLt</a> for arguments following projection <tt>q</tt>.
projUseSizeLt :: QName -> TerM a -> TerM a

-- | For termination checking purposes flat should not be considered a
--   projection. That is, it flat doesn't preserve either structural order
--   or guardedness like other projections do. Andreas, 2012-06-09: the
--   same applies to projections of recursive records.
isProjectionButNotCoinductive :: MonadTCM tcm => QName -> tcm Bool

-- | Check whether a projection belongs to a coinductive record and is
--   actually recursive. E.g. @ isCoinductiveProjection (Stream.head) =
--   return False
--   
--   isCoinductiveProjection (Stream.tail) = return True @
isCoinductiveProjection :: MonadTCM tcm => QName -> tcm Bool
type DeBruijnPats = [DeBruijnPat]

-- | Patterns with variables as de Bruijn indices.
type DeBruijnPat = DeBruijnPat' Int
data DeBruijnPat' a

-- | De Bruijn Index.
VarDBP :: a -> DeBruijnPat' a

-- | The name refers to either an ordinary constructor or the successor
--   function on sized types.
ConDBP :: QName -> [DeBruijnPat' a] -> DeBruijnPat' a

-- | Literal. Also abused to censor part of a pattern.
LitDBP :: Literal -> DeBruijnPat' a

-- | Part of dot pattern that cannot be converted into a pattern.
TermDBP :: Term -> DeBruijnPat' a

-- | Projection pattern.
ProjDBP :: QName -> DeBruijnPat' a

-- | How long is the path to the deepest variable?
patternDepth :: DeBruijnPat' a -> Int

-- | A dummy pattern used to mask a pattern that cannot be used for
--   structural descent.
unusedVar :: DeBruijnPat

-- | <tt>raiseDBP n ps</tt> increases each de Bruijn index in <tt>ps</tt>
--   by <tt>n</tt>. Needed when going under a binder during analysis of a
--   term.
raiseDBP :: Int -> DeBruijnPats -> DeBruijnPats

-- | Extract variables from <a>DeBruijnPat</a>s that could witness a
--   decrease via a SIZELT constraint.
--   
--   These variables must be under an inductive constructor (with no record
--   constructor in the way), or after a coinductive projection (with no
--   inductive one in the way).
class UsableSizeVars a
usableSizeVars :: UsableSizeVars a => a -> TerM VarSet

-- | The call information is stored as free monoid over <a>CallInfo</a>. As
--   long as we never look at it, only accumulate it, it does not matter
--   whether we use <tt>Set</tt>, (nub) list, or <tt>Tree</tt>. Internally,
--   due to lazyness, it is anyway a binary tree of <a>mappend</a> nodes
--   and singleton leafs. Since we define no order on <a>CallInfo</a>
--   (expensive), we cannot use a <tt>Set</tt> or nub list.
--   Performance-wise, I could not see a difference between Set and list.
newtype CallPath
CallPath :: [CallInfo] -> CallPath
callInfos :: CallPath -> [CallInfo]

-- | Only show intermediate nodes. (Drop last <a>CallInfo</a>).
instance Functor DeBruijnPat'
instance Show a => Show (DeBruijnPat' a)
instance Functor TerM
instance Applicative TerM
instance Monad TerM
instance Show CallPath
instance Monoid CallPath
instance Pretty CallPath
instance UsableSizeVars [DeBruijnPat]
instance UsableSizeVars DeBruijnPat
instance PrettyTCM DeBruijnPat
instance IsProjP (DeBruijnPat' a)
instance MonadError TCErr TerM
instance MonadTCM TerM
instance MonadIO TerM
instance MonadState TCState TerM
instance MonadReader TCEnv TerM
instance MonadTer TerM


-- | Find the places where the builtin static is used and do some
--   normalisation there.
module Agda.Compiler.Epic.Static
normaliseStatic :: CompiledClauses -> Compile TCM CompiledClauses
evaluateCC :: CompiledClauses -> Compile TCM CompiledClauses
etaExpand :: Term -> Compile TCM Term
class Evaluate a
evaluate :: Evaluate a => a -> Compile TCM a
instance Evaluate Term
instance Evaluate a => Evaluate (Elim' a)
instance Evaluate a => Evaluate (Abs a)
instance Evaluate a => Evaluate (Arg a)
instance Evaluate a => Evaluate [a]


-- | Convert from Agda's internal representation to our auxiliary AST.
module Agda.Compiler.Epic.FromAgda

-- | Convert from Agda's internal representation to our auxiliary AST.
fromAgda :: Maybe Term -> [(QName, Definition)] -> Compile TCM [Fun]

-- | Translate an Agda definition to an Epic function where applicable
translateDefn :: Maybe Term -> (QName, Definition) -> Compile TCM (Maybe Fun)
reverseCCBody :: Int -> CompiledClauses -> CompiledClauses

-- | Translate from Agda's desugared pattern matching (CompiledClauses) to
--   our AuxAST. This is all done by magic. It uses <a>substTerm</a> to
--   translate the actual terms when the cases have been gone through. The
--   case expressions that we get use de Bruijn indices that change after
--   each case in the following way. Say we have this pattern:
--   
--   <pre>
--   f (X x y) (Y z) = term
--   </pre>
--   
--   Initially, the variables have these indexes:
--   
--   <pre>
--   f 0@(X x y) 1@(Y z) = term
--   </pre>
--   
--   The first case will be on <tt>0</tt>, and the variables bound inside
--   the <tt>X</tt> pattern will replace the outer index, so we get
--   something like this:
--   
--   <pre>
--   f 0 2@(Y z) = case 0 of X 0 1 -&gt; term
--   </pre>
--   
--   Notice how <tt>(Y z)</tt> now has index <tt>2</tt>. Then the second
--   pattern is desugared in the same way:
--   
--   <pre>
--   f 0 2 = case 0 of X 0 1 -&gt; case 2 of Y 2 -&gt; term
--   </pre>
--   
--   This replacement is what is done using the replaceAt function.
--   
--   CompiledClauses also have default branches for when all branches fail
--   (even inner branches), the catchAllBranch. Epic does not support this,
--   so we have to add the catchAllBranch to each inner case (here we are
--   calling it omniDefault). To avoid code duplication it is first bound
--   by a let expression.
compileClauses :: QName -> Int -> CompiledClauses -> Compile TCM Fun

-- | Translate the actual Agda terms, with an environment of all the bound
--   variables from patternmatching. Agda terms are in de Bruijn so we just
--   check the new names in the position.
substTerm :: [Var] -> Term -> Compile TCM Expr

-- | Translate Agda literals to our AUX definition
substLit :: Literal -> Compile TCM Lit

module Agda.Compiler.MAlonzo.Primitives

-- | Check that the main function has type IO a, for some a.
checkTypeOfMain :: QName -> Type -> TCM [Decl] -> TCM [Decl]
importsForPrim :: TCM [ModuleName]
declsForPrim :: TCM [Decl]
mazNatToInteger :: String
mazHBoolToBool :: String
mazBoolToHBool :: String
mazStringToList :: String
mazListToString :: String
mazHListToList :: String
mazListToHList :: String
mazCharToInteger :: String
mazIntToNat :: String
mazNatToInt :: String
mazIntegerToNat :: String
xForPrim :: [(String, TCM [a])] -> TCM [a]
primBody :: String -> TCM Exp
repl :: [String] -> String -> String
pconName :: String -> TCM String
hasCompiledData :: [String] -> TCM Bool
bltQual' :: String -> String -> TCM String


-- | This module defines an inlining transformation on clauses that's run
--   before termination checking. The purpose is to improve termination
--   checking of with clauses (issue 59). The transformation inlines
--   generated with-functions expanding the clauses of the parent function
--   in such a way that termination checking the expanded clauses
--   guarantees termination of the original function, while allowing more
--   terminating functions to be accepted. It does in no way pretend to
--   preserve the semantics of the original function.
--   
--   Roughly, the source program
--   
--   <pre>
--   f ps with as
--   {f ps₁i qsi = bi}
--   </pre>
--   
--   is represented internally as
--   
--   <pre>
--   f ps = f-aux xs as      where xs   = vars(ps)
--   {f-aux ps₂i qsi = bi}   where ps₁i = ps[ps₂i/xs]
--   </pre>
--   
--   The inlining transformation turns this into
--   
--   <pre>
--   {f ps = aj} for aj ∈ as
--   {f ps₁i qsi = bi}
--   </pre>
--   
--   The first set of clauses, called <a>withExprClauses</a>, ensure that
--   we don't forget any recursive calls in <tt>as</tt>. The second set of
--   clauses, henceforth called <a>inlinedClauses</a>, are the
--   surface-level clauses the user sees (and probably reasons about).
--   
--   The reason this works is that there is a single call site for each
--   with-function.
--   
--   Note that the lhss of the inlined clauses are not type-correct,
--   neither with the type of <tt>f</tt> (since there are additional
--   patterns <tt>qsi</tt>) nor with the type of <tt>f-aux</tt> (since
--   there are the surface-level patterns <tt>ps₁i</tt> instead of the
--   actual patterns <tt>ps₂i</tt>).
module Agda.Termination.Inlining
inlineWithClauses :: QName -> Clause -> TCM [Clause]
isWithFunction :: MonadTCM tcm => QName -> tcm (Maybe QName)
expandWithFunctionCall :: QName -> Elims -> TCM Term

module Agda.TypeChecking.SizedTypes

-- | Check whether a variable in the context is bounded by a size
--   expression. If <tt>x : Size&lt; a</tt>, then <tt>a</tt> is returned.
isBounded :: MonadTCM tcm => Nat -> tcm BoundedSize

-- | Whenever we create a bounded size meta, add a constraint expressing
--   the bound. In <tt>boundedSizeMetaHook v tel a</tt>, <tt>tel</tt>
--   includes the current context.
boundedSizeMetaHook :: Term -> Telescope -> Type -> TCM ()

-- | <tt>trySizeUniv cmp t m n x els1 y els2</tt> is called as a last
--   resort when conversion checking <tt>m <tt>cmp</tt> n : t</tt> failed
--   for definitions <tt>m = x els1</tt> and <tt>n = y els2</tt>, where the
--   heads <tt>x</tt> and <tt>y</tt> are not equal.
--   
--   <tt>trySizeUniv</tt> accounts for subtyping between SIZELT and SIZE,
--   like <tt>Size&lt; i =&lt; Size</tt>.
--   
--   If it does not succeed it reports failure of conversion check.
trySizeUniv :: Comparison -> Type -> Term -> Term -> QName -> Elims -> QName -> Elims -> TCM ()

-- | Compute the deep size view of a term. Precondition: sized types are
--   enabled.
deepSizeView :: Term -> TCM DeepSizeView
sizeMaxView :: Term -> TCM SizeMaxView

-- | Compare two sizes.
compareSizes :: Comparison -> Term -> Term -> TCM ()

-- | Compare two sizes in max view.
compareMaxViews :: Comparison -> SizeMaxView -> SizeMaxView -> TCM ()

-- | <tt>compareBelowMax u vs</tt> checks <tt>u &lt;= max vs</tt>.
--   Precondition: <tt>size vs &gt;= 2</tt>
compareBelowMax :: DeepSizeView -> SizeMaxView -> TCM ()
compareSizeViews :: Comparison -> DeepSizeView -> DeepSizeView -> TCM ()

-- | Checked whether a size constraint is trivial (like <tt>X &lt;=
--   X+1</tt>).
trivial :: Term -> Term -> TCM Bool

-- | Test whether a problem consists only of size constraints.
isSizeProblem :: ProblemId -> TCM Bool

-- | Test is a constraint speaks about sizes.
isSizeConstraint :: Closure Constraint -> TCM Bool

-- | Find the size constraints.
getSizeConstraints :: TCM [Closure Constraint]

-- | Return a list of size metas and their context.
getSizeMetas :: Bool -> TCM [(MetaId, Type, Telescope)]

-- | Atomic size expressions.
data SizeExpr

-- | A size meta applied to de Bruijn levels.
SizeMeta :: MetaId -> [Int] -> SizeExpr

-- | A de Bruijn level.
Rigid :: Int -> SizeExpr

-- | Size constraints we can solve.
data SizeConstraint

-- | <tt>Leq a +n b</tt> represents <tt>a =&lt; b + n</tt>. <tt>Leq a -n
--   b</tt> represents <tt>a + n =&lt; b</tt>.
Leq :: SizeExpr -> Int -> SizeExpr -> SizeConstraint

-- | Compute a set of size constraints that all live in the same context
--   from constraints over terms of type size that may live in different
--   contexts.
--   
--   cf. <a>simplifyLevelConstraint</a>
computeSizeConstraints :: [Closure Constraint] -> TCM [SizeConstraint]

-- | Turn a constraint over de Bruijn levels into a size constraint.
computeSizeConstraint :: Constraint -> TCM (Maybe SizeConstraint)

-- | Turn a term with de Bruijn levels into a size expression with offset.
--   
--   Throws a <a>patternViolation</a> if the term isn't a proper size
--   expression.
sizeExpr :: Term -> TCM (SizeExpr, Int)

-- | Compute list of size metavariables with their arguments appearing in a
--   constraint.
flexibleVariables :: SizeConstraint -> [(MetaId, [Int])]

-- | Convert size constraint into form where each meta is applied to levels
--   <tt>0,1,..,n-1</tt> where <tt>n</tt> is the arity of that meta.
--   
--   <tt>X[σ] &lt;= t</tt> beomes <tt>X[id] &lt;= t[σ^-1]</tt>
--   
--   <tt>X[σ] ≤ Y[τ]</tt> becomes <tt>X[id] ≤ Y[τ[σ^-1]]</tt> or
--   <tt>X[σ[τ^1]] ≤ Y[id]</tt> whichever is defined. If none is defined,
--   we give up.
canonicalizeSizeConstraint :: SizeConstraint -> Maybe SizeConstraint

-- | Main function.
solveSizeConstraints :: TCM ()

-- | Old solver for size constraints using <a>Warshall</a>.
oldSolver :: [(MetaId, Int)] -> [SizeConstraint] -> TCM Bool
instance Eq SizeExpr
instance Show SizeConstraint
instance Show SizeExpr

module Agda.Termination.TermCheck

-- | Termination check a single declaration.
termDecl :: Declaration -> TCM Result

-- | The result of termination checking a module. Must be <a>Pointed</a>
--   and a <a>Monoid</a>.
type Result = [TerminationError]

-- | Patterns with variables as de Bruijn indices.
type DeBruijnPat = DeBruijnPat' Int
instance ExtractCalls Level
instance StripAllProjections Term
instance StripAllProjections Args
instance StripAllProjections Elims
instance StripAllProjections a => StripAllProjections (Arg a)
instance ExtractCalls LevelAtom
instance ExtractCalls PlusLevel
instance ExtractCalls Term
instance ExtractCalls Type
instance ExtractCalls Sort
instance (ExtractCalls a, ExtractCalls b) => ExtractCalls (a, b)
instance ExtractCalls a => ExtractCalls [a]
instance ExtractCalls a => ExtractCalls (Elim' a)
instance ExtractCalls a => ExtractCalls (Dom a)
instance ExtractCalls a => ExtractCalls (Arg a)
instance ExtractCalls a => ExtractCalls (Abs a)


-- | Code which replaces pattern matching on record constructors with uses
--   of projection functions.
module Agda.TypeChecking.RecordPatterns

-- | Replaces pattern matching on record constructors with uses of
--   projection functions. Does not remove record constructor patterns
--   which have sub-patterns containing non-record constructor or literal
--   patterns.
--   
--   If the input clause contains dot patterns inside record patterns, then
--   the translation may yield clauses which are not type-correct. However,
--   we believe that it is safe to use the output as input to
--   <a>compileClauses</a>. Perhaps it would be better to perform record
--   pattern translation on the compiled clauses instead, but the code
--   below has already been implemented and seems to work.
translateRecordPatterns :: Clause -> TCM Clause
translateCompiledClauses :: CompiledClauses -> TCM CompiledClauses

-- | Bottom-up procedure to record-pattern-translate split tree.
translateSplitTree :: SplitTree -> TCM SplitTree

-- | Take a record pattern <tt>p</tt> and yield a list of projections
--   corresponding to the pattern variables, from left to right.
--   
--   E.g. for <tt>(x , (y , z))</tt> we return <tt>[ fst, fst . snd, snd .
--   snd ]</tt>.
--   
--   If it is not a record pattern, error <a>ShouldBeRecordPattern</a> is
--   raised.
recordPatternToProjections :: Pattern -> TCM [Term -> Term]
instance Functor RecPatM
instance Applicative RecPatM
instance Monad RecPatM
instance MonadIO RecPatM
instance MonadTCM RecPatM
instance MonadReader TCEnv RecPatM
instance MonadState TCState RecPatM
instance Eq Kind
instance DropFrom a => DropFrom [a]
instance DropFrom (c, SplitTree' c)
instance DropFrom (SplitTree' c)

module Agda.TypeChecking.CompiledClause.Match
matchCompiled :: CompiledClauses -> MaybeReducedArgs -> ReduceM (Reduced (Blocked Args) Term)

-- | <tt>matchCompiledE c es</tt> takes a function given by case tree
--   <tt>c</tt> and and a spine <tt>es</tt> and tries to apply the function
--   to <tt>es</tt>.
matchCompiledE :: CompiledClauses -> MaybeReducedElims -> ReduceM (Reduced (Blocked Elims) Term)

-- | A stack entry is a triple consisting of 1. the part of the case tree
--   to continue matching, 2. the current argument vector, and 3. a patch
--   function taking the current argument vector back to the original
--   argument vector.
type Frame = (CompiledClauses, MaybeReducedElims, Elims -> Elims)
type Stack = [Frame]

-- | <tt>match'</tt> tries to solve the matching problems on the
--   <tt>Stack</tt>. In each iteration, the top problem is removed and
--   handled.
--   
--   If the top problem was a <tt>Done</tt>, we succeed.
--   
--   If the top problem was a <tt>Case n</tt> and the <tt>n</tt>th argument
--   of the problem is not a constructor or literal, we are stuck, thus,
--   fail.
--   
--   If we have a branch for the constructor/literal, we put it on the
--   stack to continue. If we do not have a branch, we fall through to the
--   next problem, which should be the corresponding catch-all branch.
--   
--   An empty stack is an exception that can come only from an incomplete
--   function definition.
match' :: Stack -> ReduceM (Reduced (Blocked Elims) Term)
unfoldCorecursionE :: Elim -> ReduceM (Blocked Elim)
unfoldCorecursion :: Term -> ReduceM (Blocked Term)

module Agda.TypeChecking.InstanceArguments

-- | A candidate solution for an instance meta is a term with its type.
type Candidate = (Term, Type)
type Candidates = [Candidate]

-- | Compute a list of instance candidates. <a>Nothing</a> if type is a
--   meta, error if type is not eligible for instance search.
initialIFSCandidates :: Type -> TCM (Maybe Candidates)

-- | <tt>initializeIFSMeta s t</tt> generates an instance meta of type
--   <tt>t</tt> with suggested name <tt>s</tt>.
initializeIFSMeta :: String -> Type -> TCM Term

-- | <tt>findInScope m (v,a)s</tt> tries to instantiate on of the types
--   <tt>a</tt>s of the candidate terms <tt>v</tt>s to the type <tt>t</tt>
--   of the metavariable <tt>m</tt>. If successful, meta <tt>m</tt> is
--   solved with the instantiation of <tt>v</tt>. If unsuccessful, the
--   constraint is regenerated, with possibly reduced candidate set. The
--   list of candidates is equal to <tt>Nothing</tt> when the type of the
--   meta wasn't known when the constraint was generated. In that case, try
--   to find its type again.
findInScope :: MetaId -> Maybe Candidates -> TCM ()

-- | Result says whether we need to add constraint, and if so, the set of
--   remaining candidates.
findInScope' :: MetaId -> Candidates -> TCM (Maybe Candidates)

-- | A meta _M is rigidly constrained if there is a constraint _M us == D
--   vs, for inert D. Such metas can safely be instantiated by recursive
--   instance search, since the constraint limits the solution space.
rigidlyConstrainedMetas :: TCM [MetaId]

-- | Given a meta <tt>m</tt> of type <tt>t</tt> and a list of candidates
--   <tt>cands</tt>, <tt>checkCandidates m t cands</tt> returns a refined
--   list of valid candidates.
checkCandidates :: MetaId -> Type -> Candidates -> TCM Candidates

-- | To preserve the invariant that a constructor is not applied to its
--   parameter arguments, we explicitly check whether function term we are
--   applying to arguments is a unapplied constructor. In this case we drop
--   the first <a>conPars</a> arguments. See Issue670a. Andreas, 2013-11-07
--   Also do this for projections, see Issue670b.
applyDroppingParameters :: Term -> Args -> TCM Term

module Agda.TypeChecking.Constraints

-- | Catches pattern violation errors and adds a constraint.
catchConstraint :: Constraint -> TCM () -> TCM ()
addConstraint :: Constraint -> TCM ()

-- | Don't allow the argument to produce any constraints.
noConstraints :: TCM a -> TCM a

-- | Create a fresh problem for the given action.
newProblem :: TCM a -> TCM (ProblemId, a)
newProblem_ :: TCM () -> TCM ProblemId
ifNoConstraints :: TCM a -> (a -> TCM b) -> (ProblemId -> a -> TCM b) -> TCM b
ifNoConstraints_ :: TCM () -> TCM a -> (ProblemId -> TCM a) -> TCM a

-- | <tt>guardConstraint c blocker</tt> tries to solve <tt>blocker</tt>
--   first. If successful without constraints, it moves on to solve
--   <tt>c</tt>, otherwise it adds a <tt>Guarded c cs</tt> constraint to
--   the <tt>blocker</tt>-generated constraints <tt>cs</tt>.
guardConstraint :: Constraint -> TCM () -> TCM ()
whenConstraints :: TCM () -> TCM () -> TCM ()

-- | Wake up the constraints depending on the given meta.
wakeupConstraints :: MetaId -> TCM ()

-- | Wake up all constraints.
wakeupConstraints_ :: TCM ()
solveAwakeConstraints :: TCM ()
solveAwakeConstraints' :: Bool -> TCM ()
solveConstraint :: Constraint -> TCM ()
solveConstraint_ :: Constraint -> TCM ()
checkTypeCheckingProblem :: TypeCheckingProblem -> TCM Term

module Agda.TypeChecking.MetaVars.Occurs
modifyOccursCheckDefs :: (Set QName -> Set QName) -> TCM ()

-- | Set the names of definitions to be looked at to the defs in the
--   current mutual block.
initOccursCheck :: MetaVariable -> TCM ()

-- | Is a def in the list of stuff to be checked?
defNeedsChecking :: QName -> TCM Bool

-- | Remove a def from the list of defs to be looked at.
tallyDef :: QName -> TCM ()
data OccursCtx

-- | we are in arguments of a meta
Flex :: OccursCtx

-- | we are not in arguments of a meta but a bound var
Rigid :: OccursCtx

-- | we are at the start or in the arguments of a constructor
StronglyRigid :: OccursCtx

-- | we are at the term root (this turns into <tt>StronglyRigid</tt>)
Top :: OccursCtx

-- | we are in an irrelevant argument
Irrel :: OccursCtx
data UnfoldStrategy
YesUnfold :: UnfoldStrategy
NoUnfold :: UnfoldStrategy
defArgs :: UnfoldStrategy -> OccursCtx -> OccursCtx
unfold :: UnfoldStrategy -> Term -> TCM (Blocked Term)

-- | Leave the top position.
leaveTop :: OccursCtx -> OccursCtx

-- | Leave the strongly rigid position.
weakly :: OccursCtx -> OccursCtx
strongly :: OccursCtx -> OccursCtx
patternViolation' :: Int -> String -> TCM a
abort :: OccursCtx -> TypeError -> TCM a

-- | Distinguish relevant and irrelevant variables in occurs check.
type Vars = ([Nat], [Nat])
goIrrelevant :: Vars -> Vars
allowedVar :: Nat -> Vars -> Bool
takeRelevant :: Vars -> [Nat]
liftUnderAbs :: Vars -> Vars

-- | Extended occurs check.
class Occurs t
occurs :: Occurs t => UnfoldStrategy -> OccursCtx -> MetaId -> Vars -> t -> TCM t
metaOccurs :: Occurs t => MetaId -> t -> TCM ()

-- | When assigning <tt>m xs := v</tt>, check that <tt>m</tt> does not
--   occur in <tt>v</tt> and that the free variables of <tt>v</tt> are
--   contained in <tt>xs</tt>.
occursCheck :: MetaId -> Vars -> Term -> TCM Term

-- | <tt>prune m' vs xs</tt> attempts to remove all arguments from
--   <tt>vs</tt> whose free variables are not contained in <tt>xs</tt>. If
--   successful, <tt>m'</tt> is solved by the new, pruned meta variable and
--   we return <tt>True</tt> else <tt>False</tt>.
--   
--   Issue 1147: If any of the meta args <tt>vs</tt> is matchable, e.g., is
--   a constructor term, we cannot prune, because the offending variables
--   could be removed by reduction for a suitable instantiation of the meta
--   variable.
prune :: MetaId -> Args -> [Nat] -> TCM PruneResult

-- | <tt>hasBadRigid xs v = Just True</tt> iff one of the rigid variables
--   in <tt>v</tt> is not in <tt>xs</tt>. Actually we can only prune if a
--   bad variable is in the head. See issue 458. Or in a non-eliminateable
--   position (see succeed/PruningNonMillerPattern).
--   
--   <tt>hasBadRigid xs v = Nothing</tt> means that we cannot prune at all
--   as one of the meta args is matchable. (See issue 1147.)
hasBadRigid :: [Nat] -> Term -> ExceptT () TCM Bool

-- | Check whether a term <tt>Def f es</tt> is finally stuck. Currently, we
--   give only a crude approximation.
isNeutral :: MonadTCM tcm => QName -> Elims -> tcm Bool
rigidVarsNotContainedIn :: Free a => a -> [Nat] -> Bool
data PruneResult

-- | the kill list is empty or only <tt>False</tt>s
NothingToPrune :: PruneResult

-- | there is no possible kill (because of type dep.)
PrunedNothing :: PruneResult

-- | managed to kill some args in the list
PrunedSomething :: PruneResult

-- | all prescribed kills where performed
PrunedEverything :: PruneResult

-- | <tt>killArgs [k1,...,kn] X</tt> prunes argument <tt>i</tt> from
--   metavar <tt>X</tt> if <tt>ki==True</tt>. Pruning is carried out
--   whenever &gt; 0 arguments can be pruned. <tt>True</tt> is only
--   returned if all arguments could be pruned.
killArgs :: [Bool] -> MetaId -> TCM PruneResult

-- | <tt>killedType [((x1,a1),k1)..((xn,an),kn)] b = ([k'1..k'n],t')</tt>
--   (ignoring <tt>Dom</tt>). Let <tt>t' = (xs:as) -&gt; b</tt>. Invariant:
--   <tt>k'i == True</tt> iff <tt>ki == True</tt> and pruning the
--   <tt>i</tt>th argument from type <tt>b</tt> is possible without
--   creating unbound variables. <tt>t'</tt> is type <tt>t</tt> after
--   pruning all <tt>k'i==True</tt>.
killedType :: [(Dom (ArgName, Type), Bool)] -> Type -> ([Arg Bool], Type)
performKill :: [Arg Bool] -> MetaId -> Type -> TCM ()
instance Eq OccursCtx
instance Show OccursCtx
instance Eq UnfoldStrategy
instance Show UnfoldStrategy
instance Eq PruneResult
instance Show PruneResult
instance Occurs a => Occurs [a]
instance (Occurs a, Occurs b) => Occurs (a, b)
instance Occurs a => Occurs (Dom a)
instance Occurs a => Occurs (Arg a)
instance (Occurs a, Subst a) => Occurs (Abs a)
instance Occurs a => Occurs (Elim' a)
instance Occurs Sort
instance Occurs Type
instance Occurs LevelAtom
instance Occurs PlusLevel
instance Occurs Level
instance Occurs Clause
instance Occurs Defn
instance Occurs QName
instance Occurs Term

module Agda.TypeChecking.MetaVars

-- | Find position of a value in a list. Used to change metavar argument
--   indices during assignment.
--   
--   <tt>reverse</tt> is necessary because we are directly abstracting over
--   the list.
findIdx :: Eq a => [a] -> a -> Maybe Int

-- | Check whether a meta variable is a place holder for a blocked term.
isBlockedTerm :: MetaId -> TCM Bool
isEtaExpandable :: MetaId -> TCM Bool

-- | Performing the meta variable assignment.
--   
--   The instantiation should not be an <a>InstV</a> or <a>InstS</a> and
--   the <a>MetaId</a> should point to something <a>Open</a> or a
--   <a>BlockedConst</a>. Further, the meta variable may not be
--   <a>Frozen</a>.
assignTerm :: MetaId -> [Arg ArgName] -> Term -> TCM ()

-- | Skip frozen check. Used for eta expanding frozen metas.
assignTerm' :: MetaId -> [Arg ArgName] -> Term -> TCM ()
newSortMeta :: TCM Sort
newSortMetaCtx :: Args -> TCM Sort
newTypeMeta :: Sort -> TCM Type
newTypeMeta_ :: TCM Type

-- | <tt>newIFSMeta s t cands</tt> creates a new "implicit from scope"
--   metavariable of type the output type of <tt>t</tt> with name
--   suggestion <tt>s</tt> and initial solution candidates <tt>cands</tt>.
--   If <tt>t</tt> is a function type, then insert enough lambdas in front
--   of it.
newIFSMeta :: MetaNameSuggestion -> Type -> Maybe [(Term, Type)] -> TCM Term

-- | Create a new value meta with specific dependencies.
newIFSMetaCtx :: MetaNameSuggestion -> Type -> Args -> Maybe [(Term, Type)] -> TCM Term
newNamedValueMeta :: RunMetaOccursCheck -> MetaNameSuggestion -> Type -> TCM Term

-- | Create a new metavariable, possibly η-expanding in the process.
newValueMeta :: RunMetaOccursCheck -> Type -> TCM Term
newValueMetaCtx :: RunMetaOccursCheck -> Type -> Args -> TCM Term

-- | Create a new value meta without η-expanding.
newValueMeta' :: RunMetaOccursCheck -> Type -> TCM Term

-- | Create a new value meta with specific dependencies.
newValueMetaCtx' :: RunMetaOccursCheck -> Type -> Args -> TCM Term
newTelMeta :: Telescope -> TCM Args
type Condition = Dom Type -> Abs Type -> Bool
trueCondition :: Condition
newArgsMeta :: Type -> TCM Args
newArgsMeta' :: Condition -> Type -> TCM Args
newArgsMetaCtx :: Type -> Telescope -> Args -> TCM Args
newArgsMetaCtx' :: Condition -> Type -> Telescope -> Args -> TCM Args

-- | Create a metavariable of record type. This is actually one
--   metavariable for each field.
newRecordMeta :: QName -> Args -> TCM Term
newRecordMetaCtx :: QName -> Args -> Telescope -> Args -> TCM Term
newQuestionMark :: InteractionId -> Type -> TCM Term

-- | Construct a blocked constant if there are constraints.
blockTerm :: Type -> TCM Term -> TCM Term
blockTermOnProblem :: Type -> Term -> ProblemId -> TCM Term
blockTypeOnProblem :: Type -> ProblemId -> TCM Type

-- | <tt>unblockedTester t</tt> returns <tt>False</tt> if <tt>t</tt> is a
--   meta or a blocked term.
--   
--   Auxiliary function to create a postponed type checking problem.
unblockedTester :: Type -> TCM Bool

-- | Create a postponed type checking problem <tt>e : t</tt> that waits for
--   type <tt>t</tt> to unblock (become instantiated or its constraints
--   resolved).
postponeTypeCheckingProblem_ :: TypeCheckingProblem -> TCM Term

-- | Create a postponed type checking problem <tt>e : t</tt> that waits for
--   conditon <tt>unblock</tt>. A new meta is created in the current
--   context that has as instantiation the postponed type checking problem.
--   An <a>UnBlock</a> constraint is added for this meta, which links to
--   this meta.
postponeTypeCheckingProblem :: TypeCheckingProblem -> TCM Bool -> TCM Term
problemType :: TypeCheckingProblem -> Type

-- | Eta expand metavariables listening on the current meta.
etaExpandListeners :: MetaId -> TCM ()

-- | Wake up a meta listener and let it do its thing
wakeupListener :: Listener -> TCM ()

-- | Do safe eta-expansions for meta (<tt>SingletonRecords,Levels</tt>).
etaExpandMetaSafe :: MetaId -> TCM ()

-- | Various kinds of metavariables.
data MetaKind

-- | Meta variables of record type.
Records :: MetaKind

-- | Meta variables of "hereditarily singleton" record type.
SingletonRecords :: MetaKind

-- | Meta variables of level type, if type-in-type is activated.
Levels :: MetaKind

-- | All possible metavariable kinds.
allMetaKinds :: [MetaKind]

-- | Eta expand a metavariable, if it is of the specified kind. Don't do
--   anything if the metavariable is a blocked term.
etaExpandMeta :: [MetaKind] -> MetaId -> TCM ()

-- | Eta expand blocking metavariables of record type, and reduce the
--   blocked thing.
etaExpandBlocked :: Reduce t => Blocked t -> TCM (Blocked t)

-- | Assign to an open metavar which may not be frozen. First check that
--   metavar args are in pattern fragment. Then do extended occurs check on
--   given thing.
--   
--   Assignment is aborted by throwing a <tt>PatternErr</tt> via a call to
--   <tt>patternViolation</tt>. This error is caught by
--   <tt>catchConstraint</tt> during equality checking
--   (<tt>compareAtom</tt>) and leads to restoration of the original
--   constraints.
assignV :: CompareDirection -> MetaId -> Args -> Term -> TCM ()
assignWrapper :: CompareDirection -> MetaId -> Elims -> Term -> TCM () -> TCM ()

-- | Miller pattern unification:
--   
--   <tt>assign x vs v</tt> solves problem <tt>x vs = v</tt> for meta
--   <tt>x</tt> if <tt>vs</tt> are distinct variables (linearity check) and
--   <tt>v</tt> depends only on these variables and does not contain
--   <tt>x</tt> itself (occurs check).
--   
--   This is the basic story, but we have added some features:
--   
--   <ol>
--   <li>Pruning.</li>
--   <li>Benign cases of non-linearity.</li>
--   <li><tt>vs</tt> may contain record patterns.</li>
--   </ol>
--   
--   For a reference to some of these extensions, read Andreas Abel and
--   Brigitte Pientka's TLCA 2011 paper.
assign :: CompareDirection -> MetaId -> Args -> Term -> TCM ()

-- | When faced with <tt>_X us == D vs</tt> for an inert D we can solve
--   this by <tt>_X xs := D _Ys</tt> with new constraints <tt>_Yi us ==
--   vi</tt>. This is important for instance arguments, where knowing the
--   head D might enable progress.
attemptInertRHSImprovement :: MetaId -> Args -> Term -> TCM ()

-- | <tt>assignMeta m x t ids u</tt> solves <tt>x ids = u</tt> for meta
--   <tt>x</tt> of type <tt>t</tt>, where term <tt>u</tt> lives in a
--   context of length <tt>m</tt>. Precondition: <tt>ids</tt> is linear.
assignMeta :: Int -> MetaId -> Type -> [Int] -> Term -> TCM ()

-- | <tt>assignMeta' m x t ids u</tt> solves <tt>x = [ids]u</tt> for meta
--   <tt>x</tt> of type <tt>t</tt>, where term <tt>u</tt> lives in a
--   context of length <tt>m</tt>, and <tt>ids</tt> is a partial
--   substitution.
assignMeta' :: Int -> MetaId -> Type -> Int -> SubstCand -> Term -> TCM ()

-- | Turn the assignment problem <tt>_X args &lt;= SizeLt u</tt> into
--   <tt>_X args = SizeLt (_Y args)</tt> and constraint <tt>_Y args &lt;=
--   u</tt>.
subtypingForSizeLt :: CompareDirection -> MetaId -> MetaVariable -> Type -> Args -> Term -> (Term -> TCM ()) -> TCM ()

-- | Eta-expand bound variables like <tt>z</tt> in <tt>X (fst z)</tt>.
expandProjectedVars :: (Normalise a, TermLike a, PrettyTCM a, NoProjectedVar a, Subst a, PrettyTCM b, Subst b) => a -> b -> (a -> b -> TCM c) -> TCM c

-- | Eta-expand a de Bruijn index of record type in context and passed
--   term(s).
etaExpandProjectedVar :: (PrettyTCM a, Subst a) => Int -> a -> TCM c -> (a -> TCM c) -> TCM c

-- | Check whether one of the meta args is a projected var.
class NoProjectedVar a
noProjectedVar :: NoProjectedVar a => a -> Either ProjVarExc ()
data ProjVarExc
ProjVarExc :: Int -> [QName] -> ProjVarExc
type FVs = VarSet
type SubstCand = [(Nat, Term)]

-- | Turn non-det substitution into proper substitution, if possible.
--   Otherwise, raise the error.
checkLinearity :: SubstCand -> ExceptT () TCM SubstCand
type Res = [(Arg Nat, Term)]

-- | Exceptions raised when substitution cannot be inverted.
data InvertExcept

-- | Cannot recover.
CantInvert :: InvertExcept

-- | A neutral arg: can't invert, but maybe prune.
NeutralArg :: InvertExcept

-- | Try to eta-expand var to remove projs.
ProjectedVar :: Int -> [QName] -> InvertExcept

-- | Check that arguments <tt>args</tt> to a metavar are in pattern
--   fragment. Assumes all arguments already in whnf and eta-reduced.
--   Parameters are represented as <tt>Var</tt>s so <tt>checkArgs</tt>
--   really checks that all args are <tt>Var</tt>s and returns the
--   "substitution" to be applied to the rhs of the equation to solve. (If
--   <tt>args</tt> is considered a substitution, its inverse is returned.)
--   
--   The returned list might not be ordered. Linearity, i.e., whether the
--   substitution is deterministic, has to be checked separately.
inverseSubst :: Args -> ExceptT InvertExcept TCM SubstCand

-- | Used in <a>giveExpr</a>.
updateMeta :: MetaId -> Term -> TCM ()

-- | Returns every meta-variable occurrence in the given type, except for
--   those in <a>Sort</a>s.
allMetas :: TermLike a => a -> [MetaId]
instance Eq MetaKind
instance Enum MetaKind
instance Bounded MetaKind
instance Show MetaKind
instance Error InvertExcept
instance NoProjectedVar a => NoProjectedVar [a]
instance NoProjectedVar a => NoProjectedVar (Arg a)
instance NoProjectedVar Term
instance Error ProjVarExc


-- | Generates data used for precise syntax highlighting.
module Agda.Interaction.Highlighting.Generate

-- | Highlighting levels.
data Level

-- | Full highlighting. Should only be used after typechecking has
--   completed successfully.
Full :: Level

-- | Highlighting without disambiguation of overloaded constructors.
Partial :: Level

-- | Generate syntax highlighting information for the given declaration,
--   and (if appropriate) print it. If the <a>HighlightingLevel</a> is
--   <tt><a>Full</a></tt>, then the state is additionally updated with the
--   new highlighting info (in case of a conflict new info takes precedence
--   over old info).
--   
--   The procedure makes use of some of the token highlighting info in
--   <a>stTokens</a> (that corresponding to the interval covered by the
--   declaration). If the <a>HighlightingLevel</a> is <tt><a>Full</a></tt>,
--   then this token highlighting info is additionally removed from
--   <a>stTokens</a>.
generateAndPrintSyntaxInfo :: Declaration -> Level -> TCM ()

-- | Generate and return the syntax highlighting information for the tokens
--   in the given file.
generateTokenInfo :: AbsolutePath -> TCM CompressedFile

-- | Same as <a>generateTokenInfo</a> but takes a string instead of a
--   filename.
generateTokenInfoFromString :: Range -> String -> TCM CompressedFile

-- | Prints syntax highlighting info for an error.
printErrorInfo :: TCErr -> TCM ()

-- | Generate highlighting for error. Does something special for
--   termination errors.
errorHighlighting :: TCErr -> TCM File

-- | Generates and prints syntax highlighting information for unsolved
--   meta-variables and certain unsolved constraints.
printUnsolvedInfo :: TCM ()

-- | Lispify and print the given highlighting information.
printHighlightingInfo :: MonadTCM tcm => HighlightingInfo -> tcm ()

-- | <tt>highlightAsTypeChecked rPre r m</tt> runs <tt>m</tt> and returns
--   its result. Additionally, some code may be highlighted:
--   
--   <ul>
--   <li>If <tt>r</tt> is non-empty and not a sub-range of <tt>rPre</tt>
--   (after <a>continuousPerLine</a> has been applied to both): <tt>r</tt>
--   is highlighted as being type-checked while <tt>m</tt> is running (this
--   highlighting is removed if <tt>m</tt> completes
--   <i>successfully</i>).</li>
--   <li>Otherwise: Highlighting is removed for <tt>rPre - r</tt> before
--   <tt>m</tt> runs, and if <tt>m</tt> completes successfully, then
--   <tt>rPre - r</tt> is highlighted as being type-checked.</li>
--   </ul>
highlightAsTypeChecked :: MonadTCM tcm => Range -> Range -> tcm a -> tcm a

-- | Generates syntax highlighting information for unsolved meta variables.
computeUnsolvedMetaWarnings :: TCM File

-- | Generates syntax highlighting information for unsolved constraints
--   that are not connected to a meta variable.
computeUnsolvedConstraints :: TCM File

-- | Remember a name disambiguation (during type checking). To be used
--   later during syntax highlighting.
storeDisambiguatedName :: QName -> TCM ()

-- | All the properties.
tests :: IO Bool


-- | Responsible for running all internal tests.
module Agda.Tests
testSuite :: IO Bool


-- | A syntactic equality check that takes meta instantiations into
--   account, but does not reduce. It replaces <tt> (v, v') &lt;-
--   instantiateFull (v, v') v == v' </tt> by a more efficient routine
--   which only traverses and instantiates the terms as long as they are
--   equal.
module Agda.TypeChecking.SyntacticEquality

-- | Instantiate full as long as things are equal
class SynEq a where synEq' a a' = ifEqual (uncurry synEq) (a, a')

-- | Syntactic equality check for terms. <tt> checkSyntacticEquality v v' =
--   do (v,v') &lt;- instantiateFull (v,v') return ((v,v'), v==v') </tt>
--   only that <tt>v,v'</tt> are only fully instantiated to the depth where
--   they are equal.
checkSyntacticEquality :: SynEq a => a -> a -> TCM ((a, a), Bool)
instance SynEq c => SynEq (ArgInfo c)
instance (SynEq a, SynEq c) => SynEq (Dom c a)
instance (SynEq a, SynEq c) => SynEq (Arg c a)
instance (Subst a, SynEq a) => SynEq (Abs a)
instance SynEq a => SynEq (Elim' a)
instance SynEq a => SynEq [a]
instance SynEq Type
instance SynEq Sort
instance SynEq LevelAtom
instance SynEq PlusLevel
instance SynEq Level
instance SynEq Term

module Agda.TypeChecking.Polarity

-- | Infimum on the information lattice. <a>Invariant</a> is bottom
--   (dominant for inf), <a>Nonvariant</a> is top (neutral for inf).
(/\) :: Polarity -> Polarity -> Polarity

-- | <a>Polarity</a> negation, swapping monotone and antitone.
neg :: Polarity -> Polarity

-- | What is the polarity of a function composition?
composePol :: Polarity -> Polarity -> Polarity
polFromOcc :: Occurrence -> Polarity

-- | Get the next polarity from a list, <a>Invariant</a> if empty.
nextPolarity :: [Polarity] -> (Polarity, [Polarity])

-- | Replace <a>Nonvariant</a> by <a>Invariant</a>.
purgeNonvariant :: [Polarity] -> [Polarity]

-- | Main function of this module.
computePolarity :: QName -> TCM ()

-- | Data and record parameters are used as phantom arguments all over the
--   test suite (and possibly in user developments).
--   <tt>enablePhantomTypes</tt> turns <a>Nonvariant</a> parameters to
--   <a>Invariant</a> to enable phantoms.
enablePhantomTypes :: Defn -> [Polarity] -> [Polarity]

-- | Make arguments <a>Invariant</a> if the type of a not-<a>Nonvariant</a>
--   later argument depends on it.
dependentPolarity :: Type -> [Polarity] -> TCM [Polarity]

-- | Check whether a variable is relevant in a type expression, ignoring
--   domains of non-variant arguments.
relevantInIgnoringNonvariant :: Nat -> Type -> [Polarity] -> TCM Bool

-- | Record information that an argument is unused in <a>Relevance</a>.
mkUnused :: Relevance -> Relevance

-- | Improve <a>Relevance</a> information in a type by polarity
--   information. <a>Nonvariant</a> becomes <a>UnusedArg</a>.
nonvariantToUnusedArg :: [Polarity] -> Type -> TCM Type

-- | Propagate <a>Nonvariant</a> <a>Polarity</a> to <a>Relevance</a>
--   information in <a>Arg</a>s of a defined symbol.
nonvariantToUnusedArgInDef :: [Polarity] -> Defn -> Defn
nonvariantToUnusedArgInClause :: [Polarity] -> Clause -> Clause

-- | Hack for polarity of size indices.
sizePolarity :: QName -> [Polarity] -> TCM [Polarity]

-- | <tt>checkSizeIndex d np i a</tt> checks that constructor target type
--   <tt>a</tt> has form <tt>d ps (↑ i) idxs</tt> where <tt>|ps| = np</tt>.
--   
--   Precondition: <tt>a</tt> is reduced and of form <tt>d ps idxs0</tt>.
checkSizeIndex :: QName -> Nat -> Nat -> Type -> TCM Bool

-- | <tt>polarities i a</tt> computes the list of polarities of de Bruijn
--   index <tt>i</tt> in syntactic entity <tt>a</tt>.
class HasPolarity a
polarities :: HasPolarity a => Nat -> a -> TCM [Polarity]

-- | <tt>polarity i a</tt> computes the polarity of de Bruijn index
--   <tt>i</tt> in syntactic entity <tt>a</tt> by taking the infimum of all
--   <a>polarities</a>.
polarity :: HasPolarity a => Nat -> a -> TCM Polarity
instance HasPolarity LevelAtom
instance HasPolarity PlusLevel
instance HasPolarity Level
instance HasPolarity Term
instance HasPolarity a => HasPolarity (Elim' a)
instance HasPolarity Type
instance (HasPolarity a, HasPolarity b) => HasPolarity (a, b)
instance HasPolarity a => HasPolarity [a]
instance HasPolarity a => HasPolarity (Abs a)
instance HasPolarity a => HasPolarity (Dom a)
instance HasPolarity a => HasPolarity (Arg a)


-- | Functions for inserting implicit arguments at the right places.
module Agda.TypeChecking.Implicit

-- | <tt>implicitArgs n expand t</tt> generates up to <tt>n</tt> implicit
--   arguments metas (unbounded if <tt>n&lt;0</tt>), as long as <tt>t</tt>
--   is a function type and <tt>expand</tt> holds on the hiding info of its
--   domain.
implicitArgs :: Int -> (Hiding -> Bool) -> Type -> TCM (Args, Type)

-- | <tt>implicitNamedArgs n expand t</tt> generates up to <tt>n</tt> named
--   implicit arguments metas (unbounded if <tt>n&lt;0</tt>), as long as
--   <tt>t</tt> is a function type and <tt>expand</tt> holds on the hiding
--   and name info of its domain.
implicitNamedArgs :: Int -> (Hiding -> ArgName -> Bool) -> Type -> TCM (NamedArgs, Type)
data ImplicitInsertion

-- | this many implicits have to be inserted
ImpInsert :: [Hiding] -> ImplicitInsertion

-- | hidden argument where there should have been a non-hidden arg
BadImplicits :: ImplicitInsertion

-- | bad named argument
NoSuchName :: ArgName -> ImplicitInsertion
NoInsertNeeded :: ImplicitInsertion
impInsert :: [Hiding] -> ImplicitInsertion

-- | The list should be non-empty.
insertImplicit :: NamedArg e -> [Arg ArgName] -> ImplicitInsertion
instance Show ImplicitInsertion

module Agda.TypeChecking.Rules.LHS.Instantiate

-- | Instantiate a telescope with a substitution. Might reorder the
--   telescope. <tt>instantiateTel (Γ : Tel)(σ : Γ --&gt; Γ) = Γσ~</tt>
--   Monadic only for debugging purposes.
instantiateTel :: Substitution -> Telescope -> TCM (Telescope, Permutation, Substitution, [Dom Type])

-- | Produce a nice error message when splitting failed
nothingToSplitError :: Problem -> TCM a

module Agda.TypeChecking.Patterns.Match

-- | If matching is inconclusive (<tt>DontKnow</tt>) we want to know
--   whether it is due to a particular meta variable.
data Match a
Yes :: Simplification -> [a] -> Match a
No :: Match a
DontKnow :: (Maybe MetaId) -> Match a

-- | Instead of <a>zipWithM</a>, we need to use this lazy version of
--   combining pattern matching computations.
foldMatch :: (a -> b -> ReduceM (Match Term, b)) -> [a] -> [b] -> ReduceM (Match Term, [b])

-- | <tt>matchCopatterns ps es</tt> matches spine <tt>es</tt> against
--   copattern spine <tt>ps</tt>.
--   
--   Returns <a>Yes</a> and a substitution for the pattern variables (in
--   form of [Term]) if matching was successful.
--   
--   Returns <a>No</a> if there was a constructor or projection mismatch.
--   
--   Returns <a>DontKnow</a> if an argument could not be evaluated to
--   constructor form because of a blocking meta variable.
--   
--   In any case, also returns spine <tt>es</tt> in reduced form (with all
--   the weak head reductions performed that were necessary to come to a
--   decision).
matchCopatterns :: [NamedArg Pattern] -> [Elim] -> ReduceM (Match Term, [Elim])

-- | Match a single copattern.
matchCopattern :: Pattern -> Elim -> ReduceM (Match Term, Elim)
matchPatterns :: [NamedArg Pattern] -> [Arg Term] -> ReduceM (Match Term, [Arg Term])

-- | Match a single pattern.
matchPattern :: Pattern -> Arg Term -> ReduceM (Match Term, Arg Term)
yesSimplification :: (Match a, b) -> (Match a, b)
instance Functor Match
instance Monoid (Match a)


-- | Check that a datatype is strictly positive.
module Agda.TypeChecking.Positivity

-- | Check that the datatypes in the mutual block containing the given
--   declarations are strictly positive.
--   
--   Also add information about positivity and recursivity of records to
--   the signature.
checkStrictlyPositive :: Set QName -> TCM ()
getDefArity :: Definition -> TCM Int

-- | <a>Occurrence</a> is a complete lattice with least element
--   <a>Mixed</a> and greatest element <a>Unused</a>.
--   
--   It forms a commutative semiring where <a>oplus</a> is meet (glb) and
--   <a>otimes</a> is composition. Both operations are idempotent.
--   
--   For <a>oplus</a>, <a>Unused</a> is neutral (zero) and <a>Mixed</a> is
--   dominant. For <a>otimes</a>, <a>StrictPos</a> is neutral (one) and
--   <a>Unused</a> is dominant.

-- | Description of an occurrence.
data OccursWhere
LeftOfArrow :: OccursWhere -> OccursWhere

-- | in the nth argument of a define constant
DefArg :: QName -> Nat -> OccursWhere -> OccursWhere

-- | in the principal argument of built-in ∞
UnderInf :: OccursWhere -> OccursWhere

-- | as an argument to a bound variable
VarArg :: OccursWhere -> OccursWhere

-- | as an argument of a metavariable
MetaArg :: OccursWhere -> OccursWhere

-- | in the type of a constructor
ConArgType :: QName -> OccursWhere -> OccursWhere

-- | in a datatype index of a constructor
IndArgType :: QName -> OccursWhere -> OccursWhere

-- | in the nth clause of a defined function
InClause :: Nat -> OccursWhere -> OccursWhere

-- | matched against in a clause of a defined function
Matched :: OccursWhere -> OccursWhere

-- | in the definition of a constant
InDefOf :: QName -> OccursWhere -> OccursWhere
Here :: OccursWhere

-- | an unknown position (treated as negative)
Unknown :: OccursWhere
(>*<) :: OccursWhere -> OccursWhere -> OccursWhere
data Item
AnArg :: Nat -> Item
ADef :: QName -> Item
type Occurrences = Map Item [OccursWhere]
(>+<) :: Occurrences -> Occurrences -> Occurrences
concatOccurs :: [Occurrences] -> Occurrences
occursAs :: (OccursWhere -> OccursWhere) -> Occurrences -> Occurrences
here :: Item -> Occurrences

-- | <tt>onlyVarsUpTo n occs</tt> discards occurrences of de Bruijn index
--   <tt>&gt;= n</tt>.
onlyVarsUpTo :: Nat -> Occurrences -> Occurrences

-- | Context for computing occurrences.
data OccEnv
OccEnv :: [Maybe Item] -> Maybe QName -> OccEnv

-- | Items corresponding to the free variables.
vars :: OccEnv -> [Maybe Item]

-- | Name for ∞ builtin.
inf :: OccEnv -> Maybe QName

-- | Monad for computing occurrences.
type OccM = Reader OccEnv
withExtendedOccEnv :: Maybe Item -> OccM a -> OccM a

-- | Running the monad
getOccurrences :: ComputeOccurrences a => [Maybe Item] -> a -> TCM Occurrences
class ComputeOccurrences a
occurrences :: ComputeOccurrences a => a -> OccM Occurrences

-- | Compute the occurrences in a given definition.
computeOccurrences :: QName -> TCM Occurrences

-- | Eta expand a clause to have the given number of variables. Warning:
--   doesn't update telescope or permutation! This is used instead of
--   special treatment of lambdas (which was unsound: issue 121)
etaExpandClause :: Nat -> Clause -> Clause
data Node
DefNode :: QName -> Node
ArgNode :: QName -> Nat -> Node

-- | Pairing something with a node (for printing only).
data WithNode n a
WithNode :: n -> a -> WithNode n a

-- | Edge labels for the positivity graph.
data Edge
Edge :: Occurrence -> OccursWhere -> Edge

-- | These operations form a semiring if we quotient by the relation "the
--   <a>Occurrence</a> components are equal".
buildOccurrenceGraph :: Set QName -> TCM (Graph Node Edge)

-- | Given an <a>OccursWhere</a> computes the target node and an
--   <a>Edge</a>. The first argument is the set of names in the current
--   mutual block.
computeEdge :: Set QName -> OccursWhere -> TCM (Node, Edge)
instance Show OccursWhere
instance Eq OccursWhere
instance Eq Item
instance Ord Item
instance Show Item
instance Eq Node
instance Ord Node
instance Show Edge
instance SemiRing Edge
instance (PrettyTCM n, PrettyTCM (WithNode n e)) => PrettyTCM (Graph n e)
instance PrettyTCM n => PrettyTCM (WithNode n Occurrence)
instance PrettyTCM n => PrettyTCM (WithNode n Edge)
instance PrettyTCM Occurrence
instance PrettyTCM Node
instance Show Node
instance (ComputeOccurrences a, ComputeOccurrences b) => ComputeOccurrences (a, b)
instance ComputeOccurrences a => ComputeOccurrences [a]
instance ComputeOccurrences a => ComputeOccurrences (Dom a)
instance ComputeOccurrences a => ComputeOccurrences (Arg a)
instance ComputeOccurrences a => ComputeOccurrences (Elim' a)
instance ComputeOccurrences a => ComputeOccurrences (Abs a)
instance ComputeOccurrences a => ComputeOccurrences (Tele a)
instance ComputeOccurrences Type
instance ComputeOccurrences LevelAtom
instance ComputeOccurrences PlusLevel
instance ComputeOccurrences Level
instance ComputeOccurrences Term
instance ComputeOccurrences Clause
instance PrettyTCM OccursWhere
instance SemiRing Occurrence

module Agda.TypeChecking.ProjectionLike

-- | View for a <tt>Def f (Apply a : es)</tt> where <tt>isProjection
--   f</tt>. Used for projection-like <tt>f</tt>s.
data ProjectionView

-- | A projection or projection-like function, applied to its principal
--   argument
ProjectionView :: QName -> Arg Term -> Elims -> ProjectionView
projViewProj :: ProjectionView -> QName
projViewSelf :: ProjectionView -> Arg Term
projViewSpine :: ProjectionView -> Elims

-- | Just a lone projection-like function, missing its principal argument
--   (from which we could infer the parameters).
LoneProjectionLike :: QName -> ArgInfo -> ProjectionView

-- | Not a projection or projection-like thing.
NoProjection :: Term -> ProjectionView

-- | Semantics of <a>ProjectionView</a>.
unProjView :: ProjectionView -> Term

-- | Top-level <a>ProjectionView</a> (no reduction).
projView :: Term -> TCM ProjectionView

-- | Reduce away top-level projection like functions. (Also reduces
--   projections, but they should not be there, since Internal is in
--   lambda- and projection-beta-normal form.)
reduceProjectionLike :: Term -> TCM Term

-- | Turn prefix projection-like function application into postfix ones.
--   This does just one layer, such that the top spine contains the
--   projection-like functions as projections. Used in
--   <tt>compareElims</tt> in <tt>TypeChecking.Conversion</tt> and in
--   <a>CheckInternal</a>.
--   
--   If the <a>Bool</a> is <a>True</a>, a lone projection like function
--   will be turned into a lambda-abstraction, expecting the principal
--   argument. If the <a>Bool</a> is <a>False</a>, it will be returned
--   unaltered.
--   
--   No precondition. Preserves constructorForm, since it really does only
--   something on (applications of) projection-like functions.
elimView :: Bool -> Term -> TCM Term

-- | Which <tt>Def</tt>types are eligible for the principle argument of a
--   projection-like function?
eligibleForProjectionLike :: QName -> TCM Bool

-- | Turn a definition into a projection if it looks like a projection.
makeProjection :: QName -> TCM ()

module Agda.TypeChecking.Quote
data QuotingKit
QuotingKit :: (Term -> ReduceM Term) -> (Type -> ReduceM Term) -> (Clause -> ReduceM Term) -> (Dom Type -> ReduceM Term) -> QuotingKit
quoteTermWithKit :: QuotingKit -> Term -> ReduceM Term
quoteTypeWithKit :: QuotingKit -> Type -> ReduceM Term
quoteClauseWithKit :: QuotingKit -> Clause -> ReduceM Term
quoteDomWithKit :: QuotingKit -> Dom Type -> ReduceM Term
quotingKit :: TCM QuotingKit
quoteName :: QName -> Term
quoteConName :: ConHead -> Term
quoteTerm :: Term -> TCM Term
quoteType :: Type -> TCM Term


-- | Primitive functions, such as addition on builtin integers.
module Agda.TypeChecking.Primitive
data PrimitiveImpl
PrimImpl :: Type -> PrimFun -> PrimitiveImpl
newtype Nat
Nat :: Integer -> Nat
unNat :: Nat -> Integer
newtype Lvl
Lvl :: Integer -> Lvl
unLvl :: Lvl -> Integer
class PrimType a
primType :: PrimType a => a -> TCM Type
class PrimTerm a
primTerm :: PrimTerm a => a -> TCM Term
class ToTerm a where toTermR = (pure .) <$> toTerm
toTerm :: ToTerm a => TCM (a -> Term)
toTermR :: ToTerm a => TCM (a -> ReduceM Term)

-- | <tt>buildList A ts</tt> builds a list of type <tt>List A</tt>. Assumes
--   that the terms <tt>ts</tt> all have type <tt>A</tt>.
buildList :: TCM ([Term] -> Term)
type FromTermFunction a = Arg Term -> ReduceM (Reduced (MaybeReduced (Arg Term)) a)
class FromTerm a
fromTerm :: FromTerm a => TCM (FromTermFunction a)

-- | Conceptually: <tt>redBind m f k = either (return . Left . f) k
--   =&lt;&lt; m</tt>
redBind :: ReduceM (Reduced a a') -> (a -> b) -> (a' -> ReduceM (Reduced b b')) -> ReduceM (Reduced b b')
redReturn :: a -> ReduceM (Reduced a' a)
fromReducedTerm :: (Term -> Maybe a) -> TCM (FromTermFunction a)
fromLiteral :: (Literal -> Maybe a) -> TCM (FromTermFunction a)
primTrustMe :: TCM PrimitiveImpl
primQNameType :: TCM PrimitiveImpl
primQNameDefinition :: TCM PrimitiveImpl
primDataConstructors :: TCM PrimitiveImpl
mkPrimLevelZero :: TCM PrimitiveImpl
mkPrimLevelSuc :: TCM PrimitiveImpl
mkPrimLevelMax :: TCM PrimitiveImpl
mkPrimFun1TCM :: (FromTerm a, ToTerm b) => TCM Type -> (a -> ReduceM b) -> TCM PrimitiveImpl
mkPrimFun1 :: (PrimType a, PrimType b, FromTerm a, ToTerm b) => (a -> b) -> TCM PrimitiveImpl
mkPrimFun2 :: (PrimType a, PrimType b, PrimType c, FromTerm a, ToTerm a, FromTerm b, ToTerm c) => (a -> b -> c) -> TCM PrimitiveImpl
mkPrimFun4 :: (PrimType a, FromTerm a, ToTerm a, PrimType b, FromTerm b, ToTerm b, PrimType c, FromTerm c, ToTerm c, PrimType d, FromTerm d, PrimType e, ToTerm e) => (a -> b -> c -> d -> e) -> TCM PrimitiveImpl
(-->) :: TCM Type -> TCM Type -> TCM Type
(.-->) :: TCM Type -> TCM Type -> TCM Type
gpi :: ArgInfo -> String -> TCM Type -> TCM Type -> TCM Type
hPi :: String -> TCM Type -> TCM Type -> TCM Type
nPi :: String -> TCM Type -> TCM Type -> TCM Type
varM :: Int -> TCM Term
gApply :: Hiding -> TCM Term -> TCM Term -> TCM Term
(<@>) :: TCM Term -> TCM Term -> TCM Term
(<#>) :: TCM Term -> TCM Term -> TCM Term
list :: TCM Term -> TCM Term
io :: TCM Term -> TCM Term
el :: TCM Term -> TCM Type
tset :: TCM Type

-- | Abbreviation: <tt>argN = <a>Arg</a> <a>defaultArgInfo</a></tt>.
argN :: e -> Arg e
domN :: e -> Dom e

-- | Abbreviation: <tt>argH = <a>hide</a> <a>Arg</a>
--   <a>defaultArgInfo</a></tt>.
argH :: e -> Arg e
domH :: e -> Dom e
type Op a = a -> a -> a
type Fun a = a -> a
type Rel a = a -> a -> Bool
type Pred a = a -> Bool
primitiveFunctions :: Map String (TCM PrimitiveImpl)
lookupPrimitiveFunction :: String -> TCM PrimitiveImpl
lookupPrimitiveFunctionQ :: QName -> TCM (String, PrimitiveImpl)
instance Eq Nat
instance Ord Nat
instance Num Nat
instance Enum Nat
instance Real Nat
instance Eq Lvl
instance Ord Lvl
instance (ToTerm a, FromTerm a) => FromTerm [a]
instance FromTerm Bool
instance FromTerm QName
instance FromTerm Str
instance FromTerm Char
instance FromTerm Double
instance FromTerm Lvl
instance FromTerm Nat
instance FromTerm Integer
instance (PrimTerm a, ToTerm a) => ToTerm [a]
instance ToTerm ArgInfo
instance ToTerm Type
instance ToTerm Term
instance ToTerm Bool
instance ToTerm QName
instance ToTerm Str
instance ToTerm Char
instance ToTerm Double
instance ToTerm Lvl
instance ToTerm Nat
instance ToTerm Integer
instance PrimTerm a => PrimTerm (IO a)
instance PrimTerm a => PrimTerm [a]
instance PrimTerm Type
instance PrimTerm QName
instance PrimTerm Lvl
instance PrimTerm Nat
instance PrimTerm Str
instance PrimTerm Double
instance PrimTerm Char
instance PrimTerm Bool
instance PrimTerm Integer
instance PrimTerm a => PrimType a
instance (PrimType a, PrimType b) => PrimTerm (a -> b)
instance Show Nat
instance Show Lvl
instance Integral Nat

module Agda.TypeChecking.Injectivity
headSymbol :: Term -> TCM (Maybe TermHead)
checkInjectivity :: QName -> [Clause] -> TCM FunctionInverse

-- | Argument should be in weak head normal form.
functionInverse :: Term -> TCM InvView
data InvView
Inv :: QName -> [Elim] -> (Map TermHead Clause) -> InvView
NoInv :: InvView
data MaybeAbort
Abort :: MaybeAbort
KeepGoing :: MaybeAbort
useInjectivity :: Comparison -> Type -> Term -> Term -> TCM ()

module Agda.TypeChecking.Conversion

-- | Try whether a computation runs without errors or new constraints.
--   Restores state upon failure.
tryConversion :: TCM () -> TCM Bool

-- | Check if to lists of arguments are the same (and all variables).
--   Precondition: the lists have the same length.
sameVars :: Elims -> Elims -> Bool

-- | <tt>intersectVars us vs</tt> checks whether all relevant elements in
--   <tt>us</tt> and <tt>vs</tt> are variables, and if yes, returns a prune
--   list which says <tt>True</tt> for arguments which are different and
--   can be pruned.
intersectVars :: Elims -> Elims -> Maybe [Bool]
equalTerm :: Type -> Term -> Term -> TCM ()
equalAtom :: Type -> Term -> Term -> TCM ()
equalType :: Type -> Type -> TCM ()

-- | Ignore errors in irrelevant context.
convError :: TypeError -> TCM ()

-- | Type directed equality on values.
compareTerm :: Comparison -> Type -> Term -> Term -> TCM ()
unifyPointers :: Comparison -> Term -> Term -> TCM () -> TCM ()

-- | Try to assign meta. If meta is projected, try to eta-expand and run
--   conversion check again.
assignE :: CompareDirection -> MetaId -> Elims -> Term -> (Term -> Term -> TCM ()) -> TCM ()
compareTermDir :: CompareDirection -> Type -> Term -> Term -> TCM ()
compareTerm' :: Comparison -> Type -> Term -> Term -> TCM ()

-- | <tt>compareTel t1 t2 cmp tel1 tel1</tt> checks whether pointwise
--   <tt>tel1 `cmp` tel2</tt> and complains that <tt>t2 `cmp` t1</tt>
--   failed if not.
compareTel :: Type -> Type -> Comparison -> Telescope -> Telescope -> TCM ()

-- | Raise <a>UnequalTerms</a> if there is no hope that by meta solving and
--   subsequent eta-contraction these terms could become equal.
--   Precondition: the terms are in reduced form (with no top-level
--   pointer) and failed to be equal in the <a>compareAtom</a> check.
--   
--   By eta-contraction, a lambda or a record constructor term can become
--   anything.
etaInequal :: Comparison -> Type -> Term -> Term -> TCM ()
compareAtomDir :: CompareDirection -> Type -> Term -> Term -> TCM ()

-- | Syntax directed equality on atomic values
compareAtom :: Comparison -> Type -> Term -> Term -> TCM ()
compareRelevance :: Comparison -> Relevance -> Relevance -> Bool

-- | <tt>compareElims pols a v els1 els2</tt> performs type-directed
--   equality on eliminator spines. <tt>t</tt> is the type of the head
--   <tt>v</tt>.
compareElims :: [Polarity] -> Type -> Term -> [Elim] -> [Elim] -> TCM ()

-- | <a>Compare</a> two terms in irrelevant position. This always succeeds.
--   However, we can dig for solutions of irrelevant metas in the terms we
--   compare. (Certainly not the systematic solution, that'd be proof
--   search...)
compareIrrelevant :: Type -> Term -> Term -> TCM ()
compareWithPol :: Polarity -> (Comparison -> a -> a -> TCM ()) -> a -> a -> TCM ()

-- | Type-directed equality on argument lists
compareArgs :: [Polarity] -> Type -> Term -> Args -> Args -> TCM ()

-- | Equality on Types
compareType :: Comparison -> Type -> Type -> TCM ()
leqType :: Type -> Type -> TCM ()

-- | <tt>coerce v a b</tt> coerces <tt>v : a</tt> to type <tt>b</tt>,
--   returning a <tt>v' : b</tt> with maybe extra hidden applications or
--   hidden abstractions.
--   
--   In principle, this function can host coercive subtyping, but currently
--   it only tries to fix problems with hidden function types.
coerce :: Term -> Type -> Type -> TCM Term

-- | Account for situations like <tt>k : (Size&lt; j) &lt;= (Size&lt; k +
--   1)</tt>
--   
--   Actually, the semantics is <tt>(Size&lt;= k) ∩ (Size&lt; j) ⊆ rhs</tt>
--   which gives a disjunctive constraint. Mmmh, looks like stuff TODO.
--   
--   For now, we do a cheap heuristics.
coerceSize :: Term -> Type -> Type -> TCM Term
compareLevel :: Comparison -> Level -> Level -> TCM ()
compareSort :: Comparison -> Sort -> Sort -> TCM ()

-- | Check that the first sort is less or equal to the second.
leqSort :: Sort -> Sort -> TCM ()
leqLevel :: Level -> Level -> TCM ()
equalLevel :: Level -> Level -> TCM ()

-- | Check that the first sort equal to the second.
equalSort :: Sort -> Sort -> TCM ()
bothAbsurd :: QName -> QName -> TCM Bool

module Agda.TypeChecking.Rules.LHS.Unify
newtype Unify a
U :: ReaderT UnifyEnv (WriterT UnifyOutput (ExceptionT UnifyException (StateT UnifyState TCM))) a -> Unify a
unUnify :: Unify a -> ReaderT UnifyEnv (WriterT UnifyOutput (ExceptionT UnifyException (StateT UnifyState TCM))) a
data UnifyMayPostpone
MayPostpone :: UnifyMayPostpone
MayNotPostpone :: UnifyMayPostpone
type UnifyEnv = UnifyMayPostpone
emptyUEnv :: UnifyEnv
noPostponing :: Unify a -> Unify a
askPostpone :: Unify UnifyMayPostpone

-- | Output the result of unification (success or maybe).
type UnifyOutput = Unifiable

-- | Were two terms unifiable or did we have to postpone some equation such
--   that we are not sure?
data Unifiable

-- | Unification succeeded.
Definitely :: Unifiable

-- | Unification did not fail, but we had to postpone a part.
Possibly :: Unifiable

-- | Conjunctive monoid.

-- | Tell that something could not be unified right now, so the unification
--   succeeds only <a>Possibly</a>.
reportPostponing :: Unify ()

-- | Check whether unification proceeded without postponement.
ifClean :: Unify () -> Unify a -> Unify a -> Unify a
data Equality
Equal :: TypeHH -> Term -> Term -> Equality
type Sub = IntMap Term
data UnifyException
ConstructorMismatch :: Type -> Term -> Term -> UnifyException
StronglyRigidOccurrence :: Type -> Term -> Term -> UnifyException
UnclearOccurrence :: Type -> Term -> Term -> UnifyException
WithoutKException :: Type -> Term -> Term -> UnifyException
GenericUnifyException :: String -> UnifyException
data UnifyState
USt :: Sub -> [Equality] -> UnifyState
uniSub :: UnifyState -> Sub
uniConstr :: UnifyState -> [Equality]
emptyUState :: UnifyState

-- | Throw-away error message.
projectionMismatch :: QName -> QName -> Unify a
constructorMismatch :: Type -> Term -> Term -> Unify a
constructorMismatchHH :: TypeHH -> Term -> Term -> Unify a
getSub :: Unify Sub
modSub :: (Sub -> Sub) -> Unify ()
checkEqualities :: [Equality] -> TCM ()

-- | Force equality now instead of postponing it using <a>addEquality</a>.
checkEquality :: Type -> Term -> Term -> TCM ()

-- | Try equality. If constraints remain, postpone (enter unsafe mode).
--   Heterogeneous equalities cannot be tried nor reawakened, so we can
--   throw them away and flag "dirty".
checkEqualityHH :: TypeHH -> Term -> Term -> Unify ()

-- | Check whether heterogeneous situation is really homogeneous. If not,
--   give up.
forceHom :: TypeHH -> TCM Type

-- | Check whether heterogeneous situation is really homogeneous. If not,
--   return Nothing.
makeHom :: TypeHH -> TCM (Maybe Type)
addEquality :: Type -> Term -> Term -> Unify ()
addEqualityHH :: TypeHH -> Term -> Term -> Unify ()
takeEqualities :: Unify [Equality]

-- | Includes flexible occurrences, metas need to be solved. TODO: relax?
--   TODO: later solutions may remove flexible occurences
occursCheck :: Nat -> Term -> Type -> Unify ()

-- | Assignment with preceding occurs check.
(|->) :: Nat -> (Term, Type) -> Unify ()
makeSubstitution :: Sub -> Substitution

-- | Apply the current substitution on a term and reduce to weak head
--   normal form.
class UReduce t
ureduce :: UReduce t => t -> Unify t

-- | Take a substitution σ and ensure that no variables from the domain
--   appear in the targets. The context of the targets is not changed.
--   TODO: can this be expressed using makeSubstitution and applySubst?
flattenSubstitution :: Substitution -> Substitution
data UnificationResult
Unifies :: Substitution -> UnificationResult
NoUnify :: Type -> Term -> Term -> UnificationResult
DontKnow :: TCErr -> UnificationResult

-- | Are we in a homogeneous (one type) or heterogeneous (two types)
--   situation?
data HomHet a

-- | homogeneous
Hom :: a -> HomHet a

-- | heterogeneous
Het :: a -> a -> HomHet a
isHom :: HomHet a -> Bool
fromHom :: HomHet a -> a
leftHH :: HomHet a -> a
rightHH :: HomHet a -> a
type TermHH = HomHet Term
type TypeHH = HomHet Type
type TelHH = Tele (Dom TypeHH)
type TelViewHH = TelV TypeHH
type ArgsHH = HomHet Args
absAppHH :: SubstHH t tHH => Abs t -> TermHH -> tHH
class ApplyHH t
applyHH :: ApplyHH t => t -> HomHet Args -> HomHet t
substHH :: SubstHH t tHH => TermHH -> t -> tHH

-- | <tt>substHH u t</tt> substitutes <tt>u</tt> for the 0th variable in
--   <tt>t</tt>.
class SubstHH t tHH
substUnderHH :: SubstHH t tHH => Nat -> TermHH -> t -> tHH
trivialHH :: SubstHH t tHH => t -> tHH

-- | Unify indices.
--   
--   In <tt>unifyIndices_ flex a us vs</tt>,
--   
--   <tt>a</tt> is the type eliminated by <tt>us</tt> and <tt>vs</tt>
--   (usally the type of a constructor), need not be reduced,
--   
--   <tt>us</tt> and <tt>vs</tt> are the argument lists to unify,
--   
--   <tt>flex</tt> is the set of flexible (instantiable) variabes in
--   <tt>us</tt> and <tt>vs</tt>.
--   
--   The result is the most general unifier of <tt>us</tt> and <tt>vs</tt>.
unifyIndices_ :: MonadTCM tcm => FlexibleVars -> Type -> Args -> Args -> tcm Substitution
unifyIndices :: MonadTCM tcm => FlexibleVars -> Type -> Args -> Args -> tcm UnificationResult

-- | Given the type of a constructor application the corresponding data or
--   record type, applied to its parameters (extracted from the given
--   type), is returned.
--   
--   Precondition: The type has to correspond to an application of the
--   given constructor.
dataOrRecordType :: ConHead -> Type -> TCM (Maybe Type)
dataOrRecordType' :: ConHead -> Type -> TCM (Maybe (QName, Type, Args, Args))

-- | Heterogeneous situation. <tt>a1</tt> and <tt>a2</tt> need to end in
--   same datatype/record.
dataOrRecordTypeHH :: ConHead -> TypeHH -> TCM (Maybe TypeHH)
dataOrRecordTypeHH' :: ConHead -> TypeHH -> TCM (Maybe (QName, HomHet (Type, Args, Args)))

-- | Return record type identifier if argument is a record type.
isEtaRecordTypeHH :: MonadTCM tcm => TypeHH -> tcm (Maybe (QName, HomHet Args))

-- | Views an expression (pair) as type shape. Fails if not same shape.
data ShapeView a
PiSh :: (Dom a) -> (Abs a) -> ShapeView a
FunSh :: (Dom a) -> a -> ShapeView a

-- | data/record
DefSh :: QName -> ShapeView a

-- | neutral type
VarSh :: Nat -> ShapeView a

-- | built-in type
LitSh :: Literal -> ShapeView a
SortSh :: ShapeView a

-- | some meta
MetaSh :: ShapeView a

-- | not a type or not definitely same shape
ElseSh :: ShapeView a

-- | Return the type and its shape. Expects input in (u)reduced form.
shapeView :: Type -> Unify (Type, ShapeView Type)

-- | Return the reduced type(s) and the common shape.
shapeViewHH :: TypeHH -> Unify (TypeHH, ShapeView TypeHH)

-- | <tt>telViewUpToHH n t</tt> takes off the first <tt>n</tt> function
--   types of <tt>t</tt>. Takes off all if $n &lt; 0$.
telViewUpToHH :: Int -> TypeHH -> Unify TelViewHH
instance Typeable HomHet
instance Typeable ShapeView
instance Show a => Show (HomHet a)
instance Eq a => Eq (HomHet a)
instance Ord a => Ord (HomHet a)
instance Functor HomHet
instance Foldable HomHet
instance Traversable HomHet
instance Monad Unify
instance MonadIO Unify
instance Functor Unify
instance Applicative Unify
instance MonadException UnifyException Unify
instance MonadWriter UnifyOutput Unify
instance Show a => Show (ShapeView a)
instance (Eq a, Subst a) => Eq (ShapeView a)
instance (Ord a, Subst a) => Ord (ShapeView a)
instance Functor ShapeView
instance SubstHH a b => SubstHH (Tele a) (Tele b)
instance (SubstHH a a', SubstHH b b') => SubstHH (a, b) (a', b')
instance SubstHH a b => SubstHH (Abs a) (Abs b)
instance SubstHH a b => SubstHH (Dom a) (Dom b)
instance SubstHH a b => SubstHH (Arg a) (Arg b)
instance SubstHH Type (HomHet Type)
instance SubstHH Term (HomHet Term)
instance (Free a, Subst a) => SubstHH (HomHet a) (HomHet a)
instance ApplyHH Type
instance ApplyHH Term
instance PrettyTCM a => PrettyTCM (HomHet a)
instance Subst a => Subst (HomHet a)
instance UReduce a => UReduce [a]
instance UReduce a => UReduce (Arg a)
instance (UReduce a, UReduce b, UReduce c) => UReduce (a, b, c)
instance (UReduce a, UReduce b) => UReduce (a, b)
instance UReduce t => UReduce (Maybe t)
instance UReduce t => UReduce (HomHet t)
instance UReduce Type
instance UReduce Term
instance Subst Equality
instance Error UnifyException
instance Monoid Unifiable
instance HasConstInfo Unify
instance MonadReader TCEnv Unify
instance MonadState TCState Unify
instance MonadTCM Unify

module Agda.Compiler.Epic.Forcing

-- | Returns how many parameters a datatype has
dataParameters :: QName -> Compile TCM Nat

-- | Returns how many parameters a datatype has
dataParametersTCM :: QName -> TCM Nat
report :: Int -> TCM Doc -> Compile TCM ()
piApplyM' :: Type -> Args -> TCM Type

-- | insertTele i xs t tele tpos tele := Gamma ; (i : T as) ; Delta n :=
--   parameters T xs' := xs <a>apply</a> (take n as) becomes tpos ( Gamma ;
--   xs' ; Delta[i := t] --note that Delta still reference Gamma correctly
--   , T as ^ (size xs') )
--   
--   we raise the type since we have added xs' new bindings before Gamma,
--   and as can only bind to Gamma.
insertTele :: (QName, Args) -> Int -> Maybe Type -> Term -> Telescope -> Compile TCM (Telescope, (Telescope, Type, Type))
mkCon :: QName -> Int -> Term
unifyI :: Telescope -> FlexibleVars -> Type -> Args -> Args -> Compile TCM [Maybe Term]
takeTele :: Int -> Telescope -> Telescope

-- | Main function for removing pattern matching on forced variables
remForced :: [Fun] -> Compile TCM [Fun]

-- | For a given expression, in a certain telescope (the list of Var) is a
--   mapping of variable name to the telescope.
forcedExpr :: [Var] -> Telescope -> Expr -> Compile TCM Expr

-- | replace the forcedVar with pattern matching from the outside.
replaceForced :: ([Var], [Var]) -> Telescope -> [Var] -> [Maybe Term] -> Expr -> Compile TCM Expr

-- | Given a term containg the forced var, dig out the variable by
--   inserting the proper case-expressions.
buildTerm :: Var -> Nat -> Term -> Compile TCM (Expr -> Expr, Var)

-- | Find the location where a certain Variable index is by searching the
--   constructors aswell. i.e find a term that can be transformed into a
--   pattern that contains the same value the index. This fails if no such
--   term is present.
findPosition :: Nat -> [Maybe Term] -> Compile TCM (Maybe (Nat, Term))


-- | A bidirectional type checker for internal syntax.
--   
--   Performs checking on unreduced terms. With the exception that
--   projection-like function applications have to be reduced since they
--   break bidirectionality.
module Agda.TypeChecking.CheckInternal

-- | Entry point for e.g. checking WithFunctionType.
checkType :: Type -> TCM ()

-- | Entry point for term checking.
checkInternal :: Term -> Type -> TCM ()

module Agda.TypeChecking.Rules.Data

-- | Type check a datatype definition. Assumes that the type has already
--   been checked.
checkDataDef :: DefInfo -> QName -> [LamBinding] -> [Constructor] -> TCM ()

-- | A parameter is small if its sort fits into the data sort.
--   <tt>smallParams</tt> overapproximates the small parameters (in doubt:
--   small).
smallParams :: Telescope -> Sort -> TCM [Int]

-- | Type check a constructor declaration. Checks that the constructor
--   targets the datatype and that it fits inside the declared sort.
--   Returns the non-linear parameters.
checkConstructor :: QName -> Telescope -> Nat -> Sort -> Constructor -> TCM [Int]

-- | Bind the parameters of a datatype.
bindParameters :: [LamBinding] -> Type -> (Telescope -> Type -> TCM a) -> TCM a

-- | Check that the arguments to a constructor fits inside the sort of the
--   datatype. The first argument is the type of the constructor.
fitsIn :: Type -> Sort -> TCM ()

-- | Return the parameters that share variables with the indices
--   nonLinearParameters :: Int -&gt; Type -&gt; TCM [Int]
--   nonLinearParameters nPars t =
--   
--   Check that a type constructs something of the given datatype. The
--   first argument is the number of parameters to the datatype.
--   
--   As a side effect, return the parameters that occur free in indices.
--   E.g. in <tt>data Eq (A : Set)(a : A) : A -&gt; Set where refl : Eq A a
--   a</tt> this would include parameter <tt>a</tt>, but not <tt>A</tt>.
--   
--   TODO: what if there's a meta here?
constructs :: Int -> Type -> QName -> TCM [Int]

-- | Is the type coinductive? Returns <a>Nothing</a> if the answer cannot
--   be determined.
isCoinductive :: Type -> TCM (Maybe Bool)


-- | Solving size constraints under hypotheses.
--   
--   The size solver proceeds as follows:
--   
--   <ol>
--   <li>Get size constraints, cluster into connected components.All size
--   constraints that mention the same metas go into the same cluster. Each
--   cluster can be solved by itself.Constraints that do not fit our format
--   are ignored. We check whether our computed solution fulfills them as
--   well in the last step.</li>
--   <li>Find a joint context for each cluster.Each constraint comes with
--   its own typing context, which contains size hypotheses <tt>j :
--   Size&lt; i</tt>. We need to find a common super context in which all
--   constraints of a cluster live, and raise all constraints to this
--   context.This involves migrating from de Bruijn indices to de Bruijn
--   levels.There might not be a common super context. Then we are screwed,
--   since our solver is not ready to deal with such a situation. We will
--   blatantly refuse to solve this cluster and blame it on the user.</li>
--   <li>Convert the joint context into a hypothesis graph.This is
--   straightforward. Each de Bruijn level becomes a rigid variable, each
--   typing assumption <tt>j : Size&lt; i</tt> becomes an arc.</li>
--   <li>Convert the constraints into a constraint graph.Here we need to
--   convert <tt>MetaV</tt>s into flexible variables.</li>
--   <li>Run the solver</li>
--   <li>Convert the solution into meta instantiations.</li>
--   <li>Double-check whether the constraints are solved.</li>
--   </ol>
module Agda.TypeChecking.SizedTypes.Solve

-- | Solve size constraints involving hypotheses.
solveSizeConstraints :: TCM ()
solveSizeConstraints_ :: [Closure Constraint] -> TCM ()
solveCluster :: [HypSizeConstraint] -> TCM ()

-- | Collect constraints from a typing context, looking for SIZELT
--   hypotheses.
getSizeHypotheses :: Context -> TCM [(CtxId, SizeConstraint)]

-- | Convert size constraint into form where each meta is applied to
--   indices <tt>0,1,..,n-1</tt> where <tt>n</tt> is the arity of that
--   meta.
--   
--   <tt>X[σ] &lt;= t</tt> beomes <tt>X[id] &lt;= t[σ^-1]</tt>
--   
--   <tt>X[σ] ≤ Y[τ]</tt> becomes <tt>X[id] ≤ Y[τ[σ^-1]]</tt> or
--   <tt>X[σ[τ^1]] ≤ Y[id]</tt> whichever is defined. If none is defined,
--   we give up.
canonicalizeSizeConstraint :: SizeConstraint -> Maybe (SizeConstraint)

-- | Identifiers for rigid variables.
data NamedRigid
NamedRigid :: String -> Int -> NamedRigid

-- | Name for printing in debug messages.
rigidName :: NamedRigid -> String

-- | De Bruijn index.
rigidIndex :: NamedRigid -> Int

-- | Size metas in size expressions.
data SizeMeta
SizeMeta :: MetaId -> [Int] -> SizeMeta
sizeMetaId :: SizeMeta -> MetaId
sizeMetaArgs :: SizeMeta -> [Int]

-- | An equality which ignores the meta arguments.

-- | An order which ignores the meta arguments.

-- | Size expression with de Bruijn indices.
type DBSizeExpr = SizeExpr' NamedRigid SizeMeta

-- | Only for <a>raise</a>.
type SizeConstraint = Constraint' NamedRigid SizeMeta

-- | Assumes we are in the right context.

-- | Size constraint with de Bruijn indices.
data HypSizeConstraint
HypSizeConstraint :: Context -> [CtxId] -> [SizeConstraint] -> SizeConstraint -> HypSizeConstraint
sizeContext :: HypSizeConstraint -> Context
sizeHypIds :: HypSizeConstraint -> [CtxId]
sizeHypotheses :: HypSizeConstraint -> [SizeConstraint]
sizeConstraint :: HypSizeConstraint -> SizeConstraint

-- | Turn a constraint over de Bruijn indices into a size constraint.
computeSizeConstraint :: Closure Constraint -> TCM (Maybe HypSizeConstraint)

-- | Turn a term into a size expression.
--   
--   Returns <a>Nothing</a> if the term isn't a proper size expression.
sizeExpr :: Term -> TCM (Maybe DBSizeExpr)

-- | Turn a de size expression into a term.
unSizeExpr :: DBSizeExpr -> TCM Term
instance PrettyTCM HypSizeConstraint
instance Flexs SizeMeta HypSizeConstraint
instance PrettyTCM SizeConstraint
instance Subst SizeConstraint
instance Subst (SizeExpr' NamedRigid SizeMeta)
instance Subst SizeMeta
instance PrettyTCM SizeMeta
instance Ord SizeMeta
instance Eq SizeMeta
instance Plus NamedRigid Int NamedRigid
instance Show NamedRigid
instance Ord NamedRigid
instance Eq NamedRigid

module Agda.TypeChecking.Unquote
agdaTermType :: TCM Type
qNameType :: TCM Type
type UnquoteM = ExceptionT UnquoteError TCM
runUnquoteM :: UnquoteM a -> TCM (Either UnquoteError a)
isCon :: ConHead -> TCM Term -> UnquoteM Bool
class Unquote a
unquote :: Unquote a => Term -> UnquoteM a
unquoteH :: Unquote a => Arg Term -> UnquoteM a
unquoteN :: Unquote a => Arg Term -> UnquoteM a
choice :: Monad m => [(m Bool, m a)] -> m a -> m a
ensureDef :: QName -> UnquoteM QName
ensureCon :: QName -> UnquoteM QName
pickName :: Type -> String
data UnquotedFunDef
UnQFun :: Type -> [Clause] -> UnquotedFunDef
reifyUnquoted :: Reify a e => a -> TCM e
instance Unquote UnquotedFunDef
instance Unquote Clause
instance Unquote Pattern
instance Unquote Term
instance Unquote Literal
instance Unquote Type
instance Unquote Level
instance Unquote Sort
instance Unquote a => Unquote (Abs a)
instance Unquote ConHead
instance Unquote QName
instance Unquote Relevance
instance Unquote Hiding
instance Unquote a => Unquote [a]
instance Unquote Str
instance Unquote Char
instance Unquote Double
instance Unquote Integer
instance Unquote a => Unquote (Elim' a)
instance Unquote a => Unquote (Arg a)
instance Unquote ArgInfo

module Agda.TypeChecking.Rules.LHS.Split

-- | Split a problem at the first constructor pattern which is actually of
--   datatype type.
--   
--   Or, if there is no constructor pattern left and the rest type is a
--   record type and the first rest pattern is a projection pattern, split
--   the rest type.
--   
--   Implicit patterns should have been inserted.
splitProblem :: Maybe QName -> Problem -> TCM (Either SplitError SplitProblem)

module Agda.TypeChecking.Rules.LHS.Implicit

-- | Insert implicit patterns in a problem.
insertImplicitProblem :: Problem -> TCM Problem

-- | Eta-expand implicit pattern if of record type.
expandImplicitPattern :: Type -> NamedArg Pattern -> TCM (NamedArg Pattern)

-- | Try to eta-expand implicit pattern. Returns <a>Nothing</a> unless
--   dealing with a record type that has eta-expansion and a constructor
--   <tt>c</tt>. In this case, it returns <a>Just</a> <tt>c _ _ ... _</tt>
--   (record constructor applied to as many implicit patterns as there are
--   fields).
expandImplicitPattern' :: Type -> NamedArg Pattern -> TCM (Maybe (NamedArg Pattern))
implicitP :: Named_ Pattern

-- | Insert implicit patterns in a list of patterns.
insertImplicitPatterns :: ExpandHidden -> [NamedArg Pattern] -> Telescope -> TCM [NamedArg Pattern]
insertImplicitPatternsT :: ExpandHidden -> [NamedArg Pattern] -> Type -> TCM [NamedArg Pattern]

module Agda.TypeChecking.With
withFunctionType :: Telescope -> [Term] -> [Type] -> Telescope -> Type -> TCM Type

-- | Compute the clauses for the with-function given the original patterns.
buildWithFunction :: QName -> Telescope -> [NamedArg Pattern] -> Permutation -> Nat -> Nat -> [SpineClause] -> TCM [SpineClause]

-- | <pre>
--   stripWithClausePatterns Γ qs π ps = ps'
--   </pre>
--   
--   <tt>Δ</tt> - context bound by lhs of original function (not an
--   argument)
--   
--   <tt>Γ</tt> - type of arguments to original function
--   
--   <tt>qs</tt> - internal patterns for original function
--   
--   <tt>π</tt> - permutation taking <tt>vars(qs)</tt> to
--   <tt>support(Δ)</tt>
--   
--   <tt>ps</tt> - patterns in with clause (presumably of type <tt>Γ</tt>)
--   
--   <tt>ps'</tt> - patterns for with function (presumably of type
--   <tt>Δ</tt>)
stripWithClausePatterns :: Telescope -> [NamedArg Pattern] -> Permutation -> [NamedArg Pattern] -> TCM [NamedArg Pattern]

-- | Construct the display form for a with function. It will display
--   applications of the with function as applications to the original
--   function. For instance, <tt>aux a b c</tt> as <tt>f (suc a) (suc b) |
--   c</tt>
--   
--   <tt>n</tt> is the number of with arguments.
withDisplayForm :: QName -> QName -> Telescope -> Telescope -> Nat -> [NamedArg Pattern] -> Permutation -> Permutation -> TCM DisplayForm
patsToTerms :: Permutation -> [NamedArg Pattern] -> [Arg DisplayTerm]

module Agda.TypeChecking.Rules.LHS.ProblemRest

-- | Rename the variables in a telescope using the names from a given
--   pattern
useNamesFromPattern :: [NamedArg Pattern] -> Telescope -> Telescope

-- | Are there any untyped user patterns left?
noProblemRest :: Problem -> Bool

-- | Construct an initial <tt>split</tt> <a>Problem</a> from user patterns.
--   Example: @
--   
--   Case : {A : Set} → Maybe A → Set → Set → Set Case nothing B C = B Case
--   (just _) B C = C
--   
--   sample : {A : Set} (m : Maybe A) → Case m Bool (Maybe A → Bool) sample
--   (just a) (just b) = true sample (just a) nothing = false sample
--   nothing = true <tt> The problem generated for the first clause of
--   </tt>sample<tt> with patterns </tt>just a, just b<tt> would be: </tt>
--   problemInPat = ["_", "just a"] problemOutPat = [identity-permutation,
--   [<a>A</a>, "m"]] problemTel = [A : Set, m : Maybe A] problemRest =
--   restPats = ["just b"] restType = "Case m Bool (Maybe A -&gt; Bool)" @
problemFromPats :: [NamedArg Pattern] -> Type -> TCM Problem

-- | Try to move patterns from the problem rest into the problem. Possible
--   if type of problem rest has been updated to a function type.
updateProblemRest_ :: Problem -> TCM (Nat, Problem)
updateProblemRest :: LHSState -> TCM LHSState

module Agda.TypeChecking.Rules.LHS

-- | Compute the set of flexible patterns in a list of patterns. The result
--   is the deBruijn indices of the flexible patterns. A pattern is
--   flexible if it is dotted or implicit.
flexiblePatterns :: [NamedArg Pattern] -> TCM FlexibleVars

-- | Compute the dot pattern instantiations.
dotPatternInsts :: [NamedArg Pattern] -> Substitution -> [Dom Type] -> TCM [DotPatternInst]

-- | In an internal pattern, replace some pattern variables by dot
--   patterns, according to the given substitution.
instantiatePattern :: Substitution -> Permutation -> [NamedArg Pattern] -> [NamedArg Pattern]

-- | In an internal pattern, replace some pattern variables by dot
--   patterns, according to the given substitution.
instantiatePattern' :: Substitution -> Permutation -> [NamedArg Pattern] -> [NamedArg Pattern]

-- | Check if a problem is solved. That is, if the patterns are all
--   variables.
isSolvedProblem :: Problem -> Bool

-- | For each user-defined pattern variable in the <a>Problem</a>, check
--   that the corresponding data type (if any) does not contain a
--   constructor of the same name (which is not in scope); this "shadowing"
--   could indicate an error, and is not allowed.
--   
--   Precondition: The problem has to be solved.
noShadowingOfConstructors :: (Maybe r -> Call) -> Problem -> TCM ()

-- | Check that a dot pattern matches it's instantiation.
checkDotPattern :: DotPatternInst -> TCM ()

-- | Bind the variables in a left hand side. Precondition: the patterns
--   should all be <a>VarP</a>, <a>WildP</a>, <a>AbsurdP</a>, or
--   <a>ImplicitP</a> and the telescope should have the same size as the
--   pattern list. There could also be <a>ConP</a>s resulting from eta
--   expanded implicit record patterns.
bindLHSVars :: [NamedArg Pattern] -> Telescope -> TCM a -> TCM a

-- | Bind as patterns
bindAsPatterns :: [AsBinding] -> TCM a -> TCM a
data LHSResult
LHSResult :: Maybe Telescope -> Telescope -> Substitution -> [String] -> [NamedArg Pattern] -> Arg Type -> Permutation -> LHSResult

-- | Γ: The types of the patterns. <a>Nothing</a> if more patterns than
--   domain types in <tt>a</tt>. Used only to construct a <tt>with</tt>
--   function; see <tt>stripwithClausePatterns</tt>.
lhsPatternTele :: LHSResult -> Maybe Telescope

-- | Δ : The types of the pattern variables.
lhsVarTele :: LHSResult -> Telescope

-- | σ : The patterns in form of a substitution Δ ⊢ σ : Γ
lhsSubstitution :: LHSResult -> Substitution

-- | Names for the variables in Δ, for binding the body.
lhsVarNames :: LHSResult -> [String]

-- | The patterns in internal syntax.
lhsPatterns :: LHSResult -> [NamedArg Pattern]

-- | The type of the body. Is <tt>bσ</tt> if <tt>Γ</tt> is defined.
--   <a>Irrelevant</a> to indicate the rhs must be checked in irrelevant
--   mode.
lhsBodyType :: LHSResult -> Arg Type

-- | The permutation from pattern vars to <tt>Δ</tt>.
lhsPermutation :: LHSResult -> Permutation

-- | Check a LHS. Main function.
--   
--   <tt>checkLeftHandSide a ps a ret</tt> checks that user patterns
--   <tt>ps</tt> eliminate the type <tt>a</tt> of the defined function, and
--   calls continuation <tt>ret</tt> if successful.
checkLeftHandSide :: (Maybe r -> Call) -> Maybe QName -> [NamedArg Pattern] -> Type -> (LHSResult -> TCM a) -> TCM a

-- | The loop (tail-recursive): split at a variable in the problem until
--   problem is solved
checkLHS :: Maybe QName -> LHSState -> TCM LHSState

-- | Ensures that we are not performing pattern matching on codata.
noPatternMatchingOnCodata :: [NamedArg Pattern] -> TCM ()
instance InstantiateFull LHSResult


-- | Coverage checking, case splitting, and splitting for refine tactics.
module Agda.TypeChecking.Coverage
data SplitClause
SClause :: Telescope -> Permutation -> [NamedArg Pattern] -> Substitution -> Maybe (Arg Type) -> SplitClause

-- | Type of variables in <tt>scPats</tt>.
scTel :: SplitClause -> Telescope

-- | How to get from the variables in the patterns to the telescope.
scPerm :: SplitClause -> Permutation

-- | The patterns leading to the currently considered branch of the split
--   tree.
scPats :: SplitClause -> [NamedArg Pattern]

-- | Substitution from <a>scTel</a> to old context. Only needed directly
--   after split on variable: * To update <a>scTarget</a> * To rename other
--   split variables when splitting on multiple variables. <tt>scSubst</tt>
--   is not ``transitive'', i.e., does not record the substitution from the
--   original context to <a>scTel</a> over a series of splits. It is
--   freshly computed after each split by <tt>computeNeighborhood</tt>;
--   also <a>splitResult</a>, which does not split on a variable, should
--   reset it to the identity <a>idS</a>, lest it be applied to
--   <a>scTarget</a> again, leading to Issue 1294.
scSubst :: SplitClause -> Substitution

-- | The type of the rhs, living in context <a>scTel</a>. This invariant is
--   broken before calls to <a>fixTarget</a>; there, <a>scTarget</a> lives
--   in the old context. <a>fixTarget</a> moves <a>scTarget</a> to the new
--   context by applying substitution <a>scSubst</a>.
scTarget :: SplitClause -> Maybe (Arg Type)

-- | Create a split clause from a clause in internal syntax.
clauseToSplitClause :: Clause -> SplitClause

-- | Update the target type, add more patterns to split clause if target
--   becomes a function type. Returns <tt>True</tt> if new patterns were
--   added.
fixTarget :: SplitClause -> TCM (Bool, SplitClause)

-- | A <tt>Covering</tt> is the result of splitting a <a>SplitClause</a>.
data Covering
Covering :: Nat -> [(QName, SplitClause)] -> Covering

-- | De Bruijn level of argument we split on.
covSplitArg :: Covering -> Nat

-- | Covering clauses, indexed by constructor these clauses share.
covSplitClauses :: Covering -> [(QName, SplitClause)]

-- | Project the split clauses out of a covering.
splitClauses :: Covering -> [SplitClause]

-- | Top-level function for checking pattern coverage.
coverageCheck :: QName -> Type -> [Clause] -> TCM SplitTree

-- | Entry point from <tt>Interaction.MakeCase</tt>.
splitClauseWithAbsurd :: Clause -> Nat -> TCM (Either SplitError (Either SplitClause Covering))

-- | Entry point from <tt>TypeChecking.Empty</tt> and
--   <tt>Interaction.BasicOps</tt>. <tt>splitLast CoInductive</tt> is used
--   in the <tt>refine</tt> tactics.
splitLast :: Induction -> Telescope -> [NamedArg Pattern] -> TCM (Either SplitError Covering)

-- | <pre>
--   splitResult f sc = return res
--   </pre>
--   
--   If the target type of <tt>sc</tt> is a record type, a covering set of
--   split clauses is returned (<tt>sc</tt> extended by all valid
--   projection patterns), otherwise <tt>res == Nothing</tt>. Note that the
--   empty set of split clauses is returned if the record has no fields.
splitResult :: QName -> SplitClause -> TCM (Maybe Covering)
instance PrettyTCM SplitClause

module Agda.TypeChecking.CompiledClause.Compile

-- | Process function clauses into case tree. This involves: 1. Coverage
--   checking, generating a split tree. 2. Translation of lhs record
--   patterns into rhs uses of projection. Update the split tree. 3.
--   Generating a case tree from the split tree. Phases 1. and 2. are
--   skipped if <tt>Nothing</tt>.
compileClauses :: Maybe (QName, Type) -> [Clause] -> TCM CompiledClauses
type Cl = ([Arg Pattern], ClauseBody)
type Cls = [Cl]
compileWithSplitTree :: SplitTree -> Cls -> CompiledClauses
compile :: Cls -> CompiledClauses

-- | Get the index of the next argument we need to split on. This the
--   number of the first pattern that does a match in the first clause.
nextSplit :: Cls -> Maybe Int

-- | Is this a variable pattern?
isVar :: Pattern -> Bool

-- | <tt>splitOn single n cs</tt> will force expansion of catch-alls if
--   <tt>single</tt>.
splitOn :: Bool -> Int -> Cls -> Case Cls
splitC :: Int -> Cl -> Case Cl

-- | Expand catch-alls that appear before actual matches.
--   
--   Example:
--   
--   <pre>
--   true  y
--   x     false
--   false y
--   </pre>
--   
--   will expand the catch-all <tt>x</tt> to <tt>false</tt>.
--   
--   Catch-alls need also to be expanded if they come before/after a record
--   pattern, otherwise we get into trouble when we want to eliminate
--   splits on records later.
expandCatchAlls :: Bool -> Int -> Cls -> Cls
substBody :: Int -> Int -> Term -> ClauseBody -> ClauseBody

module Agda.TypeChecking.Empty

-- | Check whether a type is empty. Maybe postponed as emptyness
--   constraint.
isEmptyType :: Range -> Type -> TCM ()

module Agda.TypeChecking.Rules.Term

-- | Check that an expression is a type.
isType :: Expr -> Sort -> TCM Type

-- | Check that an expression is a type without knowing the sort.
isType_ :: Expr -> TCM Type

-- | Check that an expression is a type which is equal to a given type.
isTypeEqualTo :: Expr -> Type -> TCM Type
leqType_ :: Type -> Type -> TCM ()

-- | Type check a telescope. Binds the variables defined by the telescope.
checkTelescope_ :: Telescope -> (Telescope -> TCM a) -> TCM a

-- | Check a typed binding and extends the context with the bound
--   variables. The telescope passed to the continuation is valid in the
--   original context.
checkTypedBindings_ :: TypedBindings -> (Telescope -> TCM a) -> TCM a
data LamOrPi
LamNotPi :: LamOrPi
PiNotLam :: LamOrPi

-- | Check a typed binding and extends the context with the bound
--   variables. The telescope passed to the continuation is valid in the
--   original context.
--   
--   Parametrized by a flag wether we check a typed lambda or a Pi. This
--   flag is needed for irrelevance.
checkTypedBindings :: LamOrPi -> TypedBindings -> (Telescope -> TCM a) -> TCM a
checkTypedBinding :: LamOrPi -> ArgInfo -> TypedBinding -> (ListTel -> TCM a) -> TCM a

-- | Type check a lambda expression.
checkLambda :: Arg TypedBinding -> Expr -> Type -> TCM Term

-- | <tt>checkAbsurdLambda i h e t</tt> checks absurd lambda against type
--   <tt>t</tt>. Precondition: <tt>e = AbsurdLam i h</tt>
checkAbsurdLambda :: ExprInfo -> Hiding -> Expr -> Type -> TCM Term

-- | <tt>checkExtendedLambda i di qname cs e t</tt> check pattern matching
--   lambda. Precondition: <tt>e = ExtendedLam i di qname cs</tt>
checkExtendedLambda :: ExprInfo -> DefInfo -> QName -> [Clause] -> Expr -> Type -> TCM Term

-- | <tt>checkRecordExpression fs e t</tt> checks record construction
--   against type <tt>t</tt>. Precondition <tt>e = Rec _ fs</tt>.
checkRecordExpression :: Assigns -> Expr -> Type -> TCM Term

-- | <tt>checkRecordUpdate ei recexpr fs e t</tt> Precondition <tt>e =
--   RecUpdate ei recexpr fs</tt>.
checkRecordUpdate :: ExprInfo -> Expr -> Assigns -> Expr -> Type -> TCM Term
checkLiteral :: Literal -> Type -> TCM Term

-- | <tt>checkArguments' exph r args t0 t k</tt> tries <tt>checkArguments
--   exph args t0 t</tt>. If it succeeds, it continues <tt>k</tt> with the
--   returned results. If it fails, it registers a postponed typechecking
--   problem and returns the resulting new meta variable.
--   
--   Checks <tt>e := ((_ : t0) args) : t</tt>.
checkArguments' :: ExpandHidden -> ExpandInstances -> Range -> [NamedArg Expr] -> Type -> Type -> (Args -> Type -> TCM Term) -> TCM Term

-- | Type check an expression.
checkExpr :: Expr -> Type -> TCM Term

-- | <tt>checkApplication hd args e t</tt> checks an application.
--   Precondition: <tt>Application hs args = appView e</tt>
--   
--   <tt>checkApplication</tt> disambiguates constructors (and continues to
--   <a>checkConstructorApplication</a>) and resolves pattern synonyms.
checkApplication :: Expr -> Args -> Expr -> Type -> TCM Term

-- | Turn a domain-free binding (e.g. lambda) into a domain-full one, by
--   inserting an underscore for the missing type.
domainFree :: ArgInfo -> Name -> LamBinding
checkMeta :: (Type -> TCM Term) -> Type -> MetaInfo -> TCM Term
inferMeta :: (Type -> TCM Term) -> MetaInfo -> TCM (Args -> Term, Type)

-- | Type check a meta variable. If its type is not given, we return its
--   type, or a fresh one, if it is a new meta. If its type is given, we
--   check that the meta has this type, and we return the same type.
checkOrInferMeta :: (Type -> TCM Term) -> Maybe Type -> MetaInfo -> TCM (Term, Type)
inferHeadDef :: QName -> TCM (Args -> Term, Type)

-- | Infer the type of a head thing (variable, function symbol, or
--   constructor). We return a function that applies the head to arguments.
--   This is because in case of a constructor we want to drop the
--   parameters.
inferHead :: Expr -> TCM (Args -> Term, Type)
inferDef :: (QName -> Args -> TCM Term) -> QName -> TCM (Term, Type)

-- | Check the type of a constructor application. This is easier than a
--   general application since the implicit arguments can be inserted
--   without looking at the arguments to the constructor.
checkConstructorApplication :: Expr -> Type -> ConHead -> [NamedArg Expr] -> TCM Term

-- | <tt>checkHeadApplication e t hd args</tt> checks that <tt>e</tt> has
--   type <tt>t</tt>, assuming that <tt>e</tt> has the form <tt>hd
--   args</tt>. The corresponding type-checked term is returned.
--   
--   If the head term <tt>hd</tt> is a coinductive constructor, then a
--   top-level definition <tt>fresh tel = hd args</tt> (where the clause is
--   delayed) is added, where <tt>tel</tt> corresponds to the current
--   telescope. The returned term is <tt>fresh tel</tt>.
--   
--   Precondition: The head <tt>hd</tt> has to be unambiguous, and there
--   should not be any need to insert hidden lambdas.
checkHeadApplication :: Expr -> Type -> Expr -> [NamedArg Expr] -> TCM Term
traceCallE :: Error e => (Maybe r -> Call) -> ExceptT e TCM r -> ExceptT e TCM r

-- | Check a list of arguments: <tt>checkArgs args t0 t1</tt> checks that
--   <tt>t0 = Delta -&gt; t0'</tt> and <tt>args : Delta</tt>. Inserts
--   hidden arguments to make this happen. Returns the evaluated arguments
--   <tt>vs</tt>, the remaining type <tt>t0'</tt> (which should be a
--   subtype of <tt>t1</tt>) and any constraints <tt>cs</tt> that have to
--   be solved for everything to be well-formed.
checkArguments :: ExpandHidden -> ExpandInstances -> Range -> [NamedArg Expr] -> Type -> Type -> ExceptT (Args, [NamedArg Expr], Type) TCM (Args, Type)

-- | Check that a list of arguments fits a telescope.
checkArguments_ :: ExpandHidden -> Range -> [NamedArg Expr] -> Telescope -> TCM Args

-- | Infer the type of an expression. Implemented by checking against a
--   meta variable. Except for neutrals, for them a polymorphic type is
--   inferred.
inferExpr :: Expr -> TCM (Term, Type)
defOrVar :: Expr -> Bool

-- | Used to check aliases <tt>f = e</tt>. Switches off <a>ExpandLast</a>
--   for the checking of top-level application.
checkDontExpandLast :: Expr -> Type -> TCM Term

-- | Check whether a de Bruijn index is bound by a module telescope.
isModuleFreeVar :: Int -> TCM Bool

-- | Infer the type of an expression, and if it is of the form <tt>{tel}
--   -&gt; D vs</tt> for some datatype <tt>D</tt> then insert the hidden
--   arguments. Otherwise, leave the type polymorphic.
inferExprForWith :: Expr -> TCM (Term, Type)
checkLetBindings :: [LetBinding] -> TCM a -> TCM a
checkLetBinding :: LetBinding -> TCM a -> TCM a
class ConvColor a i
convColor :: ConvColor a i => a -> i
instance Eq LamOrPi
instance Show LamOrPi
instance ConvColor a i => ConvColor [a] [i]
instance ConvColor (Dom e) (Dom e)
instance ConvColor (Arg e) (Arg e)
instance ConvColor ArgInfo ArgInfo
instance Error (a, b, c)

module Agda.TypeChecking.Rules.Record

-- | <pre>
--   checkRecDef i name con ps contel fields
--   </pre>
--   
--   <ul>
--   <li><i><tt>name</tt></i> Record type
--   identifier.<ul><li><i><tt>con</tt></i> Maybe constructor name and
--   info.</li><li><i><tt>ps</tt></i> Record
--   parameters.</li><li><i><tt>contel</tt></i> Approximate type of
--   constructor (<tt>fields</tt> -&gt; Set). Does not include record
--   parameters.</li><li><i><tt>fields</tt></i> List of field
--   signatures.</li></ul></li>
--   </ul>
checkRecDef :: DefInfo -> QName -> Maybe (Ranged Induction) -> Maybe QName -> [LamBinding] -> Expr -> [Field] -> TCM ()

-- | <tt>checkRecordProjections m r q tel ftel fs</tt>.
--   
--   <ul>
--   <li><i><tt>m</tt> </i> name of the generated
--   module<ul><li><i><tt>r</tt> </i> name of the record
--   type</li><li><i><tt>con</tt> </i> name of the record
--   constructor</li><li><i><tt>tel</tt> </i> parameters and record
--   variable r ("self")</li><li><i><tt>ftel</tt> </i> telescope of
--   fields</li><li><i><tt>fs</tt> </i> the fields to be
--   checked</li></ul></li>
--   </ul>
checkRecordProjections :: ModuleName -> QName -> ConHead -> Telescope -> Telescope -> [Declaration] -> TCM ()

module Agda.TypeChecking.Rules.Def
checkFunDef :: Delayed -> DefInfo -> QName -> [Clause] -> TCM ()

-- | A single clause without arguments and without type signature is an
--   alias.
isAlias :: [Clause] -> Type -> Maybe (Expr, MetaId)

-- | Check a trivial definition of the form <tt>f = e</tt>
checkAlias :: Type -> ArgInfo -> Delayed -> DefInfo -> QName -> Expr -> TCM ()

-- | Type check a definition by pattern matching.
checkFunDef' :: Type -> ArgInfo -> Delayed -> Maybe (Int, Int) -> Maybe QName -> DefInfo -> QName -> [Clause] -> TCM ()

-- | Set <a>funTerminates</a> according to termination info in
--   <a>TCEnv</a>, which comes from a possible termination pragma.
useTerPragma :: Definition -> TCM Definition

-- | Insert some patterns in the in with-clauses LHS of the given RHS
insertPatterns :: [Pattern] -> RHS -> RHS

-- | Parameters for creating a <tt>with</tt>-function.
data WithFunctionProblem
NoWithFunction :: WithFunctionProblem
WithFunction :: QName -> QName -> Telescope -> Telescope -> Telescope -> [Term] -> [Type] -> Type -> [NamedArg Pattern] -> Permutation -> Permutation -> Permutation -> [Clause] -> WithFunctionProblem

-- | parent function name
wfParentName :: WithFunctionProblem -> QName

-- | with function name
wfName :: WithFunctionProblem -> QName

-- | arguments to parent function
wfParentTel :: WithFunctionProblem -> Telescope

-- | arguments to the with function before the with expressions
wfBeforeTel :: WithFunctionProblem -> Telescope

-- | arguments to the with function after the with expressions
wfAfterTel :: WithFunctionProblem -> Telescope

-- | with expressions
wfExprs :: WithFunctionProblem -> [Term]

-- | types of the with expressions
wfExprTypes :: WithFunctionProblem -> [Type]

-- | type of the right hand side
wfRHSType :: WithFunctionProblem -> Type

-- | parent patterns
wfParentPats :: WithFunctionProblem -> [NamedArg Pattern]

-- | permutation resulting from splitting the telescope into needed and
--   unneeded vars
wfPermSplit :: WithFunctionProblem -> Permutation

-- | permutation reordering the variables in the parent pattern
wfPermParent :: WithFunctionProblem -> Permutation

-- | final permutation (including permutation for the parent clause)
wfPermFinal :: WithFunctionProblem -> Permutation

-- | the given clauses for the with function
wfClauses :: WithFunctionProblem -> [Clause]

-- | Type check a function clause.
checkClause :: Type -> SpineClause -> TCM Clause
checkWithFunction :: WithFunctionProblem -> TCM ()

-- | Type check a where clause. The first argument is the number of
--   variables bound in the left hand side.
checkWhere :: Nat -> [Declaration] -> TCM a -> TCM a

-- | Check if a pattern contains an absurd pattern. For instance, <tt>suc
--   ()</tt>
containsAbsurdPattern :: Pattern -> Bool


-- | Rewriting with arbitrary rules.
--   
--   The user specifies a relation symbol by the pragma <tt> {--} </tt>
--   where <tt>rel</tt> should be of type <tt>Δ → (lhs rhs : A) → Set
--   i</tt>.
--   
--   Then the user can add rewrite rules by the pragma <tt> {--} </tt>
--   where <tt>q</tt> should be a closed term of type <tt>Γ → rel us lhs
--   rhs</tt>.
--   
--   We then intend to add a rewrite rule <tt> Γ ⊢ lhs ↦ rhs : B </tt> to
--   the signature where <tt>B = A[us/Δ]</tt>.
--   
--   To this end, we normalize <tt>lhs</tt>, which should be of the form
--   <tt> f ts </tt> for a <tt><a>Def</a></tt>-symbol f (postulate,
--   function, data, record, constructor). Further, <tt>FV(ts) =
--   dom(Γ)</tt>. The rule <tt>q :: Γ ⊢ f ts ↦ rhs : B</tt> is added to the
--   signature to the definition of <tt>f</tt>.
--   
--   When reducing a term <tt>Ψ ⊢ f vs</tt> is stuck, we try the rewrites
--   for <tt>f</tt>, by trying to unify <tt>vs</tt> with <tt>ts</tt>. This
--   is for now done by substituting fresh metas Xs for the bound variables
--   in <tt>ts</tt> and checking equality with <tt>vs</tt> <tt> Ψ ⊢ (f
--   ts)[Xs<i>Γ] = f vs : B[Xs</i>Γ] </tt> If successful (no open
--   metas/constraints), we replace <tt>f vs</tt> by <tt>rhs[Xs/Γ]</tt> and
--   continue reducing.
module Agda.TypeChecking.Rewriting

-- | Check that the name given to the BUILTIN REWRITE is actually a
--   relation symbol. I.e., its type should be of the form <tt>Δ → (lhs rhs
--   : A) → Set ℓ</tt>. Note: we do not care about hiding/non-hiding of lhs
--   and rhs.
verifyBuiltinRewrite :: Term -> Type -> TCM ()

-- | Deconstructing a type into <tt>Δ → t → t' → core</tt>.
data RelView
RelView :: Telescope -> ListTel -> Type -> Type -> Type -> RelView

-- | The whole telescope <tt>Δ, t, t'</tt>.
relViewTel :: RelView -> Telescope

-- | <tt>Δ</tt>.
relViewDelta :: RelView -> ListTel

-- | <tt>t</tt>.
relViewType :: RelView -> Type

-- | <tt>t'</tt>.
relViewType' :: RelView -> Type

-- | <tt>core</tt>.
relViewCore :: RelView -> Type

-- | Deconstructing a type into <tt>Δ → t → t' → core</tt>. Returns
--   <tt>Nothing</tt> if not enough argument types.
relView :: Type -> TCM (Maybe RelView)

-- | Add <tt>q : Γ → rel us lhs rhs</tt> as rewrite rule <tt> Γ ⊢ lhs ↦ rhs
--   : B </tt> to the signature where <tt>B = A[us/Δ]</tt>. Remember that
--   <tt>rel : Δ → A → A → Set i</tt>, so <tt>rel us : (lhs rhs : A[us/Δ])
--   → Set i</tt>.
addRewriteRule :: QName -> TCM ()

-- | Append rewrite rules to a definition.
addRewriteRules :: QName -> RewriteRules -> TCM ()

-- | Lens for <a>RewriteRules</a>.
updateRewriteRules :: (RewriteRules -> RewriteRules) -> Definition -> Definition

-- | <tt>rewriteWith t v rew</tt> tries to rewrite <tt>v : t</tt> with
--   <tt>rew</tt>, returning the reduct if successful.
rewriteWith :: Maybe Type -> Term -> RewriteRule -> TCM (Maybe Term)

-- | <tt>rewrite t</tt> tries to rewrite a reduced term.
rewrite :: Term -> TCM (Maybe Term)

module Agda.TypeChecking.Rules.Builtin

-- | Bind a builtin thing to an expression.
bindBuiltin :: String -> Expr -> TCM ()

-- | <tt>bindPostulatedName builtin e m</tt> checks that <tt>e</tt> is a
--   postulated name <tt>q</tt>, and binds the builtin <tt>builtin</tt> to
--   the term <tt>m q def</tt>, where <tt>def</tt> is the current
--   <a>Definition</a> of <tt>q</tt>.
bindPostulatedName :: String -> Expr -> (QName -> Definition -> TCM Term) -> TCM ()

module Agda.TypeChecking.Rules.Decl

-- | Type check a sequence of declarations.
checkDecls :: [Declaration] -> TCM ()

-- | Type check a single declaration.
checkDecl :: Declaration -> TCM ()
mutualChecks :: MutualInfo -> Declaration -> [Declaration] -> Set QName -> TCM ()
type FinalChecks = Maybe (TCM ())
checkUnquoteDecl :: MutualInfo -> DefInfo -> QName -> Expr -> TCM FinalChecks

-- | Instantiate all metas in <a>Definition</a> associated to <a>QName</a>.
--   -- Makes sense after freezing metas. Some checks, like free variable
--   analysis, are not in <a>TCM</a>, -- so they will be more precise (see
--   issue 1099) after meta instantiation. -- Precondition: name has been
--   added to signature already.
instantiateDefinitionType :: QName -> TCM ()

-- | Highlight a declaration.
highlight_ :: Declaration -> TCM ()

-- | Termination check a declaration.
checkTermination_ :: Declaration -> TCM ()

-- | Check a set of mutual names for positivity.
checkPositivity_ :: Set QName -> TCM ()

-- | Check that all coinductive records are actually recursive. (Otherwise,
--   one can implement invalid recursion schemes just like for the old
--   coinduction.)
checkCoinductiveRecords :: [Declaration] -> TCM ()

-- | Check a set of mutual names for constructor-headedness.
checkInjectivity_ :: Set QName -> TCM ()

-- | Check a set of mutual names for projection likeness.
checkProjectionLikeness_ :: Set QName -> TCM ()

-- | Type check an axiom.
checkAxiom :: Axiom -> DefInfo -> ArgInfo -> QName -> Expr -> TCM ()

-- | Type check a primitive function declaration.
checkPrimitive :: DefInfo -> QName -> Expr -> TCM ()

-- | Check a pragma.
checkPragma :: Range -> Pragma -> TCM ()

-- | Type check a bunch of mutual inductive recursive definitions.
--   
--   All definitions which have so far been assigned to the given mutual
--   block are returned.
checkMutual :: MutualInfo -> [Declaration] -> TCM (Set QName)

-- | Type check the type signature of an inductive or recursive definition.
checkTypeSignature :: TypeSignature -> TCM ()

-- | Type check a module.
checkSection :: ModuleInfo -> ModuleName -> Telescope -> [Declaration] -> TCM ()

-- | Helper for <a>checkSectionApplication</a>.
--   
--   Matches the arguments of the module application with the module
--   parameters.
--   
--   Returns the remaining module parameters as an open telescope. Warning:
--   the returned telescope is <i>not</i> the final result, an actual
--   instantiation of the parameters does not occur.
checkModuleArity :: ModuleName -> Telescope -> [NamedArg Expr] -> TCM Telescope

-- | Check an application of a section (top-level function, includes
--   <tt><a>traceCall</a></tt>).
checkSectionApplication :: ModuleInfo -> ModuleName -> ModuleApplication -> Ren QName -> Ren ModuleName -> TCM ()

-- | Check an application of a section.
checkSectionApplication' :: ModuleInfo -> ModuleName -> ModuleApplication -> Ren QName -> Ren ModuleName -> TCM ()

-- | Type check an import declaration. Actually doesn't do anything, since
--   all the work is done when scope checking.
checkImport :: ModuleInfo -> ModuleName -> TCM ()

module Agda.TheTypeChecker

-- | Type check a sequence of declarations.
checkDecls :: [Declaration] -> TCM ()

-- | Type check a single declaration.
checkDecl :: Declaration -> TCM ()

-- | Infer the type of an expression. Implemented by checking against a
--   meta variable. Except for neutrals, for them a polymorphic type is
--   inferred.
inferExpr :: Expr -> TCM (Term, Type)

-- | Type check an expression.
checkExpr :: Expr -> Type -> TCM Term


-- | This module deals with finding imported modules and loading their
--   interface files.
module Agda.Interaction.Imports

-- | Are we loading the interface for the user-loaded file or for an
--   import?
data MainInterface

-- | Interface for main file.
MainInterface :: MainInterface

-- | Interface for imported file.
NotMainInterface :: MainInterface

-- | Merge an interface into the current proof state.
mergeInterface :: Interface -> TCM ()
addImportedThings :: Signature -> BuiltinThings PrimFun -> Set String -> PatternSynDefns -> TCM ()

-- | Scope checks the given module. A proper version of the module name
--   (with correct definition sites) is returned.
scopeCheckImport :: ModuleName -> TCM (ModuleName, Map ModuleName Scope)
data MaybeWarnings
NoWarnings :: MaybeWarnings
SomeWarnings :: Warnings -> MaybeWarnings
hasWarnings :: MaybeWarnings -> Bool

-- | If the module has already been visited (without warnings), then its
--   interface is returned directly. Otherwise the computation is used to
--   find the interface and the computed interface is stored for potential
--   later use.
alreadyVisited :: TopLevelModuleName -> TCM (Interface, MaybeWarnings) -> TCM (Interface, MaybeWarnings)

-- | Type checks the main file of the interaction. This could be the file
--   loaded in the interacting editor (emacs), or the file passed on the
--   command line.
--   
--   First, the primitive modules are imported. Then,
--   <tt>getInterface'</tt> is called to do the main work.
typeCheckMain :: AbsolutePath -> TCM (Interface, MaybeWarnings)

-- | Tries to return the interface associated to the given (imported)
--   module. The time stamp of the relevant interface file is also
--   returned. Calls itself recursively for the imports of the given
--   module. May type check the module. An error is raised if a warning is
--   encountered.
--   
--   Do not use this for the main file, use <a>typeCheckMain</a> instead.
getInterface :: ModuleName -> TCM Interface

-- | See <a>getInterface</a>.
getInterface_ :: TopLevelModuleName -> TCM Interface

-- | A more precise variant of <a>getInterface</a>. If warnings are
--   encountered then they are returned instead of being turned into
--   errors.
getInterface' :: TopLevelModuleName -> MainInterface -> TCM (Interface, MaybeWarnings)

-- | Print the highlighting information contained in the given interface.
highlightFromInterface :: Interface -> AbsolutePath -> TCM ()
readInterface :: FilePath -> TCM (Maybe Interface)

-- | Writes the given interface to the given file. Returns the file's new
--   modification time stamp, or <a>Nothing</a> if the write failed.
writeInterface :: FilePath -> Interface -> TCM ()

-- | Tries to type check a module and write out its interface. The function
--   only writes out an interface file if it does not encounter any
--   warnings.
--   
--   If appropriate this function writes out syntax highlighting
--   information.
createInterface :: AbsolutePath -> TopLevelModuleName -> TCM (Interface, MaybeWarnings)

-- | Builds an interface for the current module, which should already have
--   been successfully type checked.
buildInterface :: AbsolutePath -> TopLevelInfo -> HighlightingInfo -> Set String -> [OptionsPragma] -> TCM Interface

-- | Returns (iSourceHash, iFullHash)
getInterfaceFileHashes :: FilePath -> TCM (Maybe (Hash, Hash))
safeReadInterface :: FilePath -> TCM (Maybe Interface)
moduleHash :: ModuleName -> TCM Hash

-- | True if the first file is newer than the second file. If a file
--   doesn't exist it is considered to be infinitely old.
isNewerThan :: FilePath -> FilePath -> IO Bool
instance Eq MainInterface
instance Show MainInterface

module Agda.Compiler.MAlonzo.Compiler
compilerMain :: Bool -> Interface -> TCM ()
compile :: Interface -> TCM ()
imports :: TCM [ImportDecl]
definitions :: Definitions -> TCM [Decl]

-- | Note that the INFINITY, SHARP and FLAT builtins are translated as
--   follows (if a <a>CoinductionKit</a> is given):
--   
--   <pre>
--   type Infinity a b = b
--   
--   sharp :: a -&gt; a
--   sharp x = x
--   
--   flat :: a -&gt; a
--   flat x = x
--   </pre>
definition :: Maybe CoinductionKit -> Definition -> TCM [Decl]
checkConstructorType :: QName -> TCM [Decl]
checkCover :: QName -> HaskellType -> Nat -> [QName] -> TCM [Decl]

-- | Move somewhere else!
conArityAndPars :: QName -> TCM (Nat, Nat)
clause :: QName -> Maybe String -> (Nat, Bool, Clause) -> TCM Decl
argpatts :: [NamedArg Pattern] -> [Pat] -> TCM [Pat]
clausebody :: ClauseBody -> TCM Exp

-- | Extract Agda term to Haskell expression. Irrelevant arguments are
--   extracted as <tt>()</tt>. Types are extracted as <tt>()</tt>.
--   <tt>DontCare</tt> outside of irrelevant arguments is extracted as
--   <tt>error</tt>.
term :: Term -> ReaderT Nat TCM Exp

-- | Irrelevant arguments are replaced by Haskells' ().
term' :: Arg Term -> ReaderT Nat TCM Exp
literal :: Literal -> TCM Exp
hslit :: Literal -> Literal
litqname :: QName -> TCM Exp
condecl :: QName -> TCM (Nat, ConDecl)
cdecl :: QName -> Nat -> ConDecl
tvaldecl :: QName -> Induction -> Nat -> Nat -> [ConDecl] -> Maybe Clause -> [Decl]
infodecl :: QName -> Decl
hsCast :: Exp -> Exp
hsCast' :: Exp -> Exp
hsCoerce :: Exp -> Exp
writeModule :: Module -> TCM ()
rteModule :: Module
explicitForAll :: Extension
compileDir :: TCM FilePath
outFile' :: (Pretty a, TransformBi ModuleName (Wrap a)) => a -> TCM (FilePath, FilePath)
outFile :: ModuleName -> TCM FilePath
outFile_ :: TCM FilePath
callGHC :: Bool -> Interface -> TCM ()


-- | Epic compiler backend.
module Agda.Compiler.Epic.Compiler

-- | Compile an interface into an executable using Epic
compilerMain :: Interface -> TCM ()

module Agda.Compiler.JS.Compiler
compilerMain :: Interface -> TCM ()
compile :: Interface -> TCM ()
prefix :: [Char]
jsMod :: ModuleName -> GlobalId
jsFileName :: GlobalId -> String
jsMember :: Name -> MemberId
global' :: QName -> TCM (Exp, [MemberId])
global :: QName -> TCM (Exp, [MemberId])
reorder :: [Export] -> [Export]
reorder' :: Set [MemberId] -> [Export] -> [Export]
isTopLevelValue :: Export -> Bool
isEmptyObject :: Export -> Bool
insertAfter :: Set [MemberId] -> Export -> [Export] -> [Export]
curModule :: TCM Module
definition :: (QName, Definition) -> TCM Export
defn :: QName -> [MemberId] -> Type -> Maybe JSCode -> Defn -> TCM Exp
numPars :: [Clause] -> Nat
clause :: Clause -> TCM Case
mapping :: [Pattern] -> (Nat, Nat, [Exp])
mapping' :: Pattern -> (Nat, Nat, [Exp]) -> (Nat, Nat, [Exp])
pattern :: Pattern -> TCM Patt
tag :: QName -> TCM Tag
visitorName :: QName -> TCM MemberId
body :: ClauseBody -> TCM Exp
term :: Term -> TCM Exp
isSingleton :: Type -> TCM (Maybe Exp)
args :: Int -> Args -> TCM [Exp]
qname :: QName -> TCM Exp
literal :: Literal -> Exp
dummyLambda :: Int -> Exp -> Exp
writeModule :: Module -> TCM ()
compileDir :: TCM FilePath
outFile :: GlobalId -> TCM FilePath
outFile_ :: TCM FilePath

module Agda.Interaction.BasicOps

-- | Parses an expression.
parseExpr :: Range -> String -> TCM Expr
parseExprIn :: InteractionId -> Range -> String -> TCM Expr
giveExpr :: MetaId -> Expr -> TCM Expr

-- | Try to fill hole by expression.
--   
--   Returns the given expression unchanged (for convenient generalization
--   to <tt><a>refine</a></tt>).
give :: InteractionId -> Maybe Range -> Expr -> TCM Expr

-- | Try to refine hole by expression <tt>e</tt>.
--   
--   This amounts to successively try to give <tt>e</tt>, <tt>e ?</tt>,
--   <tt>e ? ?</tt>, ... Returns the successfully given expression.
refine :: InteractionId -> Maybe Range -> Expr -> TCM Expr

-- | Evaluate the given expression in the current environment
evalInCurrent :: Expr -> TCM Expr
evalInMeta :: InteractionId -> Expr -> TCM Expr
data Rewrite
AsIs :: Rewrite
Instantiated :: Rewrite
HeadNormal :: Rewrite
Simplified :: Rewrite
Normalised :: Rewrite
normalForm :: Rewrite -> Type -> TCM Type
data OutputForm a b
OutputForm :: Range -> ProblemId -> (OutputConstraint a b) -> OutputForm a b
data OutputConstraint a b
OfType :: b -> a -> OutputConstraint a b
CmpInType :: Comparison -> a -> b -> b -> OutputConstraint a b
CmpElim :: [Polarity] -> a -> [b] -> [b] -> OutputConstraint a b
JustType :: b -> OutputConstraint a b
CmpTypes :: Comparison -> b -> b -> OutputConstraint a b
CmpLevels :: Comparison -> b -> b -> OutputConstraint a b
CmpTeles :: Comparison -> b -> b -> OutputConstraint a b
JustSort :: b -> OutputConstraint a b
CmpSorts :: Comparison -> b -> b -> OutputConstraint a b
Guard :: (OutputConstraint a b) -> ProblemId -> OutputConstraint a b
Assign :: b -> a -> OutputConstraint a b
TypedAssign :: b -> a -> a -> OutputConstraint a b
PostponedCheckArgs :: b -> [a] -> a -> a -> OutputConstraint a b
IsEmptyType :: a -> OutputConstraint a b
FindInScopeOF :: b -> a -> [(a, a)] -> OutputConstraint a b

-- | A subset of <a>OutputConstraint</a>.
data OutputConstraint' a b
OfType' :: b -> a -> OutputConstraint' a b
ofName :: OutputConstraint' a b -> b
ofExpr :: OutputConstraint' a b -> a
outputFormId :: OutputForm a b -> b
showComparison :: Comparison -> String
judgToOutputForm :: Judgement a c -> OutputConstraint a c
getConstraints :: TCM [OutputForm Expr Expr]

-- | <tt>getSolvedInteractionPoints True</tt> returns all solutions, even
--   if just solved by another, non-interaction meta.
--   
--   <tt>getSolvedInteractionPoints False</tt> only returns metas that are
--   solved by a non-meta.
getSolvedInteractionPoints :: Bool -> TCM [(InteractionId, MetaId, Expr)]
typeOfMetaMI :: Rewrite -> MetaId -> TCM (OutputConstraint Expr NamedMeta)
typeOfMeta :: Rewrite -> InteractionId -> TCM (OutputConstraint Expr InteractionId)
typeOfMeta' :: Rewrite -> (InteractionId, MetaId) -> TCM (OutputConstraint Expr InteractionId)
typesOfVisibleMetas :: Rewrite -> TCM [OutputConstraint Expr InteractionId]
typesOfHiddenMetas :: Rewrite -> TCM [OutputConstraint Expr NamedMeta]
metaHelperType :: Rewrite -> InteractionId -> Range -> String -> TCM (OutputConstraint' Expr Expr)
contextOfMeta :: InteractionId -> Rewrite -> TCM [OutputConstraint' Expr Name]

-- | Returns the type of the expression in the current environment We wake
--   up irrelevant variables just in case the user want to invoke that
--   command in an irrelevant context.
typeInCurrent :: Rewrite -> Expr -> TCM Expr
typeInMeta :: InteractionId -> Rewrite -> Expr -> TCM Expr
withInteractionId :: InteractionId -> TCM a -> TCM a
withMetaId :: MetaId -> TCM a -> TCM a
introTactic :: Bool -> InteractionId -> TCM [String]

-- | Runs the given computation as if in an anonymous goal at the end of
--   the top-level module.
--   
--   Sets up current module, scope, and context.
atTopLevel :: TCM a -> TCM a

-- | Parse a name.
parseName :: Range -> String -> TCM QName

-- | Returns the contents of the given module.
moduleContents :: Rewrite -> Range -> String -> TCM ([Name], [(Name, Type)])
whyInScope :: String -> TCM (Maybe LocalVar, [AbstractName], [AbstractModule])
instance Read Rewrite
instance Functor (OutputConstraint a)
instance Functor (OutputForm a)
instance ToConcrete NamedMeta Expr
instance ToConcrete InteractionId Expr
instance (ToConcrete a c, ToConcrete b d) => ToConcrete (OutputConstraint' a b) (OutputConstraint' c d)
instance (Pretty a, Pretty b) => Pretty (OutputConstraint' a b)
instance (ToConcrete a c, ToConcrete b d) => ToConcrete (OutputConstraint a b) (OutputConstraint c d)
instance (ToConcrete a c, ToConcrete b d) => ToConcrete (OutputForm a b) (OutputForm c d)
instance (Show a, Show b) => Show (OutputConstraint a b)
instance (Show a, Show b) => Show (OutputForm a b)
instance Reify Constraint (OutputConstraint Expr Expr)
instance Reify ProblemConstraint (Closure (OutputForm Expr Expr))

module Agda.Interaction.CommandLine.CommandLine
data ExitCode a
Continue :: ExitCode a
ContinueIn :: TCEnv -> ExitCode a
Return :: a -> ExitCode a
type Command a = (String, [String] -> TCM (ExitCode a))
matchCommand :: String -> [Command a] -> Either [String] ([String] -> TCM (ExitCode a))
interaction :: String -> [Command a] -> (String -> TCM (ExitCode a)) -> IM a

-- | The interaction loop.
interactionLoop :: TCM (Maybe Interface) -> IM ()
continueAfter :: TCM a -> TCM (ExitCode b)
loadFile :: TCM () -> [String] -> TCM ()
showConstraints :: [String] -> TCM ()
showMetas :: [String] -> TCM ()
showScope :: TCM ()
metaParseExpr :: InteractionId -> String -> TCM Expr
actOnMeta :: [String] -> (InteractionId -> Expr -> TCM a) -> TCM a
giveMeta :: [String] -> TCM ()
refineMeta :: [String] -> TCM ()
retryConstraints :: TCM ()
evalIn :: [String] -> TCM ()
parseExpr :: String -> TCM Expr
evalTerm :: String -> TCM (ExitCode a)
typeOf :: [String] -> TCM ()
typeIn :: [String] -> TCM ()
showContext :: [String] -> TCM ()

-- | The logo that prints when Agda is started in interactive mode.
splashScreen :: String

-- | The help message
help :: [Command a] -> IO ()

module Agda.Interaction.MakeCase
data CaseContext
FunctionDef :: CaseContext
ExtendedLambda :: Int -> Int -> CaseContext

-- | Find the clause whose right hand side is the given meta BY SEARCHING
--   THE WHOLE SIGNATURE. Returns the original clause, before record
--   patterns have been translated away. Raises an error if there is no
--   matching clause.
--   
--   Andreas, 2010-09-21: This looks like a SUPER UGLY HACK to me. You are
--   walking through the WHOLE signature to find an information you have
--   thrown away earlier. (shutter with disgust). This code fails for
--   record rhs because they have been eta-expanded, so the MVar is gone.
findClause :: MetaId -> TCM (CaseContext, QName, Clause)

-- | Parse variables (visible or hidden), returning their de Bruijn
--   indices. Used in <a>makeCase</a>.
parseVariables :: InteractionId -> Range -> [String] -> TCM [Int]

-- | Entry point for case splitting tactic.
makeCase :: InteractionId -> Range -> String -> TCM (CaseContext, [Clause])
makeAbsurdClause :: QName -> SplitClause -> TCM Clause

-- | Make a clause with a question mark as rhs.
makeAbstractClause :: QName -> SplitClause -> TCM Clause
deBruijnIndex :: Expr -> TCM Nat
instance Eq CaseContext


-- | Handling of the INFINITY, SHARP and FLAT builtins.
module Agda.TypeChecking.Rules.Builtin.Coinduction

-- | The type of <tt>∞</tt>.
typeOfInf :: TCM Type

-- | The type of <tt>♯_</tt>.
typeOfSharp :: TCM Type

-- | The type of <tt>♭</tt>.
typeOfFlat :: TCM Type

-- | Binds the INFINITY builtin, but does not change the type's definition.
bindBuiltinInf :: Expr -> TCM ()

-- | Binds the SHARP builtin, and changes the definitions of INFINITY and
--   SHARP.
bindBuiltinSharp :: Expr -> TCM ()

-- | Binds the FLAT builtin, and changes its definition.
bindBuiltinFlat :: Expr -> TCM ()

module Agda.Auto.Convert
norm :: Normalise t => t -> TCM t
type O = (Maybe Int, QName)
data TMode
TMAll :: TMode
type MapS a b = (Map a b, [a])
initMapS :: MapS a b
popMapS :: (S -> (a, [b])) -> ((a, [b]) -> S -> S) -> TOM (Maybe b)
data S
S :: MapS QName (TMode, ConstRef O) -> MapS MetaId (Metavar (Exp O) (RefInfo O), Maybe (MExp O, [MExp O]), [MetaId]) -> MapS Int (Maybe (Bool, MExp O, MExp O)) -> Maybe MetaId -> MetaId -> S
sConsts :: S -> MapS QName (TMode, ConstRef O)
sMetas :: S -> MapS MetaId (Metavar (Exp O) (RefInfo O), Maybe (MExp O, [MExp O]), [MetaId])
sEqs :: S -> MapS Int (Maybe (Bool, MExp O, MExp O))
sCurMeta :: S -> Maybe MetaId
sMainMeta :: S -> MetaId
type TOM = StateT S TCM
tomy :: MetaId -> [(Bool, QName)] -> [Type] -> TCM ([ConstRef O], [MExp O], Map MetaId (Metavar (Exp O) (RefInfo O), MExp O, [MExp O], [MetaId]), [(Bool, MExp O, MExp O)], Map QName (TMode, ConstRef O))
getConst :: Bool -> QName -> TMode -> TOM (ConstRef O)
getdfv :: MetaId -> QName -> TCM Nat
getMeta :: MetaId -> TOM (Metavar (Exp O) (RefInfo O))
getEqs :: TCM [(Bool, Term, Term)]
copatternsNotImplemented :: TCM a
tomyClauses :: [Clause] -> TOM [([Pat O], MExp O)]
tomyClause :: Clause -> TOM (Maybe ([Pat O], MExp O))
tomyPat :: Arg Pattern -> TOM (Pat O)
tomyBody :: ClauseBodyF Term -> TOM (Maybe (MExp O, Int))
weaken :: Int -> MExp O -> MExp O
weakens :: Int -> MArgList O -> MArgList O
tomyType :: Type -> TOM (MExp O)
tomyExp :: Term -> TOM (MExp O)
tomyExps :: Args -> TOM (MM (ArgList O) (RefInfo O))
tomyIneq :: Comparison -> Bool
fmType :: MetaId -> Type -> Bool
fmExp :: MetaId -> Term -> Bool
fmExps :: MetaId -> Args -> Bool
fmLevel :: MetaId -> PlusLevel -> Bool
cnvh :: LensHiding a => a -> FMode
icnvh :: FMode -> ArgInfo
frommy :: MExp O -> ExceptT String IO Term
frommyType :: MExp O -> ExceptT String IO Type
frommyExp :: MExp O -> ExceptT String IO Term
frommyExps :: Nat -> MArgList O -> Term -> ExceptT String IO Term
abslamvarname :: String
modifyAbstractExpr :: Expr -> Expr
modifyAbstractClause :: Clause -> Clause
constructPats :: Map QName (TMode, ConstRef O) -> MetaId -> Clause -> TCM ([(FMode, MId)], [CSPat O])
frommyClause :: (CSCtx O, [CSPat O], Maybe (MExp O)) -> ExceptT String IO Clause
contains_constructor :: [CSPat O] -> Bool
etaContractBody :: ClauseBody -> TCM ClauseBody
freeIn :: Nat -> MExp o -> Bool
negtype :: ConstRef o -> MExp o -> MExp o
findClauseDeep :: MetaId -> TCM (Maybe (QName, Clause, Bool))
matchType :: Int -> Int -> Type -> Type -> Maybe (Nat, Nat)
instance Eq TMode

module Agda.Auto.Auto

-- | Entry point for Auto tactic (Agsy).
--   
--   <pre>
--   auto ii rng s = return (res, mmsg)
--   </pre>
--   
--   If <tt>mmsg = Just msg</tt>, the message <tt>msg</tt> produced by Agsy
--   should be displayed to the user.
--   
--   The result <tt>res</tt> of the Auto tactic can be one of the following
--   three:
--   
--   <ol>
--   <li><tt>Left [(ii,s)]</tt> A list of solutions <tt>s</tt> for
--   interaction ids <tt>ii</tt>. In particular, <tt>Left []</tt> means
--   Agsy found no solution.</li>
--   <li><tt>Right (Left cs)</tt> A list of clauses (the user allowed
--   case-split).</li>
--   <li><tt>Right (Right s)</tt> A refinement for the interaction id
--   <tt>ii</tt> in which Auto was invoked.</li>
--   </ol>
auto :: InteractionId -> Range -> String -> TCM (Either [(InteractionId, String)] (Either [String] String), Maybe String)

module Agda.Interaction.InteractionTop

-- | Auxiliary state of an interactive computation.
data CommandState
CommandState :: [InteractionId] -> Maybe (AbsolutePath, ClockTime) -> CommandLineOptions -> OldInteractionScopes -> CommandState

-- | The interaction points of the buffer, in the order in which they
--   appear in the buffer. The interaction points are recorded in
--   <tt>theTCState</tt>, but when new interaction points are added by give
--   or refine Agda does not ensure that the ranges of later interaction
--   points are updated.
theInteractionPoints :: CommandState -> [InteractionId]

-- | The file which the state applies to. Only stored if the module was
--   successfully type checked (potentially with warnings). The
--   <a>ClockTime</a> is the modification time stamp of the file when it
--   was last loaded.
theCurrentFile :: CommandState -> Maybe (AbsolutePath, ClockTime)

-- | Reset the options on each reload to these.
optionsOnReload :: CommandState -> CommandLineOptions

-- | We remember (the scope of) old interaction points to make it possible
--   to parse and compute highlighting information for the expression that
--   it got replaced by.
oldInteractionScopes :: CommandState -> OldInteractionScopes
type OldInteractionScopes = Map InteractionId ScopeInfo

-- | Initial auxiliary interaction state
initCommandState :: CommandState

-- | Monad for computing answers to interactive commands.
--   
--   <a>CommandM</a> is <a>TCM</a> extended with state <a>CommandState</a>.
type CommandM = StateT CommandState TCM

-- | Build an opposite action to <a>lift</a> for state monads.
revLift :: MonadState st m => (forall c. m c -> st -> k (c, st)) -> (forall b. k b -> m b) -> (forall x. (m a -> k x) -> k x) -> m a

-- | Opposite of <a>liftIO</a> for <a>CommandM</a>. Use only if main errors
--   are already catched.
commandMToIO :: (forall x. (CommandM a -> IO x) -> IO x) -> CommandM a

-- | Lift a TCM action transformer to a CommandM action transformer.
liftCommandMT :: (forall a. TCM a -> TCM a) -> CommandM a -> CommandM a

-- | Put a response by the callback function given by
--   <a>stInteractionOutputCallback</a>.
putResponse :: Response -> CommandM ()

-- | A Lens for <a>theInteractionPoints</a>.
modifyTheInteractionPoints :: ([InteractionId] -> [InteractionId]) -> CommandM ()

-- | A Lens for <a>oldInteractionScopes</a>.
modifyOldInteractionScopes :: (OldInteractionScopes -> OldInteractionScopes) -> CommandM ()
insertOldInteractionScope :: InteractionId -> ScopeInfo -> CommandM ()
removeOldInteractionScope :: InteractionId -> CommandM ()
getOldInteractionScope :: InteractionId -> CommandM ScopeInfo

-- | Run an <a>IOTCM</a> value, catch the exceptions, emit output
--   
--   If an error happens the state of <a>CommandM</a> does not change, but
--   stPersistent may change (which contains successfully loaded interfaces
--   for example).
runInteraction :: IOTCM -> CommandM ()

-- | An interactive computation.
type Interaction = Interaction' Range
data Interaction' range

-- | <tt>cmd_load m includes</tt> loads the module in file <tt>m</tt>,
--   using <tt>includes</tt> as the include directories.
Cmd_load :: FilePath -> [FilePath] -> Interaction' range

-- | <tt>cmd_compile b m includes</tt> compiles the module in file
--   <tt>m</tt> using the backend <tt>b</tt>, using <tt>includes</tt> as
--   the include directories.
Cmd_compile :: Backend -> FilePath -> [FilePath] -> Interaction' range
Cmd_constraints :: Interaction' range

-- | Show unsolved metas. If there are no unsolved metas but unsolved
--   constraints show those instead.
Cmd_metas :: Interaction' range

-- | Shows all the top-level names in the given module, along with their
--   types. Uses the top-level scope.
Cmd_show_module_contents_toplevel :: Rewrite -> String -> Interaction' range
Cmd_solveAll :: Interaction' range

-- | Parse the given expression (as if it were defined at the top-level of
--   the current module) and infer its type.
Cmd_infer_toplevel :: Rewrite -> String -> Interaction' range

-- | Parse and type check the given expression (as if it were defined at
--   the top-level of the current module) and normalise it.
Cmd_compute_toplevel :: Bool -> String -> Interaction' range

-- | <tt>cmd_load_highlighting_info source</tt> loads syntax highlighting
--   information for the module in <tt>source</tt>, and asks Emacs to apply
--   highlighting info from this file.
--   
--   If the module does not exist, or its module name is malformed or
--   cannot be determined, or the module has not already been visited, or
--   the cached info is out of date, then no highlighting information is
--   printed.
--   
--   This command is used to load syntax highlighting information when a
--   new file is opened, and it would probably be annoying if jumping to
--   the definition of an identifier reset the proof state, so this command
--   tries not to do that. One result of this is that the command uses the
--   current include directories, whatever they happen to be.
Cmd_load_highlighting_info :: FilePath -> Interaction' range

-- | Tells Agda to compute highlighting information for the expression just
--   spliced into an interaction point.
Cmd_highlight :: InteractionId -> range -> String -> Interaction' range

-- | Tells Agda whether or not to show implicit arguments.
ShowImplicitArgs :: Bool -> Interaction' range

-- | Toggle display of implicit arguments.
ToggleImplicitArgs :: Interaction' range

-- | Goal commands
--   
--   If the range is <a>noRange</a>, then the string comes from the
--   minibuffer rather than the goal.
Cmd_give :: InteractionId -> range -> String -> Interaction' range
Cmd_refine :: InteractionId -> range -> String -> Interaction' range
Cmd_intro :: Bool -> InteractionId -> range -> String -> Interaction' range
Cmd_refine_or_intro :: Bool -> InteractionId -> range -> String -> Interaction' range
Cmd_auto :: InteractionId -> range -> String -> Interaction' range
Cmd_context :: Rewrite -> InteractionId -> range -> String -> Interaction' range
Cmd_helper_function :: Rewrite -> InteractionId -> range -> String -> Interaction' range
Cmd_infer :: Rewrite -> InteractionId -> range -> String -> Interaction' range
Cmd_goal_type :: Rewrite -> InteractionId -> range -> String -> Interaction' range

-- | Displays the current goal and context.
Cmd_goal_type_context :: Rewrite -> InteractionId -> range -> String -> Interaction' range

-- | Displays the current goal and context <i>and</i> infers the type of an
--   expression.
Cmd_goal_type_context_infer :: Rewrite -> InteractionId -> range -> String -> Interaction' range

-- | Shows all the top-level names in the given module, along with their
--   types. Uses the scope of the given goal.
Cmd_show_module_contents :: Rewrite -> InteractionId -> range -> String -> Interaction' range
Cmd_make_case :: InteractionId -> range -> String -> Interaction' range
Cmd_compute :: Bool -> InteractionId -> range -> String -> Interaction' range
Cmd_why_in_scope :: InteractionId -> range -> String -> Interaction' range
Cmd_why_in_scope_toplevel :: String -> Interaction' range

-- | Displays version of the running Agda
Cmd_show_version :: Interaction' range
type IOTCM = IOTCM' Range
data IOTCM' range
IOTCM :: FilePath -> HighlightingLevel -> HighlightingMethod -> (Interaction' range) -> IOTCM' range

-- | The <a>Parse</a> monad. <a>StateT</a> state holds the remaining input.
type Parse a = ExceptT String (StateT String Identity) a

-- | Converter from the type of <a>reads</a> to <a>Parse</a> The first
--   paramter is part of the error message in case the parse fails.
readsToParse :: String -> (String -> Maybe (a, String)) -> Parse a
parseToReadsPrec :: Parse a -> Int -> String -> [(a, String)]

-- | Demand an exact string.
exact :: String -> Parse ()
readParse :: Read a => Parse a
parens' :: Parse a -> Parse a

-- | Can the command run even if the relevant file has not been loaded into
--   the state?
independent :: Interaction -> Bool

-- | Interpret an interaction
interpret :: Interaction -> CommandM ()
type GoalCommand = InteractionId -> Range -> String -> Interaction

-- | <tt>cmd_load' m includes cmd cmd2</tt> loads the module in file
--   <tt>m</tt>, using <tt>includes</tt> as the include directories.
--   
--   If type checking completes without any exceptions having been
--   encountered then the command <tt>cmd r</tt> is executed, where
--   <tt>r</tt> is the result of <a>typeCheckMain</a>.
cmd_load' :: FilePath -> [FilePath] -> Bool -> ((Interface, MaybeWarnings) -> CommandM ()) -> CommandM ()
withCurrentFile :: CommandM a -> CommandM a

-- | Available backends.
data Backend
MAlonzo :: Backend
MAlonzoNoMain :: Backend
Epic :: Backend
JS :: Backend
data GiveRefine
Give :: GiveRefine
Refine :: GiveRefine

-- | A "give"-like action (give, refine, etc).
--   
--   <tt>give_gen ii rng s give_ref mk_newtxt</tt> acts on interaction
--   point <tt>ii</tt> occupying range <tt>rng</tt>, placing the new
--   content given by string <tt>s</tt>, and replacing <tt>ii</tt> by the
--   newly created interaction points in the state.
give_gen :: InteractionId -> Range -> String -> GiveRefine -> CommandM ()
highlightExpr :: Expr -> TCM ()

-- | Sorts interaction points based on their ranges.
sortInteractionPoints :: [InteractionId] -> TCM [InteractionId]

-- | Pretty-prints the type of the meta-variable.
prettyTypeOfMeta :: Rewrite -> InteractionId -> TCM Doc

-- | Pretty-prints the context of the given meta-variable.
prettyContext :: Rewrite -> Bool -> InteractionId -> TCM Doc

-- | Create type of application of new helper function that would solve the
--   goal.
cmd_helper_function :: Rewrite -> InteractionId -> Range -> String -> TCM Doc

-- | Displays the current goal, the given document, and the current
--   context.
cmd_goal_type_context_and :: Doc -> Rewrite -> InteractionId -> Range -> String -> StateT CommandState (TCMT IO) ()

-- | Shows all the top-level names in the given module, along with their
--   types.
showModuleContents :: Rewrite -> Range -> String -> CommandM ()

-- | Explain why something is in scope.
whyInScope :: String -> CommandM ()

-- | Sets the command line options and updates the status information.
setCommandLineOptions' :: CommandLineOptions -> CommandM ()

-- | Computes some status information.
status :: CommandM Status

-- | Displays/updates status information.
displayStatus :: CommandM ()

-- | <tt>display_info</tt> does what <tt><tt>display_info'</tt> False</tt>
--   does, but additionally displays some status information (see
--   <a>status</a> and <a>displayStatus</a>).
display_info :: DisplayInfo -> CommandM ()
refreshStr :: [String] -> String -> ([String], String)
nameModifiers :: [String]

-- | Kill meta numbers and ranges from all metas (<tt>?</tt> and
--   <tt>_</tt>).
lowerMeta :: ExprLike a => a -> a

-- | Parses and scope checks an expression (using the "inside scope" as the
--   scope), performs the given command with the expression as input, and
--   displays the result.
parseAndDoAtToplevel :: (Expr -> TCM Expr) -> (Doc -> DisplayInfo) -> String -> CommandM ()

-- | Tell to highlight the code using the given highlighting info (unless
--   it is <tt>Nothing</tt>).
tellToUpdateHighlighting :: Maybe (HighlightingInfo, ModuleToSource) -> IO [Response]

-- | Tells the Emacs mode to go to the first error position (if any).
tellEmacsToJumpToError :: Range -> [Response]
instance Show Backend
instance Read Backend
instance Read range => Read (Interaction' range)
instance Functor Interaction'
instance Foldable Interaction'
instance Traversable Interaction'
instance Read range => Read (IOTCM' range)
instance Functor IOTCM'
instance Foldable IOTCM'
instance Traversable IOTCM'
instance Eq GiveRefine
instance Show GiveRefine
instance Read a => Read (Position' a)
instance Read AbsolutePath
instance Read a => Read (Interval' a)
instance Read a => Read (Range' a)
instance Read InteractionId

module Agda.Interaction.EmacsTop

-- | <a>mimicGHCi</a> is a fake ghci interpreter for the Emacs frontend and
--   for interaction tests.
--   
--   <a>mimicGHCi</a> reads the Emacs frontend commands from stdin,
--   interprets them and print the result into stdout.
mimicGHCi :: TCM ()


-- | Agda main module.
module Agda.Main

-- | The main function
runAgda :: TCM ()

-- | Print usage information.
printUsage :: IO ()

-- | Print version information.
printVersion :: IO ()

-- | What to do for bad options.
optionError :: String -> IO ()

-- | Main
main :: IO ()
