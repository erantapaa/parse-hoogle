-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A light-weight wrapper with utility functions around HsSyck
--   
--   This package provides a light-weight algebraic data type representing
--   parsed Yaml files. It is implemented as a more conveinent wrapper
--   around the HsSyck package, and provides utility functions as well.
@package yaml-light
@version 0.1.4


-- | A light-weight wrapper with utility functions around HsSyck
module Data.Yaml.YamlLight

-- | A light-weight, single ADT representation of a yaml document in
--   contrast with what is provided by HsSyck. Note that the YMap is an
--   actual Map from Data.Map, so behavior with respect to identical keys
--   and ordering of entries will behave as Data.Map dictates. This
--   behavior is also in compliance with the Yaml spec. If you currently
--   rely on HsSyck's preservation of ordering, you can also consider
--   representing such maps as sequences of single entry maps. See the
--   examples of "Ordered Mappings" in the Yaml spec:
--   <a>http://www.yaml.org/spec/1.2/spec.html</a>.
data YamlLight
YMap :: (Map YamlLight YamlLight) -> YamlLight
YSeq :: [YamlLight] -> YamlLight
YStr :: ByteString -> YamlLight
YNil :: YamlLight

-- | Parse a regular Haskell string
parseYaml :: String -> IO YamlLight

-- | Given a file name, parse contents of file
parseYamlFile :: String -> IO YamlLight

-- | Parse a ByteString buffer (this is faster)
parseYamlBytes :: ByteString -> IO YamlLight

-- | Convert a Syck YamlNode to a YamlLight
fromYamlNode :: YamlNode -> YamlLight

-- | Lookup the key's corresponding value in a Map. Returns Nothing if the
--   YamlLight is not a map, or if the key is not found
lookupYL :: YamlLight -> YamlLight -> Maybe YamlLight

-- | General form of lookup. Will return the first element that satisfies
--   predicate p, otherwise Nothing
lookupYLWith :: (YamlLight -> Bool) -> YamlLight -> Maybe YamlLight

-- | Combine a sequence of YMaps into a list of (key,value) pairs. The
--   ordering of the result preserves the ordering of the sequence, but the
--   ordering of the individual maps is as Data.Map handles it.
--   
--   Example:
--   
--   <pre>
--   - key1: val1
--     key2: val2
--   - key3: val3
--   </pre>
--   
--   Would become:
--   
--   <pre>
--   [(key1,val1),(key2,val2),(key3,val3)]
--   </pre>
--   
--   where key1 and key2 might be arranged differently as Data.Map would
--   arrange them. This does not enforce uniqueness of keys across
--   different maps. Any items of the sequence that are not maps will not
--   be present in the output list. Returns Nothing if not called on a
--   Sequence
combineSequencedMaps :: YamlLight -> Maybe [(YamlLight, YamlLight)]

-- | Take a YamlLight that is a YMap of keys to YSeqs, and return a list of
--   (key,elem) pairs, where elem is an element of the YSeq under key.
--   
--   Example:
--   
--   <pre>
--   key1: [val1, val2, val3]
--   key2: [val4, val5]
--   </pre>
--   
--   Would become:
--   
--   <pre>
--   [(key1,val1),(key1,val2),(key1,val3),(key2,val4),(key2,val5)]
--   </pre>
--   
--   where the precise ordering of the key1 and key2 pairs depends on the
--   ordering of Data.Map. Any values of keys that are not sequences will
--   not appear in the output list. Returns Nothing if not called on a
--   YMap.
combineMappedSequences :: YamlLight -> Maybe [(YamlLight, YamlLight)]

-- | Create a list of all the terminal YStrs in a YamlLight tree, and
--   couple them with a list of all the keys above them.
--   
--   Example:
--   
--   <pre>
--   - key1:
--       key1_1:
--         - "str1"
--         - "str2"
--       key1_2:
--         - "str2"
--         - "str3"
--   - key2:
--       "str4"
--   - "str5"
--   </pre>
--   
--   Would become:
--   
--   <pre>
--   [("str1",[key1_1, key1]), ("str2", [key1_1, key1]), ("str2", [key1_2, key1]), ("str3",[key1_2, key1]), ("str4",[key2]), ("str5",[])
--   </pre>
getTerminalsKeys :: YamlLight -> [(ByteString, [YamlLight])]

-- | Get the contents of a sequence
unSeq :: YamlLight -> Maybe [YamlLight]

-- | Get the contents of a map
unMap :: YamlLight -> Maybe (Map YamlLight YamlLight)

-- | Get the contents of a string
unStr :: YamlLight -> Maybe ByteString
instance Show YamlLight
instance Ord YamlLight
instance Eq YamlLight
