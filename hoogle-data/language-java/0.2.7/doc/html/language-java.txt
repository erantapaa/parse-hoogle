-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer
--   
@package language-java
@version 0.2.7

module Language.Java.Syntax

-- | A compilation unit is the top level syntactic goal symbol of a Java
--   program.
data CompilationUnit
CompilationUnit :: (Maybe PackageDecl) -> [ImportDecl] -> [TypeDecl] -> CompilationUnit

-- | A package declaration appears within a compilation unit to indicate
--   the package to which the compilation unit belongs.
data PackageDecl
PackageDecl :: Name -> PackageDecl

-- | An import declaration allows a static member or a named type to be
--   referred to by a single unqualified identifier. The first argument
--   signals whether the declaration only imports static members. The last
--   argument signals whether the declaration brings all names in the named
--   type or package, or only brings a single name into scope.
data ImportDecl
ImportDecl :: Bool -> Name -> Bool -> ImportDecl

-- | A type declaration declares a class type or an interface type.
data TypeDecl
ClassTypeDecl :: ClassDecl -> TypeDecl
InterfaceTypeDecl :: InterfaceDecl -> TypeDecl

-- | A class declaration specifies a new named reference type.
data ClassDecl
ClassDecl :: [Modifier] -> Ident -> [TypeParam] -> (Maybe RefType) -> [RefType] -> ClassBody -> ClassDecl
EnumDecl :: [Modifier] -> Ident -> [RefType] -> EnumBody -> ClassDecl

-- | A class body may contain declarations of members of the class, that
--   is, fields, classes, interfaces and methods. A class body may also
--   contain instance initializers, static initializers, and declarations
--   of constructors for the class.
data ClassBody
ClassBody :: [Decl] -> ClassBody

-- | The body of an enum type may contain enum constants.
data EnumBody
EnumBody :: [EnumConstant] -> [Decl] -> EnumBody

-- | An enum constant defines an instance of the enum type.
data EnumConstant
EnumConstant :: Ident -> [Argument] -> (Maybe ClassBody) -> EnumConstant

-- | An interface declaration introduces a new reference type whose members
--   are classes, interfaces, constants and abstract methods. This type has
--   no implementation, but otherwise unrelated classes can implement it by
--   providing implementations for its abstract methods.
data InterfaceDecl
InterfaceDecl :: [Modifier] -> Ident -> [TypeParam] -> [RefType] -> InterfaceBody -> InterfaceDecl

-- | The body of an interface may declare members of the interface.
data InterfaceBody
InterfaceBody :: [MemberDecl] -> InterfaceBody

-- | A declaration is either a member declaration, or a declaration of an
--   initializer, which may be static.
data Decl
MemberDecl :: MemberDecl -> Decl
InitDecl :: Bool -> Block -> Decl

-- | A class or interface member can be an inner class or interface, a
--   field or constant, or a method or constructor. An interface may only
--   have as members constants (not fields), abstract methods, and no
--   constructors.
data MemberDecl

-- | The variables of a class type are introduced by field declarations.
FieldDecl :: [Modifier] -> Type -> [VarDecl] -> MemberDecl

-- | A method declares executable code that can be invoked, passing a fixed
--   number of values as arguments.
MethodDecl :: [Modifier] -> [TypeParam] -> (Maybe Type) -> Ident -> [FormalParam] -> [ExceptionType] -> MethodBody -> MemberDecl

-- | A constructor is used in the creation of an object that is an instance
--   of a class.
ConstructorDecl :: [Modifier] -> [TypeParam] -> Ident -> [FormalParam] -> [ExceptionType] -> ConstructorBody -> MemberDecl

-- | A member class is a class whose declaration is directly enclosed in
--   another class or interface declaration.
MemberClassDecl :: ClassDecl -> MemberDecl

-- | A member interface is an interface whose declaration is directly
--   enclosed in another class or interface declaration.
MemberInterfaceDecl :: InterfaceDecl -> MemberDecl

-- | A declaration of a variable, which may be explicitly initialized.
data VarDecl
VarDecl :: VarDeclId -> (Maybe VarInit) -> VarDecl

-- | The name of a variable in a declaration, which may be an array.
data VarDeclId
VarId :: Ident -> VarDeclId

-- | Multi-dimensional arrays are represented by nested applications of
--   <a>VarDeclArray</a>.
VarDeclArray :: VarDeclId -> VarDeclId

-- | Explicit initializer for a variable declaration.
data VarInit
InitExp :: Exp -> VarInit
InitArray :: ArrayInit -> VarInit

-- | A formal parameter in method declaration. The last parameter for a
--   given declaration may be marked as variable arity, indicated by the
--   boolean argument.
data FormalParam
FormalParam :: [Modifier] -> Type -> Bool -> VarDeclId -> FormalParam

-- | A method body is either a block of code that implements the method or
--   simply a semicolon, indicating the lack of an implementation (modelled
--   by <a>Nothing</a>).
data MethodBody
MethodBody :: (Maybe Block) -> MethodBody

-- | The first statement of a constructor body may be an explicit
--   invocation of another constructor of the same class or of the direct
--   superclass.
data ConstructorBody
ConstructorBody :: (Maybe ExplConstrInv) -> [BlockStmt] -> ConstructorBody

-- | An explicit constructor invocation invokes another constructor of the
--   same class, or a constructor of the direct superclass, which may be
--   qualified to explicitly specify the newly created object's immediately
--   enclosing instance.
data ExplConstrInv
ThisInvoke :: [RefType] -> [Argument] -> ExplConstrInv
SuperInvoke :: [RefType] -> [Argument] -> ExplConstrInv
PrimarySuperInvoke :: Exp -> [RefType] -> [Argument] -> ExplConstrInv

-- | A modifier specifying properties of a given declaration. In general
--   only a few of these modifiers are allowed for each declaration type,
--   for instance a member type declaration may only specify one of public,
--   private or protected.
data Modifier
Public :: Modifier
Private :: Modifier
Protected :: Modifier
Abstract :: Modifier
Final :: Modifier
Static :: Modifier
StrictFP :: Modifier
Transient :: Modifier
Volatile :: Modifier
Native :: Modifier
Annotation :: Annotation -> Modifier
Synchronised :: Modifier

-- | Annotations have three different forms: no-parameter, single-parameter
--   or key-value pairs
data Annotation
NormalAnnotation :: Name -> [(Ident, ElementValue)] -> Annotation
annName :: Annotation -> Name
annKV :: Annotation -> [(Ident, ElementValue)]
SingleElementAnnotation :: Name -> ElementValue -> Annotation
annName :: Annotation -> Name
annValue :: Annotation -> ElementValue
MarkerAnnotation :: Name -> Annotation
annName :: Annotation -> Name
desugarAnnotation :: Annotation -> (Name, [(Ident, ElementValue)])
desugarAnnotation' :: Annotation -> Annotation

-- | Annotations may contain annotations or (loosely) expressions
data ElementValue
EVVal :: VarInit -> ElementValue
EVAnn :: Annotation -> ElementValue

-- | A block is a sequence of statements, local class declarations and
--   local variable declaration statements within braces.
data Block
Block :: [BlockStmt] -> Block

-- | A block statement is either a normal statement, a local class
--   declaration or a local variable declaration.
data BlockStmt
BlockStmt :: Stmt -> BlockStmt
LocalClass :: ClassDecl -> BlockStmt
LocalVars :: [Modifier] -> Type -> [VarDecl] -> BlockStmt

-- | A Java statement.
data Stmt

-- | A statement can be a nested block.
StmtBlock :: Block -> Stmt

-- | The <tt>if-then</tt> statement allows conditional execution of a
--   statement.
IfThen :: Exp -> Stmt -> Stmt

-- | The <tt>if-then-else</tt> statement allows conditional choice of two
--   statements, executing one or the other but not both.
IfThenElse :: Exp -> Stmt -> Stmt -> Stmt

-- | The <tt>while</tt> statement executes an expression and a statement
--   repeatedly until the value of the expression is false.
While :: Exp -> Stmt -> Stmt

-- | The basic <tt>for</tt> statement executes some initialization code,
--   then executes an expression, a statement, and some update code
--   repeatedly until the value of the expression is false.
BasicFor :: (Maybe ForInit) -> (Maybe Exp) -> (Maybe [Exp]) -> Stmt -> Stmt

-- | The enhanced <tt>for</tt> statement iterates over an array or a value
--   of a class that implements the <tt>iterator</tt> interface.
EnhancedFor :: [Modifier] -> Type -> Ident -> Exp -> Stmt -> Stmt

-- | An empty statement does nothing.
Empty :: Stmt

-- | Certain kinds of expressions may be used as statements by following
--   them with semicolons: assignments, pre- or post-inc- or
--   decrementation, method invocation or class instance creation
--   expressions.
ExpStmt :: Exp -> Stmt

-- | An assertion is a statement containing a boolean expression, where an
--   error is reported if the expression evaluates to false.
Assert :: Exp -> (Maybe Exp) -> Stmt

-- | The switch statement transfers control to one of several statements
--   depending on the value of an expression.
Switch :: Exp -> [SwitchBlock] -> Stmt

-- | The <tt>do</tt> statement executes a statement and an expression
--   repeatedly until the value of the expression is false.
Do :: Stmt -> Exp -> Stmt

-- | A <tt>break</tt> statement transfers control out of an enclosing
--   statement.
Break :: (Maybe Ident) -> Stmt

-- | A <tt>continue</tt> statement may occur only in a while, do, or for
--   statement. Control passes to the loop-continuation point of that
--   statement.
Continue :: (Maybe Ident) -> Stmt
Return :: (Maybe Exp) -> Stmt

-- | A <tt>synchronized</tt> statement acquires a mutual-exclusion lock on
--   behalf of the executing thread, executes a block, then releases the
--   lock. While the executing thread owns the lock, no other thread may
--   acquire the lock.
Synchronized :: Exp -> Block -> Stmt

-- | A <tt>throw</tt> statement causes an exception to be thrown.
Throw :: Exp -> Stmt

-- | A try statement executes a block. If a value is thrown and the try
--   statement has one or more catch clauses that can catch it, then
--   control will be transferred to the first such catch clause. If the try
--   statement has a finally clause, then another block of code is
--   executed, no matter whether the try block completes normally or
--   abruptly, and no matter whether a catch clause is first given control.
Try :: Block -> [Catch] -> (Maybe Block) -> Stmt

-- | Statements may have label prefixes.
Labeled :: Ident -> Stmt -> Stmt

-- | If a value is thrown and the try statement has one or more catch
--   clauses that can catch it, then control will be transferred to the
--   first such catch clause.
data Catch
Catch :: FormalParam -> Block -> Catch

-- | A block of code labelled with a <tt>case</tt> or <tt>default</tt>
--   within a <tt>switch</tt> statement.
data SwitchBlock
SwitchBlock :: SwitchLabel -> [BlockStmt] -> SwitchBlock

-- | A label within a <tt>switch</tt> statement.
data SwitchLabel

-- | The expression contained in the <tt>case</tt> must be a <a>Lit</a> or
--   an <tt>enum</tt> constant.
SwitchCase :: Exp -> SwitchLabel
Default :: SwitchLabel

-- | Initialization code for a basic <tt>for</tt> statement.
data ForInit
ForLocalVars :: [Modifier] -> Type -> [VarDecl] -> ForInit
ForInitExps :: [Exp] -> ForInit

-- | An exception type has to be a class type or a type variable.
type ExceptionType = RefType

-- | Arguments to methods and constructors are expressions.
type Argument = Exp

-- | A Java expression.
data Exp

-- | A literal denotes a fixed, unchanging value.
Lit :: Literal -> Exp

-- | A class literal, which is an expression consisting of the name of a
--   class, interface, array, or primitive type, or the pseudo-type void
--   (modelled by <a>Nothing</a>), followed by a <a>.</a> and the token
--   class.
ClassLit :: (Maybe Type) -> Exp

-- | The keyword <tt>this</tt> denotes a value that is a reference to the
--   object for which the instance method was invoked, or to the object
--   being constructed.
This :: Exp

-- | Any lexically enclosing instance can be referred to by explicitly
--   qualifying the keyword this.
ThisClass :: Name -> Exp

-- | A class instance creation expression is used to create new objects
--   that are instances of classes. | The first argument is a list of
--   non-wildcard type arguments to a generic constructor. What follows is
--   the type to be instantiated, the list of arguments passed to the
--   constructor, and optionally a class body that makes the constructor
--   result in an object of an <i>anonymous</i> class.
InstanceCreation :: [TypeArgument] -> ClassType -> [Argument] -> (Maybe ClassBody) -> Exp

-- | A qualified class instance creation expression enables the creation of
--   instances of inner member classes and their anonymous subclasses.
QualInstanceCreation :: Exp -> [TypeArgument] -> Ident -> [Argument] -> (Maybe ClassBody) -> Exp

-- | An array instance creation expression is used to create new arrays.
--   The last argument denotes the number of dimensions that have no
--   explicit length given. These dimensions must be given last.
ArrayCreate :: Type -> [Exp] -> Int -> Exp

-- | An array instance creation expression may come with an explicit
--   initializer. Such expressions may not be given explicit lengths for
--   any of its dimensions.
ArrayCreateInit :: Type -> Int -> ArrayInit -> Exp

-- | A field access expression.
FieldAccess :: FieldAccess -> Exp

-- | A method invocation expression.
MethodInv :: MethodInvocation -> Exp

-- | An array access expression refers to a variable that is a component of
--   an array.
ArrayAccess :: ArrayIndex -> Exp

-- | An expression name, e.g. a variable.
ExpName :: Name -> Exp

-- | Post-incrementation expression, i.e. an expression followed by
--   <tt>++</tt>.
PostIncrement :: Exp -> Exp

-- | Post-decrementation expression, i.e. an expression followed by
--   <tt>--</tt>.
PostDecrement :: Exp -> Exp

-- | Pre-incrementation expression, i.e. an expression preceded by
--   <tt>++</tt>.
PreIncrement :: Exp -> Exp

-- | Pre-decrementation expression, i.e. an expression preceded by
--   <tt>--</tt>.
PreDecrement :: Exp -> Exp

-- | Unary plus, the promotion of the value of the expression to a
--   primitive numeric type.
PrePlus :: Exp -> Exp

-- | Unary minus, the promotion of the negation of the value of the
--   expression to a primitive numeric type.
PreMinus :: Exp -> Exp

-- | Unary bitwise complementation: note that, in all cases, <tt>~x</tt>
--   equals <tt>(-x)-1</tt>.
PreBitCompl :: Exp -> Exp

-- | Logical complementation of boolean values.
PreNot :: Exp -> Exp

-- | A cast expression converts, at run time, a value of one numeric type
--   to a similar value of another numeric type; or confirms, at compile
--   time, that the type of an expression is boolean; or checks, at run
--   time, that a reference value refers to an object whose class is
--   compatible with a specified reference type.
Cast :: Type -> Exp -> Exp

-- | The application of a binary operator to two operand expressions.
BinOp :: Exp -> Op -> Exp -> Exp

-- | Testing whether the result of an expression is an instance of some
--   reference type.
InstanceOf :: Exp -> RefType -> Exp

-- | The conditional operator <tt>? :</tt> uses the boolean value of one
--   expression to decide which of two other expressions should be
--   evaluated.
Cond :: Exp -> Exp -> Exp -> Exp

-- | Assignment of the result of an expression to a variable.
Assign :: Lhs -> AssignOp -> Exp -> Exp

-- | A literal denotes a fixed, unchanging value.
data Literal
Int :: Integer -> Literal
Word :: Integer -> Literal
Float :: Double -> Literal
Double :: Double -> Literal
Boolean :: Bool -> Literal
Char :: Char -> Literal
String :: String -> Literal
Null :: Literal

-- | A binary infix operator.
data Op
Mult :: Op
Div :: Op
Rem :: Op
Add :: Op
Sub :: Op
LShift :: Op
RShift :: Op
RRShift :: Op
LThan :: Op
GThan :: Op
LThanE :: Op
GThanE :: Op
Equal :: Op
NotEq :: Op
And :: Op
Or :: Op
Xor :: Op
CAnd :: Op
COr :: Op

-- | An assignment operator.
data AssignOp
EqualA :: AssignOp
MultA :: AssignOp
DivA :: AssignOp
RemA :: AssignOp
AddA :: AssignOp
SubA :: AssignOp
LShiftA :: AssignOp
RShiftA :: AssignOp
RRShiftA :: AssignOp
AndA :: AssignOp
XorA :: AssignOp
OrA :: AssignOp

-- | The left-hand side of an assignment expression. This operand may be a
--   named variable, such as a local variable or a field of the current
--   object or class, or it may be a computed variable, as can result from
--   a field access or an array access.
data Lhs

-- | Assign to a variable
NameLhs :: Name -> Lhs

-- | Assign through a field access
FieldLhs :: FieldAccess -> Lhs

-- | Assign to an array
ArrayLhs :: ArrayIndex -> Lhs

-- | Array access
data ArrayIndex

-- | Index into an array
ArrayIndex :: Exp -> [Exp] -> ArrayIndex

-- | A field access expression may access a field of an object or array, a
--   reference to which is the value of either an expression or the special
--   keyword super.
data FieldAccess

-- | Accessing a field of an object or array computed from an expression.
PrimaryFieldAccess :: Exp -> Ident -> FieldAccess

-- | Accessing a field of the superclass.
SuperFieldAccess :: Ident -> FieldAccess

-- | Accessing a (static) field of a named class.
ClassFieldAccess :: Name -> Ident -> FieldAccess

-- | A method invocation expression is used to invoke a class or instance
--   method.
data MethodInvocation

-- | Invoking a specific named method.
MethodCall :: Name -> [Argument] -> MethodInvocation

-- | Invoking a method of a class computed from a primary expression,
--   giving arguments for any generic type parameters.
PrimaryMethodCall :: Exp -> [RefType] -> Ident -> [Argument] -> MethodInvocation

-- | Invoking a method of the super class, giving arguments for any generic
--   type parameters.
SuperMethodCall :: [RefType] -> Ident -> [Argument] -> MethodInvocation

-- | Invoking a method of the superclass of a named class, giving arguments
--   for any generic type parameters.
ClassMethodCall :: Name -> [RefType] -> Ident -> [Argument] -> MethodInvocation

-- | Invoking a method of a named type, giving arguments for any generic
--   type parameters.
TypeMethodCall :: Name -> [RefType] -> Ident -> [Argument] -> MethodInvocation

-- | An array initializer may be specified in a declaration, or as part of
--   an array creation expression, creating an array and providing some
--   initial values
data ArrayInit
ArrayInit :: [VarInit] -> ArrayInit

-- | There are two kinds of types in the Java programming language:
--   primitive types and reference types.
data Type
PrimType :: PrimType -> Type
RefType :: RefType -> Type

-- | There are three kinds of reference types: class types, interface
--   types, and array types. Reference types may be parameterized with type
--   arguments. Type variables cannot be syntactically distinguished from
--   class type identifiers, and are thus represented uniformly as single
--   ident class types.
data RefType
ClassRefType :: ClassType -> RefType

-- | TypeVariable Ident
ArrayType :: Type -> RefType

-- | A class or interface type consists of a type declaration specifier,
--   optionally followed by type arguments (in which case it is a
--   parameterized type).
data ClassType
ClassType :: [(Ident, [TypeArgument])] -> ClassType

-- | Type arguments may be either reference types or wildcards.
data TypeArgument
Wildcard :: (Maybe WildcardBound) -> TypeArgument
ActualType :: RefType -> TypeArgument

-- | Wildcards may be given explicit bounds, either upper
--   (<tt>extends</tt>) or lower (<tt>super</tt>) bounds.
data WildcardBound
ExtendsBound :: RefType -> WildcardBound
SuperBound :: RefType -> WildcardBound

-- | A primitive type is predefined by the Java programming language and
--   named by its reserved keyword.
data PrimType
BooleanT :: PrimType
ByteT :: PrimType
ShortT :: PrimType
IntT :: PrimType
LongT :: PrimType
CharT :: PrimType
FloatT :: PrimType
DoubleT :: PrimType

-- | A class is generic if it declares one or more type variables. These
--   type variables are known as the type parameters of the class.
data TypeParam
TypeParam :: Ident -> [RefType] -> TypeParam

-- | A single identifier.
data Ident
Ident :: String -> Ident

-- | A name, i.e. a period-separated list of identifiers.
data Name
Name :: [Ident] -> Name
instance Typeable Literal
instance Typeable Op
instance Typeable AssignOp
instance Typeable PrimType
instance Typeable Ident
instance Typeable ClassType
instance Typeable TypeArgument
instance Typeable WildcardBound
instance Typeable RefType
instance Typeable Type
instance Typeable TypeParam
instance Typeable VarDeclId
instance Typeable Name
instance Typeable Annotation
instance Typeable ElementValue
instance Typeable VarInit
instance Typeable ArrayInit
instance Typeable Exp
instance Typeable MethodInvocation
instance Typeable FieldAccess
instance Typeable ArrayIndex
instance Typeable Lhs
instance Typeable ClassBody
instance Typeable Decl
instance Typeable Block
instance Typeable BlockStmt
instance Typeable Stmt
instance Typeable ForInit
instance Typeable Modifier
instance Typeable VarDecl
instance Typeable SwitchBlock
instance Typeable SwitchLabel
instance Typeable Catch
instance Typeable FormalParam
instance Typeable ClassDecl
instance Typeable EnumBody
instance Typeable EnumConstant
instance Typeable MemberDecl
instance Typeable ConstructorBody
instance Typeable ExplConstrInv
instance Typeable MethodBody
instance Typeable InterfaceDecl
instance Typeable InterfaceBody
instance Typeable TypeDecl
instance Typeable ImportDecl
instance Typeable PackageDecl
instance Typeable CompilationUnit
instance Eq Literal
instance Ord Literal
instance Show Literal
instance Data Literal
instance Eq Op
instance Ord Op
instance Show Op
instance Data Op
instance Eq AssignOp
instance Ord AssignOp
instance Show AssignOp
instance Data AssignOp
instance Eq PrimType
instance Ord PrimType
instance Show PrimType
instance Data PrimType
instance Eq Ident
instance Ord Ident
instance Show Ident
instance Data Ident
instance Eq ClassType
instance Ord ClassType
instance Show ClassType
instance Data ClassType
instance Eq TypeArgument
instance Ord TypeArgument
instance Show TypeArgument
instance Data TypeArgument
instance Eq WildcardBound
instance Ord WildcardBound
instance Show WildcardBound
instance Data WildcardBound
instance Eq RefType
instance Ord RefType
instance Show RefType
instance Data RefType
instance Eq Type
instance Ord Type
instance Show Type
instance Data Type
instance Eq TypeParam
instance Ord TypeParam
instance Show TypeParam
instance Data TypeParam
instance Eq VarDeclId
instance Ord VarDeclId
instance Show VarDeclId
instance Data VarDeclId
instance Eq Name
instance Ord Name
instance Show Name
instance Data Name
instance Eq Annotation
instance Ord Annotation
instance Show Annotation
instance Data Annotation
instance Eq ElementValue
instance Ord ElementValue
instance Show ElementValue
instance Data ElementValue
instance Eq VarInit
instance Ord VarInit
instance Show VarInit
instance Data VarInit
instance Eq ArrayInit
instance Ord ArrayInit
instance Show ArrayInit
instance Data ArrayInit
instance Eq Exp
instance Ord Exp
instance Show Exp
instance Data Exp
instance Eq MethodInvocation
instance Ord MethodInvocation
instance Show MethodInvocation
instance Data MethodInvocation
instance Eq FieldAccess
instance Ord FieldAccess
instance Show FieldAccess
instance Data FieldAccess
instance Eq ArrayIndex
instance Ord ArrayIndex
instance Show ArrayIndex
instance Data ArrayIndex
instance Eq Lhs
instance Ord Lhs
instance Show Lhs
instance Data Lhs
instance Eq ClassBody
instance Ord ClassBody
instance Show ClassBody
instance Data ClassBody
instance Eq Decl
instance Ord Decl
instance Show Decl
instance Data Decl
instance Eq Block
instance Ord Block
instance Show Block
instance Data Block
instance Eq BlockStmt
instance Ord BlockStmt
instance Show BlockStmt
instance Data BlockStmt
instance Eq Stmt
instance Ord Stmt
instance Show Stmt
instance Data Stmt
instance Eq ForInit
instance Ord ForInit
instance Show ForInit
instance Data ForInit
instance Eq Modifier
instance Ord Modifier
instance Show Modifier
instance Data Modifier
instance Eq VarDecl
instance Ord VarDecl
instance Show VarDecl
instance Data VarDecl
instance Eq SwitchBlock
instance Ord SwitchBlock
instance Show SwitchBlock
instance Data SwitchBlock
instance Eq SwitchLabel
instance Ord SwitchLabel
instance Show SwitchLabel
instance Data SwitchLabel
instance Eq Catch
instance Ord Catch
instance Show Catch
instance Data Catch
instance Eq FormalParam
instance Ord FormalParam
instance Show FormalParam
instance Data FormalParam
instance Eq ClassDecl
instance Ord ClassDecl
instance Show ClassDecl
instance Data ClassDecl
instance Eq EnumBody
instance Ord EnumBody
instance Show EnumBody
instance Data EnumBody
instance Eq EnumConstant
instance Ord EnumConstant
instance Show EnumConstant
instance Data EnumConstant
instance Eq MemberDecl
instance Ord MemberDecl
instance Show MemberDecl
instance Data MemberDecl
instance Eq ConstructorBody
instance Ord ConstructorBody
instance Show ConstructorBody
instance Data ConstructorBody
instance Eq ExplConstrInv
instance Ord ExplConstrInv
instance Show ExplConstrInv
instance Data ExplConstrInv
instance Eq MethodBody
instance Ord MethodBody
instance Show MethodBody
instance Data MethodBody
instance Eq InterfaceDecl
instance Ord InterfaceDecl
instance Show InterfaceDecl
instance Data InterfaceDecl
instance Eq InterfaceBody
instance Ord InterfaceBody
instance Show InterfaceBody
instance Data InterfaceBody
instance Eq TypeDecl
instance Ord TypeDecl
instance Show TypeDecl
instance Data TypeDecl
instance Eq ImportDecl
instance Ord ImportDecl
instance Show ImportDecl
instance Data ImportDecl
instance Eq PackageDecl
instance Ord PackageDecl
instance Show PackageDecl
instance Data PackageDecl
instance Eq CompilationUnit
instance Ord CompilationUnit
instance Show CompilationUnit
instance Data CompilationUnit

module Language.Java.Pretty
prettyPrint :: Pretty a => a -> String
parenPrec :: Int -> Int -> Doc -> Doc
class Pretty a where pretty = prettyPrec 0 prettyPrec _ = pretty
pretty :: Pretty a => a -> Doc
prettyPrec :: Pretty a => Int -> a -> Doc
ppEVList :: (Pretty a1, Pretty a) => Int -> [(a, a1)] -> Doc
ppArgs :: Pretty a => Int -> [a] -> Doc
ppTypeParams :: Pretty a => Int -> [a] -> Doc
ppImplements :: Int -> [RefType] -> Doc
ppExtends :: Int -> [RefType] -> Doc
ppThrows :: Int -> [ExceptionType] -> Doc
ppResultType :: Int -> Maybe Type -> Doc
prettyNestedStmt :: Int -> Stmt -> Doc
maybePP :: Pretty a => Int -> Maybe a -> Doc
opt :: Bool -> Doc -> Doc
braceBlock :: [Doc] -> Doc
opPrec :: Num a => Op -> a
escapeGeneral :: Char -> String
escapeChar :: Char -> String
escapeString :: Char -> String
instance Pretty Ident
instance Pretty Name
instance Pretty TypeParam
instance Pretty PrimType
instance Pretty WildcardBound
instance Pretty TypeArgument
instance Pretty ClassType
instance Pretty RefType
instance Pretty Type
instance Pretty ArrayInit
instance Pretty MethodInvocation
instance Pretty FieldAccess
instance Pretty ArrayIndex
instance Pretty Lhs
instance Pretty AssignOp
instance Pretty Op
instance Pretty Literal
instance Pretty Exp
instance Pretty ForInit
instance Pretty SwitchLabel
instance Pretty SwitchBlock
instance Pretty Catch
instance Pretty Stmt
instance Pretty BlockStmt
instance Pretty Block
instance Pretty ElementValue
instance Pretty Annotation
instance Pretty Modifier
instance Pretty ExplConstrInv
instance Pretty ConstructorBody
instance Pretty MethodBody
instance Pretty FormalParam
instance Pretty VarInit
instance Pretty VarDeclId
instance Pretty VarDecl
instance Pretty MemberDecl
instance Pretty Decl
instance Pretty InterfaceBody
instance Pretty InterfaceDecl
instance Pretty EnumConstant
instance Pretty EnumBody
instance Pretty ClassBody
instance Pretty ClassDecl
instance Pretty TypeDecl
instance Pretty ImportDecl
instance Pretty PackageDecl
instance Pretty CompilationUnit

module Language.Java.Lexer
data L a
L :: Pos -> a -> L a
data Token
KW_Abstract :: Token
KW_Assert :: Token
KW_Boolean :: Token
KW_Break :: Token
KW_Byte :: Token
KW_Case :: Token
KW_Catch :: Token
KW_Char :: Token
KW_Class :: Token
KW_Const :: Token
KW_Continue :: Token
KW_Default :: Token
KW_Do :: Token
KW_Double :: Token
KW_Else :: Token
KW_Enum :: Token
KW_Extends :: Token
KW_Final :: Token
KW_Finally :: Token
KW_Float :: Token
KW_For :: Token
KW_Goto :: Token
KW_If :: Token
KW_Implements :: Token
KW_Import :: Token
KW_Instanceof :: Token
KW_Int :: Token
KW_Interface :: Token
KW_Long :: Token
KW_Native :: Token
KW_New :: Token
KW_Package :: Token
KW_Private :: Token
KW_Protected :: Token
KW_Public :: Token
KW_Return :: Token
KW_Short :: Token
KW_Static :: Token
KW_Strictfp :: Token
KW_Super :: Token
KW_Switch :: Token
KW_Synchronized :: Token
KW_This :: Token
KW_Throw :: Token
KW_Throws :: Token
KW_Transient :: Token
KW_Try :: Token
KW_Void :: Token
KW_Volatile :: Token
KW_While :: Token
OpenParen :: Token
CloseParen :: Token
OpenSquare :: Token
CloseSquare :: Token
OpenCurly :: Token
CloseCurly :: Token
SemiColon :: Token
Comma :: Token
Period :: Token
IntTok :: Integer -> Token
LongTok :: Integer -> Token
DoubleTok :: Double -> Token
FloatTok :: Double -> Token
CharTok :: Char -> Token
StringTok :: String -> Token
BoolTok :: Bool -> Token
NullTok :: Token
IdentTok :: String -> Token
Op_Equal :: Token
Op_GThan :: Token
Op_LThan :: Token
Op_Bang :: Token
Op_Tilde :: Token
Op_Query :: Token
Op_Colon :: Token
Op_Equals :: Token
Op_LThanE :: Token
Op_GThanE :: Token
Op_BangE :: Token
Op_AAnd :: Token
Op_OOr :: Token
Op_PPlus :: Token
Op_MMinus :: Token
Op_Plus :: Token
Op_Minus :: Token
Op_Star :: Token
Op_Slash :: Token
Op_And :: Token
Op_Or :: Token
Op_Caret :: Token
Op_Percent :: Token
Op_LShift :: Token
Op_PlusE :: Token
Op_MinusE :: Token
Op_StarE :: Token
Op_SlashE :: Token
Op_AndE :: Token
Op_OrE :: Token
Op_CaretE :: Token
Op_PercentE :: Token
Op_LShiftE :: Token
Op_RShiftE :: Token
Op_RRShiftE :: Token
Op_AtSign :: Token
lexer :: String -> [L Token]
instance Eq AlexPosn
instance Show AlexPosn
instance Show a => Show (L a)
instance Eq a => Eq (L a)
instance Show Token
instance Eq Token
instance Functor AlexLastAcc

module Language.Java.Parser
parser :: Parsec [L Token] () a -> String -> Either ParseError a
compilationUnit :: P CompilationUnit
packageDecl :: P PackageDecl
importDecl :: P ImportDecl
typeDecl :: P (Maybe TypeDecl)
classDecl :: P (Mod ClassDecl)
interfaceDecl :: P (Mod InterfaceDecl)
memberDecl :: P (Mod MemberDecl)
fieldDecl :: P (Mod MemberDecl)
methodDecl :: P (Mod MemberDecl)
constrDecl :: P (Mod MemberDecl)
interfaceMemberDecl :: P (Mod MemberDecl)
absMethodDecl :: P (Mod MemberDecl)
formalParams :: P [FormalParam]
formalParam :: P FormalParam
modifier :: P Modifier
varDecls :: P [VarDecl]
varDecl :: P VarDecl
block :: P Block
blockStmt :: P BlockStmt
stmt :: P Stmt
stmtExp :: P Exp
exp :: P Exp
primary :: P Exp
literal :: P Literal
ttype :: P Type
primType :: P PrimType
refType :: P RefType
classType :: P ClassType
resultType :: P (Maybe Type)
typeParams :: P [TypeParam]
typeParam :: P TypeParam
name :: P Name
ident :: P Ident
empty :: P ()
list :: P a -> P [a]
list1 :: P a -> P [a]
seplist :: P a -> P sep -> P [a]
seplist1 :: P a -> P sep -> P [a]
opt :: P a -> P (Maybe a)
bopt :: P a -> P Bool
lopt :: P [a] -> P [a]
comma :: P ()
semiColon :: P ()
period :: P ()
colon :: P ()
