-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a parallel implementation of logic programming using distributed tree exploration
--   
--   NOTE: In addition to the following package description, see
--   
--   <ul>
--   <li><a>TUTORIAL.md</a> for a tutorial,</li>
--   <li><a>USERS_GUIDE.md</a> for a user's guide that provides more
--   information about how to use this package, and</li>
--   <li><a>README.md</a> for an FAQ.</li>
--   </ul>
--   
--   You can think of this package in two equivalent ways. First, you can
--   think of it as an implementation of logic programming that is designed
--   to be parellelized using workers that have no memory shared between
--   them (hence, "distributed"). Second, you can think of this package as
--   providing infrastructure for exploring a tree in parallel. The
--   connection between these two perspectives is that logic programming
--   involves making nondeterministic choices, and each such choice is
--   equivalent to a branch point in a tree representing the search space
--   of the logic program. In the rest of the reference documentation we
--   will focus on the tree perspective simply because a lot of the
--   functionality makes the most sense from the perspective of working
--   with trees, but one is always free to ignore this and simply write a
--   logic program using the standard approach of using <a>MonadPlus</a> to
--   indicate choice and failure, and the <a>Tree</a> implementation of
--   this typeclass will take care of the details of turning your logic
--   program into tree. (If you are not familiar with this approach, then
--   see
--   &lt;http:<i></i>github.com<i>gcross</i>LogicGrowsOnTrees<i>blob</i>master/TUTORIAL.md
--   TUTORIAL.md&gt;.)
--   
--   To use this package, you first write a function that builds a tree
--   (say, by using logic programming); the <a>LogicGrowsOnTrees</a> module
--   provides functionality to assist in this. You may have your function
--   either return a generic <a>MonadPlus</a> or <a>MonadExplorable</a>
--   (where the latter lets you cache expensive intermediate calculations
--   so that they do not have to be performed again if this path is
--   re-explored later), or you may have it return a <a>Tree</a> (or one of
--   its impure friends) directly. You can then test your tree using the
--   visting functions in the <a>LogicGrowsOnTrees</a> module.
--   
--   WARNING: If you need something like state in your tree, then you
--   should stack the state monad (or whatever else you want) <i>on top</i>
--   of <a>Tree</a> rather than below it. The reason for this is that if
--   you stack the monad below <a>TreeT</a>, then your monad will be
--   affected by the order in which the tree is explored, which is almost
--   never what you want, in part because if you are not careful then you
--   will break the assumption made by the checkpointing and
--   parallelization infrastructure that it does not matter in what order
--   the tree is explored or even whether some parts are explored twice or
--   not at all in a given run. If side-effects that are not undone by
--   backtracking is indeed what you want, then you need to make sure that
--   your side-effects do not break this assumption; for example, a monad
--   which memoizes a pure function is perfectly fine. By contrast if you
--   are working within the <a>IO</a> monad and writing results to a
--   database rather than returning them (and assuming that duplicate
--   results would cause problems) then you need to check to make sure you
--   aren't writing the same result twice, such as by using the
--   <a>LogicGrowsOnTrees.Location</a> functionality to identify where you
--   are in the tree so you can query to see if your current location is
--   already listed in the database.
--   
--   If you want to see examples of generating a tree to solve a problem,
--   then see <a>LogicGrowsOnTrees.Examples.MapColoring</a> or
--   <a>LogicGrowsOnTrees.Examples.Queens</a> modules, which have some
--   basic examples of using logic programming to find and/or count the
--   number of solutions to a given map coloring problem and a given
--   n-queens problem. The
--   <a>LogicGrowsOnTrees.Examples.Queens.Advanced</a> module has my own
--   solution to the n-queens problem where I use symmetry breaking to
--   prune the search tree, cutting the runtime by about a factor of three.
--   
--   Once your tree has been debugged, you can start taking advantage of
--   the major features of this package. If you are interested in
--   checkpointing, but not parallelization, then you can use the step
--   functions in the <a>LogicGrowsOnTrees.Checkpoint</a> module to
--   sequentially explore a tree one node at a time, saving the current
--   checkpoint as often as you desire; at any time the exploration can be
--   aborted and resumed later. Most likely, though, you will be interested
--   in using the parallelization infrastructure rather than just the
--   checkpointing infrastructure. The parallelization infrastructure uses
--   a supervisor/worker model, and is designed such that the logic used to
--   keep track of the workers and the current progress is abstracted away
--   into the <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a> module;
--   one then uses one of the provided adapters (or possibly your own) to
--   connect the abstract model to a particular means of running multiple
--   computations in parallel, such as multiple threads, multiple processes
--   on the same machine, multiple processes on a network, and MPI; the
--   first option is included in this package and the others are provided
--   in separate packages. Parallelization is obtained by stealing
--   workloads from workers; specifically, a selected worker will look back
--   at the (non-frozen) choices it has made so far, pick the first one,
--   freeze it (so that it won't backtrack and try the other branch), and
--   then hand the other branch to the supervisor which will then give it
--   to a waiting worker.
--   
--   To use the parallelization infrastructure, you have two choices.
--   First, you can opt to use the adapter directly; the exploration
--   functions provided by the adapter are relatively simple (compared to
--   the alternative to be discussed in a moment) and furthermore, they
--   give you maximum control over the adapter, but the downside is that
--   you will have to re-implement features such as regular checkpointing
--   and forwarding information from the command line to the workers
--   yourself. Second, you can use the infrastructure in
--   <a>LogicGrowsOnTrees.Parallel.Main</a>, which automates most of the
--   process for you, including parsing the command lines, sending
--   information to the workers, determining how many workers (if
--   applicable) to start up, offering the user a command line option to
--   specify whether, where, and how often to checkpoint, etc.; this
--   infrastructure is also completely adapter independent, which means
--   that when switching from one adapter to another all you have to do is
--   change one of the arguments in your call to the main function you are
--   using in <a>LogicGrowsOnTrees.Parallel.Main</a>. The downside is that
--   the call to use this functionality is a bit more complex than the call
--   to use a particular adapter precisely because of its generality.
--   
--   If you want to see examples of using the
--   <a>LogicGrowsOnTrees.Parallel.Main</a> module, check out the example
--   executables in the <tt>examples/</tt> subdirectory of the source
--   distribution.
--   
--   If you are interested in writing a new adapter, then you have couple
--   of options. First, if your adapter can spawn and destroy workers on
--   demand, then you should look at the
--   <a>LogicGrowsOnTrees.Parallel.Common.Workgroup</a> module, as it has
--   infrastructure designed for this case; look at
--   <a>LogicGrowsOnTrees.Parallel.Adapter.Threads</a> for an example of
--   using it. Second, if your adapter does not meet this criterion, then
--   you should look at the
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a> module; your
--   adapter will need to run within the <a>SupervisorMonad</a>, with its
--   own state contained in its own monad below the <a>SupervisorMonad</a>
--   monad in the stack; for an example, look at the
--   <tt>LogicGrowsOnTrees-network</tt> module.
--   
--   NOTE: This package uses the <tt>hslogger</tt> package for logging; if
--   you set the log level to INFO or DEBUG (either by calling the
--   functions in <tt>hslogger</tt> yourself or by using the <tt>-l</tt>
--   command line option if you are using <a>Main</a>) then many status
--   messages will be printed to the screen (or wherever else the log has
--   been configured to be written).
--   
--   The modules are organized as follows:
--   
--   <ul>
--   <li><i><a>LogicGrowsOnTrees</a></i> basic infrastructure for building
--   and exploring trees</li>
--   <li><i><a>LogicGrowsOnTrees.Checkpoint</a></i> infrastructure for
--   creating and stepping through checkpoints</li>
--   <li><i><a>LogicGrowsOnTrees.Examples.MapColoring</a></i> simple
--   examples of computing all possible colorings of a map</li>
--   <li><i><a>LogicGrowsOnTrees.Examples.Queens</a></i> simple examples of
--   solving the n-quees problem</li>
--   <li><i><a>LogicGrowsOnTrees.Examples.Queens.Advanced</a></i> a very
--   complicated example of solving the n-queens problem using symmetry
--   breaking</li>
--   <li><i><a>LogicGrowsOnTrees.Location</a></i> infrastructure for when
--   you want to have knowledge of your current location within a tree</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Adapter.Threads</a></i> the
--   threads adapter</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.Message</a></i> common
--   infrastructure for exchanging messages between worker and
--   supervisor</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.Process</a></i> common
--   infrastricture for the case where a worker has specific communications
--   channels for sending and recieving messages; it might seem like this
--   should always be the case, but it is not true for threads, as the
--   supervisor has direct access to the worker thread, nor for MPI which
--   has its own idiosyncratic communication model</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.RequestQueue</a></i>
--   infrastructure for sending requests to the <a>SupervisorMonad</a> from
--   another thread</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a></i> common
--   infrastructure for keeping track of the state of workers and of the
--   system as a whole, including determining when the run is over</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.Worker</a></i> contains
--   the workhorse of the parallel infrastructure: a thread that steps
--   through a given workload while continuously polling for requests</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Common.Workgroup</a></i> common
--   infrastructure for the case where workers can be added and removed
--   from the system on demand</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.ExplorationMode</a></i> specifies
--   the various modes in which the exploration can be done</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Main</a></i> a unified interface
--   to the various adapters that automates much of the process such as
--   processing the command, forwarding the needed information to the
--   workers, and performing regular checkpointing if requested via a
--   command line argument</li>
--   <li><i><a>LogicGrowsOnTrees.Parallel.Purity</a></i> specifies the
--   purity of the tree being explored</li>
--   <li><i><a>LogicGrowsOnTrees.Path</a></i> infrastructure for working
--   with paths trough the search tree</li>
--   <li><i><a>LogicGrowsOnTrees.Utils.Handle</a></i> a couple of utility
--   functions for exchanging serializable data over handles</li>
--   <li><i><a>LogicGrowsOnTrees.Utils.IntSum</a></i> a monoid that
--   contains an <a>Int</a> to be summed over</li>
--   <li><i><a>LogicGrowsOnTrees.Utils.PerfectTree</a></i> provides
--   algorithms for generating various simple trees</li>
--   <li><i><a>LogicGrowsOnTrees.Utils.WordSum</a></i> a monoid that
--   contains a <a>Word</a> to be summed over</li>
--   <li><i><a>LogicGrowsOnTrees.Utils.Word_</a></i> a newtype wrapper that
--   provides an <a>ArgVal</a> instance for <a>Word</a></li>
--   <li><i><a>LogicGrowsOnTrees.Workload</a></i> infrastructure for
--   working with <a>Workload</a>s</li>
--   </ul>
--   
--   Of the above modules, the ones you will be using most often are
--   <a>LogicGrowsOnTrees</a> (for building trees), one of the adapter
--   modules (such as <a>LogicGrowsOnTrees.Parallel.Adapter.Threads</a>),
--   and possibly <a>LogicGrowsOnTrees.Parallel.Main</a>. If you are
--   counting the number of solutions, then you will also want to look at
--   <a>LogicGrowsOnTrees.Utils.WordSum</a>. Finally, if your program takes
--   a <a>Word</a> as a command line argument or option then you might find
--   the <a>LogicGrowsOnTrees.Utils.Word_</a> module to be useful. The
--   other modules provide lower-level functionality; in particular the
--   <tt>LogicGrowsOnTrees.Parallel.Common.*</tt> modules are primarily
--   geared towards people writing their own adapter.
@package LogicGrowsOnTrees
@version 1.0.0.0.1


-- | This module contains a type that specializes the <tt>Sum</tt>
--   <a>Monoid</a> to <a>Int</a>.
module LogicGrowsOnTrees.Utils.IntSum

-- | An unpacked <a>Int</a> whose <a>Monoid</a> instance is addition.
data IntSum
IntSum :: {-# UNPACK #-} !Int -> IntSum
getIntSum :: IntSum -> {-# UNPACK #-} !Int
instance Typeable IntSum
instance Eq IntSum
instance Show IntSum
instance Serialize IntSum
instance Monoid IntSum


-- | This module contains a couple of utility functions for sending and
--   receiving <a>Serialize</a>-able data over a handle. Because the size
--   of the serialized value can depend on the value being sent, these
--   functions employ a protocol in which first the size of the serialized
--   data is sent as a 64-bit big-endian word, and then the serialized data
--   itself is sent.
module LogicGrowsOnTrees.Utils.Handle

-- | This exception is thrown when the connection has been lost.
data ConnectionLost
ConnectionLost :: ConnectionLost

-- | Replaces EOF <tt>IOException</tt>s with the <a>ConnectionLost</a>
--   exception.
filterEOFExceptions :: IO a -> IO a

-- | Receives a <a>Serialize</a>-able value from a handle.
--   
--   Specifically, this function reads in a 64-bit big-endian word with the
--   size of the raw data to be read, reads that much data in bytes into a
--   <tt>ByteString</tt>, and then deserializes the <tt>ByteString</tt> to
--   produce the resulting value.
--   
--   If the connection has been lost, it throws <a>ConnectionLost</a>.
receive :: Serialize α => Handle -> IO α

-- | Sends a <a>Serialize</a>-able value to a handle.
--   
--   Specifically, this function serializes the given value to a
--   <tt>ByteString</tt>, and then writes the size of the serialized data
--   in bytes as a 64-bit big-endian word followed by the raw data itself.
--   
--   If the connection has been lost, it throws <a>ConnectionLost</a>.
send :: Serialize α => Handle -> α -> IO ()
instance Typeable ConnectionLost
instance Show ConnectionLost
instance Exception ConnectionLost


-- | This module contains types that represent the purity of a tree, which
--   is either pure, impure, or IO (a special case of impure).
module LogicGrowsOnTrees.Parallel.Purity

-- | The purity of a tree, which can be either <a>Pure</a> (for pure trees)
--   or <a>ImpureAtopIO</a> (for impure trees); the latter case is
--   restricted to monads that are instances of <a>MonadIO</a> and for
--   which there exists a way to convert the monad into an IO action.
--   
--   The two kind arguments, <tt>m</tt> and <tt>n</tt>, correspond to
--   respectively the monad in on top of which the <tt>TreeT</tt> monad
--   transformer is stacked and the monad in which the worker will be run.
data Purity (m :: * -> *) (n :: * -> *)
Pure :: Purity Identity IO
ImpureAtopIO :: (forall β. m β -> IO β) -> Purity m m

-- | The purity of trees in the IO monad.
io_purity :: Purity IO IO


-- | This module contains a type that specializes the <tt>Sum</tt>
--   <a>Monoid</a> to <a>Word</a>.
module LogicGrowsOnTrees.Utils.WordSum

-- | An unpacked <a>Word</a> whose <a>Monoid</a> instance is addition.
data WordSum
WordSum :: {-# UNPACK #-} !Word -> WordSum
getWordSum :: WordSum -> {-# UNPACK #-} !Word
instance Typeable WordSum
instance Eq WordSum
instance Show WordSum
instance Serialize WordSum
instance Monoid WordSum


-- | This module provides a temporary <a>ArgVal</a> instance for
--   <a>Word</a> (via a newtype wrapper <a>Word_</a>) until
--   <tt>cmdtheline</tt> releases a new version that includes an
--   <a>ArgVal</a> instance for <a>Word</a> itself.
module LogicGrowsOnTrees.Utils.Word_

-- | Newtype wrapper used to indirectly provide an <a>ArgVal</a> instance
--   for Word.
newtype Word_
Word_ :: Word -> Word_
getWord :: Word_ -> Word
instance Eq Word_
instance Show Word_
instance ArgVal (Maybe Word_)
instance ArgVal Word_


-- | Basic functionality for building and exploring trees.
module LogicGrowsOnTrees

-- | A pure tree, which is what you should normally be using.
type Tree = TreeT Identity

-- | A tree running in the I/O monad, which you should only be using for
--   doing things like reading data from an external file or database that
--   will be constant for the entire run.
type TreeIO = TreeT IO

-- | A tree run in an arbitrary monad.
newtype TreeT m α
TreeT :: ProgramT (TreeTInstruction m) m α -> TreeT m α
unwrapTreeT :: TreeT m α -> ProgramT (TreeTInstruction m) m α

-- | The <a>MonadExplorable</a> class provides caching functionality when
--   exploring a tree, as well as a way to give a worker a chance to
--   process any pending requests; at minimum <a>cacheMaybe</a> needs to be
--   defined.
class MonadPlus m => MonadExplorable m where cache = cacheMaybe . Just cacheGuard = cacheMaybe . (\ x -> if x then Just () else Nothing) processPendingRequests = return ()
cache :: (MonadExplorable m, Serialize x) => x -> m x
cacheGuard :: MonadExplorable m => Bool -> m ()
cacheMaybe :: (MonadExplorable m, Serialize x) => Maybe x -> m x
processPendingRequests :: MonadExplorable m => m ()

-- | This class is like <a>MonadExplorable</a>, but it is designed to work
--   with monad stacks; at minimum <a>runAndCacheMaybe</a> needs to be
--   defined.
class (MonadPlus m, Monad (NestedMonad m)) => MonadExplorableTrans m where type family NestedMonad m :: * -> * runAndCache = runAndCacheMaybe . liftM Just runAndCacheGuard = runAndCacheMaybe . liftM (\ x -> if x then Just () else Nothing)
runAndCache :: (MonadExplorableTrans m, Serialize x) => (NestedMonad m) x -> m x
runAndCacheGuard :: MonadExplorableTrans m => (NestedMonad m) Bool -> m ()
runAndCacheMaybe :: (MonadExplorableTrans m, Serialize x) => (NestedMonad m) (Maybe x) -> m x

-- | Explores all the nodes in a pure tree and sums over all the results in
--   the leaves.
exploreTree :: Monoid α => Tree α -> α

-- | Explores all the nodes in an impure tree and sums over all the results
--   in the leaves.
exploreTreeT :: (Monad m, Monoid α) => TreeT m α -> m α

-- | Explores a tree for its side-effects, ignoring all results.
exploreTreeTAndIgnoreResults :: Monad m => TreeT m α -> m ()

-- | Explores all the nodes in a tree until a result (i.e., a leaf) has
--   been found; if a result has been found then it is returned wrapped in
--   <a>Just</a>, otherwise <a>Nothing</a> is returned.
exploreTreeUntilFirst :: Tree α -> Maybe α

-- | Same as <a>exploreTreeUntilFirst</a>, but taking an impure tree
--   instead of pure one.
exploreTreeTUntilFirst :: Monad m => TreeT m α -> m (Maybe α)

-- | Explores all the nodes in a tree, summing all encountered results
--   (i.e., in the leaves) until the current partial sum satisfies the
--   condition provided by the first function. The returned value is a pair
--   where the first component is all of the results that were found during
--   the exploration and the second component is <a>True</a> if the
--   exploration terminated early due to the condition being met and
--   <a>False</a> otherwise.
--   
--   NOTE: The condition function is assumed to have two properties: first,
--   it is assumed to return <a>False</a> for <a>mempty</a>, and second, it
--   is assumed that if it returns <a>True</a> for <tt>x</tt> then it also
--   returns <a>True</a> for <tt>mappend x y</tt> and <tt>mappend y x</tt>
--   for all values <tt>y</tt>. The reason for this is that the condition
--   function is used to indicate when enough results have been found, and
--   so it should not be <a>True</a> for <a>mempty</a> as nothing has been
--   found and if it is <a>True</a> for <tt>x</tt> then it should not be
--   <a>False</a> for the sum of <tt>y</tt> with <tt>x</tt> as this would
--   mean that having <i>more</i> than enough results is no longer having
--   enough results.
exploreTreeUntilFound :: Monoid α => (α -> Bool) -> Tree α -> (α, Bool)

-- | Same as <a>exploreTreeUntilFound</a>, but taking an impure tree
--   instead of a pure tree.
exploreTreeTUntilFound :: (Monad m, Monoid α) => (α -> Bool) -> TreeT m α -> m (α, Bool)

-- | Returns a tree (or some other <a>MonadPlus</a>) with all of the
--   results in the input list.
allFrom :: (Foldable t, Functor t, MonadPlus m) => t α -> m α

-- | Returns an optimally balanced tree (or some other <a>MonadPlus</a>)
--   that generates all of the elements in the given (inclusive) range; if
--   the lower bound is greater than the upper bound it returns
--   <a>mzero</a>.
between :: (Enum n, MonadPlus m) => n -> n -> m n

-- | This function lets you take a pure tree and transform it into a tree
--   with an arbitrary base monad.
endowTree :: Monad m => Tree α -> TreeT m α

-- | The core of the implementation of <a>Tree</a> is mostly contained in
--   this type, which provides a list of primitive instructions for trees:
--   <a>Cache</a>, which caches a value, <a>Choice</a>, which signals a
--   branch with two choices, <a>Null</a>, which indicates that there are
--   no more results, and <a>ProcessPendingRequests</a>, which signals that
--   a break should be taken from exploration to process any pending
--   requests (only meant to be used in exceptional cases).
data TreeTInstruction m α
Cache :: m (Maybe α) -> TreeTInstruction m α
Choice :: TreeT m α -> TreeT m α -> TreeTInstruction m α
Null :: TreeTInstruction m α
ProcessPendingRequests :: TreeTInstruction m ()

-- | This is just a convenient alias for working with pure trees.
type TreeInstruction = TreeTInstruction Identity
instance Monad m => Applicative (TreeT m)
instance Monad m => Functor (TreeT m)
instance Monad m => Monad (TreeT m)
instance MonadIO m => MonadIO (TreeT m)
instance Show α => Show (Tree α)
instance Monad m => Monoid (TreeT m α)
instance MonadTrans TreeT
instance Monad m => MonadExplorableTrans (TreeT m)
instance Monad m => MonadExplorable (TreeT m)
instance Monad m => MonadExplorableTrans (MaybeT m)
instance Monad m => MonadExplorable (MaybeT m)
instance MonadExplorable Maybe
instance Monad m => MonadExplorableTrans (ListT m)
instance Monad m => MonadExplorable (ListT m)
instance MonadExplorable []
instance Monad m => MonadPlus (TreeT m)
instance Eq α => Eq (Tree α)
instance Monad m => Alternative (TreeT m)


-- | This modules contains functionality relating to paths through trees.
module LogicGrowsOnTrees.Path

-- | A choice at a branch point to take either the left branch or the right
--   branch.
data BranchChoice
LeftBranch :: BranchChoice
RightBranch :: BranchChoice

-- | A step in a path through a tree, which can either pass through a point
--   with a cached result or take a choice to go left or right at a branch
--   point.
data Step

-- | Step through a cache point
CacheStep :: ByteString -> Step

-- | Step through a choice point
ChoiceStep :: BranchChoice -> Step

-- | A sequence of <a>Step</a>s.
type Path = Seq Step

-- | Returns the opposite of the given branch choice.
oppositeBranchChoiceOf :: BranchChoice -> BranchChoice

-- | Follows a <a>Path</a> through a <a>Tree</a> to a particular subtree;
--   the main use case of this function is for a processor which has been
--   given a particular subtree as its workload to zoom in on that subtree.
--   The way this function works is as follows: as long as the remaining
--   path is non-empty, it explores the <a>Tree</a> until it encounters
--   either a cache point or a choice point; in the former case the path
--   supplies the cached value in the <a>CacheStep</a> constructor, and in
--   the latter case the path supplies the branch to take in the
--   <a>ChoiceStep</a> constructor; when the remaining path is empty then
--   the resulting <a>Tree</a> is returned.
--   
--   WARNING: This function is <i>not</i> valid for all inputs; it makes
--   the assumption that the given <a>Path</a> has been derived from the
--   given <a>Tree</a> so that the path will always encountered choice
--   points exactly when the tree does and likewise for cache points.
--   Furthermore, the path must not run out before the tree hits a leaf. If
--   any of these conditions is violated, a <a>WalkError</a> exception will
--   be thrown; in fact, you should hope than exception is thrown because
--   it will let you know that there is a bug your code as the alternative
--   is that you accidently give it a path that is not derived from the
--   given tree but which coincidentally matches it which means that it
--   will silently return a nonsensical result. Having said all that, you
--   should almost never need to worry about this possibility in practice
--   because there will normally be only one tree in use at a time and all
--   paths in use will have come from that tree.
sendTreeDownPath :: Path -> Tree α -> Tree α

-- | Like <a>sendTreeDownPath</a>, but for impure trees.
sendTreeTDownPath :: Monad m => Path -> TreeT m α -> m (TreeT m α)

-- | This exception is thrown whenever a <a>Tree</a> is sent down a path
--   which is incompatible with it.
data WalkError

-- | Indicates that a path is too long for a given tree --- that is, the
--   walk hit a leaf (or a null) before the end of the path was reached.
TreeEndedBeforeEndOfWalk :: WalkError

-- | Indicates that a choice step in a path coincided with a cache point in
--   a tree, or vice versa.
PastTreeIsInconsistentWithPresentTree :: WalkError
instance Serialize Step
instance Eq Step
instance Ord Step
instance Show Step
instance Serialize BranchChoice
instance Typeable WalkError
instance Eq WalkError
instance Show WalkError
instance Eq BranchChoice
instance Ord BranchChoice
instance Read BranchChoice
instance Show BranchChoice
instance Exception WalkError


-- | This module contains the infrastructure used to maintain a checkpoint
--   during a tree exploration.
module LogicGrowsOnTrees.Checkpoint

-- | Information about the parts of a tree that have been explored.
data Checkpoint
CachePoint :: ByteString -> Checkpoint -> Checkpoint
ChoicePoint :: Checkpoint -> Checkpoint -> Checkpoint
Explored :: Checkpoint
Unexplored :: Checkpoint

-- | Information about both the current checkpoint and the results we have
--   gathered so far.
data Progress α
Progress :: Checkpoint -> α -> Progress α
progressCheckpoint :: Progress α -> Checkpoint
progressResult :: Progress α -> α

-- | A zipper that allows us to zoom in on a particular point in the
--   checkpoint.
type CheckpointCursor = Seq CheckpointDifferential

-- | The derivative of <a>Checkpoint</a>, used to implement the zipper type
--   <a>CheckpointCursor</a>.
data CheckpointDifferential
CachePointD :: ByteString -> CheckpointDifferential
ChoicePointD :: BranchChoice -> Checkpoint -> CheckpointDifferential

-- | Like <a>CheckpointCursor</a>, but each step keeps track of the subtree
--   for the alternative branch in case we backtrack to it.
type Context m α = Seq (ContextStep m α)

-- | Like <a>CheckpointDifferential</a>, but left branches include the
--   subtree for the right branch; the right branches do not need this
--   information because we always explore the left branch first.
data ContextStep m α
CacheContextStep :: ByteString -> ContextStep m α
LeftBranchContextStep :: Checkpoint -> (TreeT m α) -> ContextStep m α
RightBranchContextStep :: ContextStep m α

-- | The current state of the exploration of a tree starting from a
--   checkpoint.
data ExplorationTState m α
ExplorationTState :: !(Context m α) -> !Checkpoint -> !(TreeT m α) -> ExplorationTState m α
explorationStateContext :: ExplorationTState m α -> !(Context m α)
explorationStateCheckpoint :: ExplorationTState m α -> !Checkpoint
explorationStateTree :: ExplorationTState m α -> !(TreeT m α)

-- | An alias for <a>ExplorationTState</a> in a pure setting.
type ExplorationState = ExplorationTState Identity

-- | Constructs the initial <a>ExplorationTState</a> for the given tree.
initialExplorationState :: Checkpoint -> TreeT m α -> ExplorationTState m α

-- | This exception is thrown when one attempts to merge checkpoints that
--   disagree with each other; this will never happen as long as you only
--   merge checkpoints that came from the same tree, so if you get this
--   exception then there is almost certainly a bug in your code.
data InconsistentCheckpoints
InconsistentCheckpoints :: Checkpoint -> Checkpoint -> InconsistentCheckpoints

-- | Constructs a full checkpoint given a (context) checkpoint zipper with
--   a hole at your current location and the subcheckpoint at your
--   location.
checkpointFromContext :: Context m α -> Checkpoint -> Checkpoint

-- | Constructs a full checkpoint given a (cursor) checkpoint zipper with a
--   hole at your current location and the subcheckpoint at your location.
checkpointFromCursor :: CheckpointCursor -> Checkpoint -> Checkpoint

-- | Computes the current checkpoint given the state of an exploration.
checkpointFromExplorationState :: ExplorationTState m α -> Checkpoint

-- | Incrementally builds up a full checkpoint given a sequence
--   corresponding to some cursor at a particular location of the full
--   checkpoint and the subcheckpoint to splice in at that location.
--   
--   The main reason that you should use this function is that, as it
--   builds up the full checkpoint, it makes some important simplifications
--   via. <a>simplifyCheckpointRoot</a>, such as replacing <tt>ChoicePoint
--   Explored Explored</tt> with <tt>Explored</tt>, which both shrinks the
--   size of the checkpoint as well as making it <i>much</i> easier to
--   determine if it is equivalent to <a>Explored</a>.
checkpointFromSequence :: (α -> (Checkpoint -> Checkpoint)) -> Seq α -> Checkpoint -> Checkpoint

-- | Constructs a full checkpoint given the path to where you are currently
--   searching and the subcheckpoint at your location, assuming that we
--   have no knowledge of anything outside our location (which is indicated
--   by marking it as <a>Unexplored</a>).
checkpointFromInitialPath :: Path -> Checkpoint -> Checkpoint

-- | Constructs a full checkpoint given the path to where you are currently
--   located, assuming that the current location is <a>Unexplored</a> and
--   everything outside of our location has been fully explored already.
checkpointFromUnexploredPath :: Path -> Checkpoint

-- | Simplifies the root of the checkpoint by replacing
--   
--   <ul>
--   <li><tt>Choicepoint Unexplored Unexplored</tt> with
--   <tt>Unexplored</tt>;</li>
--   <li><tt>Choicepoint Explored Explored</tt> with <tt>Explored</tt>;
--   and</li>
--   <li><tt>CachePoint _ Explored</tt> with <tt>Explored</tt>.</li>
--   </ul>
simplifyCheckpointRoot :: Checkpoint -> Checkpoint

-- | Applies <a>simplifyCheckpointRoot</a> everywhere in the checkpoint
--   starting from the bottom up.
simplifyCheckpoint :: Checkpoint -> Checkpoint

-- | Computes the path to the current location in the checkpoint as given
--   by the context. (Note that this is a lossy conversation because the
--   resulting path does not contain any information about the branches not
--   taken.)
pathFromContext :: Context m α -> Path

-- | Computes the path to the current location in the checkpoint as given
--   by the cursor. (Note that this is a lossy conversation because the
--   resulting path does not contain any information about the branches not
--   taken.)
pathFromCursor :: CheckpointCursor -> Path

-- | Converts a context step to a path step by throwing away information
--   about the alternative branch (if present).
pathStepFromContextStep :: ContextStep m α -> Step

-- | Converts a cursor differential to a path step by throwing away
--   information about the alternative branch (if present).
pathStepFromCursorDifferential :: CheckpointDifferential -> Step

-- | Inverts a checkpoint so that unexplored areas become explored areas
--   and vice versa. This function satisfies the law that if you sum the
--   result of exploring the tree with the original checkpoint and the
--   result of summing the tree with the inverted checkpoint then (assuming
--   the result monoid commutes) you will get the same result as exploring
--   the entire tree. That is to say,
--   
--   <pre>
--   exploreTreeStartingFromCheckpoint checkpoint tree
--   &lt;&gt;
--   exploreTreeStartingFromCheckpoint (invertCheckpoint checkpoint) tree
--   ==
--   exploreTree tree
--   </pre>
invertCheckpoint :: Checkpoint -> Checkpoint

-- | Given the current state of exploration, perform an additional step of
--   exploration, returning any solution that was found and the next state
--   of the exploration --- which will be <a>Nothing</a> if the entire tree
--   has been explored.
stepThroughTreeStartingFromCheckpoint :: ExplorationState α -> (Maybe α, Maybe (ExplorationState α))

-- | Like <a>stepThroughTreeStartingFromCheckpoint</a>, but for an impure
--   tree.
stepThroughTreeTStartingFromCheckpoint :: Monad m => ExplorationTState m α -> m (Maybe α, Maybe (ExplorationTState m α))

-- | Explores the remaining nodes in a pure tree, starting from the given
--   checkpoint, and sums over all the results in the leaves.
exploreTreeStartingFromCheckpoint :: Monoid α => Checkpoint -> Tree α -> α

-- | Explores the remaining nodes in an impure tree, starting from the
--   given checkpoint, and sums over all the results in the leaves.
exploreTreeTStartingFromCheckpoint :: (Monad m, Monoid α) => Checkpoint -> TreeT m α -> m α

-- | Explores all the remaining nodes in a pure tree, starting from the
--   given checkpoint, until a result (i.e., a leaf) has been found; if a
--   result has been found then it is returned wrapped in <a>Just</a>,
--   otherwise <a>Nothing</a> is returned.
exploreTreeUntilFirstStartingFromCheckpoint :: Checkpoint -> Tree α -> Maybe α

-- | Same as <a>exploreTreeUntilFirstStartingFromCheckpoint</a>, but for an
--   impure tree.
exploreTreeTUntilFirstStartingFromCheckpoint :: Monad m => Checkpoint -> TreeT m α -> m (Maybe α)

-- | Explores all the remaining nodes in a tree, starting from the given
--   checkpoint and summing all results encountered (i.e., in the leaves)
--   until the current partial sum satisfies the condition provided by the
--   first parameter.
--   
--   See <a>exploreTreeUntilFound</a> for more details.
exploreTreeUntilFoundStartingFromCheckpoint :: Monoid α => (α -> Bool) -> Checkpoint -> Tree α -> (α, Bool)

-- | Same as <a>exploreTreeUntilFoundStartingFromCheckpoint</a>, but for an
--   impure tree.
exploreTreeTUntilFoundStartingFromCheckpoint :: (Monad m, Monoid α) => (α -> Bool) -> Checkpoint -> TreeT m α -> m (α, Bool)
instance Eq CheckpointDifferential
instance Read CheckpointDifferential
instance Show CheckpointDifferential
instance Show (ContextStep m α)
instance Functor Progress
instance Serialize α_1627472785 => Serialize (Progress α_1627472785)
instance Monoid α_1627472785 => Monoid (Progress α_1627472785)
instance Eq α => Eq (Progress α)
instance Show α => Show (Progress α)
instance Monoid Checkpoint
instance Serialize Checkpoint
instance Typeable InconsistentCheckpoints
instance Eq Checkpoint
instance Ord Checkpoint
instance Read Checkpoint
instance Show Checkpoint
instance Eq InconsistentCheckpoints
instance Show InconsistentCheckpoints
instance Exception InconsistentCheckpoints


-- | There are several tasks for which a user may wish to use
--   LogicGrowsOnTrees, such as gathering up all the results in a tree or
--   stopping as soon as the first result is found. Because almost all of
--   the infrastructure required for these different modes is the same,
--   rather than creating a different system for each mode we instead
--   re-use the same system but pass around a mode parameter that dictates
--   its behavior at various points as well as some of the types in the
--   system.
--   
--   <a>ExplorationMode</a> is defined using a GADT where each constructor
--   has a different argument for <a>ExplorationMode</a>'s type parameter;
--   this was done so that type families can be used to specialized types
--   depending on the constructor.
module LogicGrowsOnTrees.Parallel.ExplorationMode

-- | A type indicating the mode of the exploration. Note that this is a
--   GADT for which the type parameter is unique to each constructor in
--   order to allow associated types to be specialized based on the value.
--   
--   Unfortunately Haddock does not seem to support documenting the
--   constructors of a GADT, so the documentation for each constructor is
--   located at the type it is tagged with, all of which are defined after
--   the <a>ExplorationMode</a> type.
data ExplorationMode exploration_mode
AllMode :: ExplorationMode (AllMode result)
FirstMode :: ExplorationMode (FirstMode result)
FoundModeUsingPull :: (result -> Bool) -> ExplorationMode (FoundModeUsingPull result)
FoundModeUsingPush :: (result -> Bool) -> ExplorationMode (FoundModeUsingPush result)

-- | Explore the entire tree and sum the results in all of the leaves.
data AllMode result

-- | Explore the tree until a result is found, and if so then stop.
data FirstMode result

-- | Explore the tree, summing the results, until a condition has been met;
--   <tt>Pull</tt> means that each worker's results will be kept and summed
--   locally until a request for them has been received from the
--   supervisor, which means that there might be a period of time where the
--   collectively found results meet the condition but the system is
--   unaware of this as they are scattered amongst the workers.
--   
--   NOTE: If you use this mode then you are responsible for ensuring that
--   a global progress update happens on a regular basis in order to pull
--   the results in from the workers and check to see if the condition has
--   been met; if you do not do this then the run will not terminate until
--   the tree has been fully explored.
data FoundModeUsingPull result

-- | Same as <a>FoundModeUsingPull</a>, but pushes each result to the
--   supervisor as it is found rather than summing them in the worker until
--   they are requested by the supervisor, which guarantees that the system
--   will recognize when the condition has been met as soon as final result
--   needed was found but has the downside that if there are a large number
--   of results needed then sending each one could be much more costly then
--   summing them locally and sending the current total on a regular basis
--   to the supervisor.
data FoundModeUsingPush result

-- | This class indicates that a monad has information about the current
--   exploration mode tag type that can be extracted from it.
class HasExplorationMode (monad :: * -> *) where type family ExplorationModeFor monad :: *

-- | The result type of the tree, i.e. the type of values at the leaves.

-- | The type of progress, which keeps track of how much of the tree has
--   already been explored.

-- | The type of the final result of exploring the tree.

-- | The type of the intermediate value being maintained internally by the
--   worker.

-- | The progress type returned by a worker that has finished.

-- | Extracts the <a>Checkpoint</a> component from a progress value.
checkpointFromIntermediateProgress :: ExplorationMode exploration_mode -> ProgressFor exploration_mode -> Checkpoint

-- | The initial progress at the start of the exploration.
initialProgress :: ExplorationMode exploration_mode -> ProgressFor exploration_mode

-- | The initial intermediate value for the worker.
initialWorkerIntermediateValue :: ExplorationMode exploration_mode -> WorkerIntermediateValueFor exploration_mode


-- | This module contains examples of logic programs that generate all the
--   valid colorings of a given (geographical) map.
module LogicGrowsOnTrees.Examples.MapColoring

-- | Generate all valid map colorings.
coloringSolutions :: MonadPlus m => Word -> Word -> (Word -> Word -> Bool) -> m [(Word, Word)]

-- | Generate all <i>unique</i> valid map colorings. That is, exactly one
--   coloring will be generated from each class of colorings that are
--   equivalent under a permutation of colors.
coloringUniqueSolutions :: MonadPlus m => Word -> Word -> (Word -> Word -> Bool) -> m [(Word, Word)]


-- | This module contains a heavily optimized solver for the n-queens
--   problems. Specifically, it uses the following tricks:
--   
--   <ul>
--   <li>symmetry breaking to prune redundant solutions</li>
--   <li>unpacked datatypes instead of multiple arguments</li>
--   <li>optimized <a>getOpenings</a></li>
--   <li>C code for the inner-most loop</li>
--   <li><tt>INLINE</tt>s in many places in order to create optimized
--   specializations of the generic functions</li>
--   </ul>
--   
--   Benchmarks were used to determine that all of these tricks resulted in
--   performance improvements using GHC 7.4.3.
module LogicGrowsOnTrees.Examples.Queens.Advanced

-- | The possible board symmetries.
data NQueensSymmetry

-- | the board has no symmetries at all
NoSymmetries :: NQueensSymmetry

-- | the board is symmetric under 180 degree rotations
Rotate180Only :: NQueensSymmetry

-- | the board is symmetric under all rotations
AllRotations :: NQueensSymmetry

-- | the board is symmetric under all rotations and reflections
AllSymmetries :: NQueensSymmetry

-- | Type alias for a solution, which takes the form of a list of
--   coordinates.
type NQueensSolution = [(Word, Word)]

-- | Type alias for a list of solutions.
type NQueensSolutions = [NQueensSolution]

-- | Represents a position and bit at that position.
data PositionAndBit

-- | Like <a>PositionAndBit</a>, but also including the same for the
--   reflection of the position (i.e., one less than the board size minus
--   the position).
data PositionAndBitWithReflection

-- | Interface to the main algorithm; note that α and β need to be
--   <a>Typeable</a> because of an optimization used in the C part of the
--   code. This function takes functions for its first two operators that
--   operate on partial solutions so that the same algorithm can be used
--   both for generating solutions and counting them; the advantage of this
--   approach is that it is much easier to find problems in the generated
--   solution than it is in their count, so we can test it by looking for
--   problems in the generated solutions, and when we are assured that it
--   works we can trust it to obtain the correct counts.
nqueensGeneric :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (Word -> NQueensSymmetry -> α -> m β) -> α -> Word -> m β

-- | Break the reflection symmetry.
nqueensStart :: MonadPlus m => ([(Word, Word)] -> α -> α) -> (α -> NQueensBreak90State -> m β) -> (α -> NQueensBreak180State -> m β) -> (α -> Int -> NQueensSearchState -> m β) -> α -> Word -> m β

-- | The state type while the 90-degree rotational symmetry is being
--   broken.
data NQueensBreak90State
NQueensBreak90State :: {-# UNPACK #-} !Word -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> NQueensBreak90State
b90_number_of_queens_remaining :: NQueensBreak90State -> {-# UNPACK #-} !Word
b90_window_start :: NQueensBreak90State -> {-# UNPACK #-} !Int
b90_window_size :: NQueensBreak90State -> {-# UNPACK #-} !Int
b90_occupied_rows_and_columns :: NQueensBreak90State -> {-# UNPACK #-} !Word64
b90_occupied_negative_diagonals :: NQueensBreak90State -> {-# UNPACK #-} !Word64
b90_occupied_positive_diagonals :: NQueensBreak90State -> {-# UNPACK #-} !Word64

-- | Break the 90-degree rotational symmetry at the current layer.
nqueensBreak90 :: MonadPlus m => ([(Word, Word)] -> α -> α) -> (α -> m β) -> (α -> NQueensBreak90State -> m β) -> (α -> NQueensBreak180State -> m β) -> (α -> Int -> NQueensSearchState -> m β) -> α -> NQueensBreak90State -> m β

-- | The state while the 180-degree rotational symmetry is being broken.
data NQueensBreak180State
NQueensBreak180State :: {-# UNPACK #-} !Word -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> NQueensBreak180State
b180_number_of_queens_remaining :: NQueensBreak180State -> {-# UNPACK #-} !Word
b180_window_start :: NQueensBreak180State -> {-# UNPACK #-} !Int
b180_window_size :: NQueensBreak180State -> {-# UNPACK #-} !Int
b180_occupied_rows :: NQueensBreak180State -> {-# UNPACK #-} !Word64
b180_occupied_columns :: NQueensBreak180State -> {-# UNPACK #-} !Word64
b180_occupied_negative_diagonals :: NQueensBreak180State -> {-# UNPACK #-} !Word64
b180_occupied_positive_diagonals :: NQueensBreak180State -> {-# UNPACK #-} !Word64
b180_occupied_right_positive_diagonals :: NQueensBreak180State -> {-# UNPACK #-} !Word64

-- | Break the 180-degree rotational symmetry at the current layer.
nqueensBreak180 :: MonadPlus m => ([(Word, Word)] -> α -> α) -> (α -> m β) -> (α -> NQueensBreak180State -> m β) -> (α -> Int -> NQueensSearchState -> m β) -> α -> NQueensBreak180State -> m β

-- | The state during the brute-force search.
data NQueensSearchState
NQueensSearchState :: {-# UNPACK #-} !Word -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> NQueensSearchState
s_number_of_queens_remaining :: NQueensSearchState -> {-# UNPACK #-} !Word
s_row :: NQueensSearchState -> {-# UNPACK #-} !Int
s_occupied_rows :: NQueensSearchState -> {-# UNPACK #-} !Word64
s_occupied_columns :: NQueensSearchState -> {-# UNPACK #-} !Word64
s_occupied_negative_diagonals :: NQueensSearchState -> {-# UNPACK #-} !Word64
s_occupied_positive_diagonals :: NQueensSearchState -> {-# UNPACK #-} !Word64

-- | Using brute-force to find placements for all of the remaining queens.
nqueensSearch :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (α -> m β) -> α -> Int -> NQueensSearchState -> m β

-- | Interface for directly using the brute-force search approach
nqueensBruteForceGeneric :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (α -> m β) -> α -> Word -> m β

-- | Generates the solutions to the n-queens problem with the given board
--   size.
nqueensBruteForceSolutions :: MonadPlus m => Word -> m NQueensSolution

-- | Generates the solution count to the n-queens problem with the given
--   board size.
nqueensBruteForceCount :: MonadPlus m => Word -> m WordSum

-- | C code that performs a brute-force search for the remaining queens.
--   The last three arguments are allowed to be NULL, in which case they
--   are ignored and only the count is returned.
c_LogicGrowsOnTrees_Queens_count_solutions :: CUInt -> CUInt -> CUInt -> Word64 -> Word64 -> Word64 -> Word64 -> FunPtr (CUInt -> CUInt -> IO ()) -> FunPtr (IO ()) -> FunPtr (IO ()) -> IO CUInt

-- | wrapper stub for the push value function pointer
mkPushValue :: (CUInt -> CUInt -> IO ()) -> IO (FunPtr (CUInt -> CUInt -> IO ()))

-- | wrapper stub for the pop value function pointer
mkPopValue :: IO () -> IO (FunPtr (IO ()))

-- | wrapper stub for the finalize value function pointer
mkFinalizeValue :: IO () -> IO (FunPtr (IO ()))

-- | Calls C code to perform a brute-force search for the remaining queens.
--   The types α and β must be <a>Typeable</a> because this function
--   actually optimizes for the case where only counting is being done by
--   providing null values for the function pointer inputs.
nqueensCSearch :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (α -> m β) -> α -> Int -> Int -> NQueensSearchState -> m β

-- | Interface for directly using the C search approach
nqueensCGeneric :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (α -> m β) -> α -> Word -> m β

-- | Generates the solutions to the n-queens problem with the given board
--   size.
nqueensCSolutions :: MonadPlus m => Word -> m NQueensSolution

-- | Generates the solution count to the n-queens problem with the given
--   board size.
nqueensCCount :: MonadPlus m => Word -> m WordSum

-- | Computes all rotations and reflections of the given solution.
allRotationsAndReflectionsOf :: Word -> NQueensSolution -> NQueensSolutions

-- | Computes all rotations of the given solution.
allRotationsOf :: Word -> NQueensSolution -> NQueensSolutions

-- | Converts coordinates of type <a>Int</a> to type <a>Word</a>.
convertSolutionToWord :: [(Int, Int)] -> [(Word, Word)]

-- | Extracts the outermost layers of a solution.
extractExteriorFromSolution :: Word -> Word -> NQueensSolution -> NQueensSolution

-- | Get the openings for a queen
getOpenings :: MonadPlus m => Int -> Word64 -> m PositionAndBit

-- | Get the symmetric openings for a queen
getSymmetricOpenings :: MonadPlus m => Int -> Word64 -> m PositionAndBitWithReflection

-- | Checks if a solution has reflection symmetry.
hasReflectionSymmetry :: Word -> NQueensSolution -> Bool

-- | Checks if a solution has 90-degree rotation symmetry.
hasRotate90Symmetry :: Word -> NQueensSolution -> Bool

-- | Checks if a solution has 180-degree rotation symmetry.
hasRotate180Symmetry :: Word -> NQueensSolution -> Bool

-- | Returns the number of equivalent solutions for a solution with a given
--   symmetry.
multiplicityForSymmetry :: NQueensSymmetry -> Word

-- | Gets all of the equivalent solutions with an equivalent symmetry.
multiplySolution :: MonadPlus m => Word -> NQueensSymmetry -> NQueensSolution -> m NQueensSolution

-- | Reflects the bits in a number so that each bit at position i is moved
--   to position -i (i.e., what you get when you take a bit at position 0
--   and rotate it i positions to the right)
reflectBits :: Word64 -> Word64

-- | Reflects the columns of a solution
reflectSolution :: Word -> NQueensSolution -> NQueensSolution

-- | Rotate a solution left by 180 degrees.
rotate180 :: Word -> NQueensSolution -> NQueensSolution

-- | Rotate a solution left by 90 degrees.
rotateLeft :: Word -> NQueensSolution -> NQueensSolution

-- | Rotate a solution right by 90 degrees.
rotateRight :: Word -> NQueensSolution -> NQueensSolution

-- | Computes the symmetry class of the given solution
symmetryOf :: Word -> NQueensSolution -> NQueensSymmetry
instance Eq NQueensSymmetry
instance Ord NQueensSymmetry
instance Read NQueensSymmetry
instance Show NQueensSymmetry


-- | This module contains examples of logic programs that generate
--   solutions to the n-queens problem, which is the problem of finding
--   ways to put n queens on an n x n chessboard in such a way that they do
--   not conflict. Solutions of the n-queens problem take the form of a
--   list of n coordinates such that no coordinates have overlapping rows,
--   columns, or diagonals (as these are the directions in which a queen
--   can attack).
module LogicGrowsOnTrees.Examples.Queens

-- | A table with the correct number of solutions for board sizes ranging
--   from 1 to <a>nqueens_maximum_size</a>.
--   
--   This data was pulled from
--   <a>http://queens.inf.tu-dresden.de/?n=f&amp;l=en</a>.
nqueens_correct_counts :: IntMap Word

-- | The maximum board size in <a>nqueens_correct_counts</a>. In a 64-bit
--   environment this value is equal to the largest board size for which we
--   know the number of solutions, which is 26. In a 32-bit environment
--   this value is equal to the largest board size such that the number of
--   solutions fits within a 32-bit (unsigned) integer (i.e., the range of
--   <a>Word</a>), which is 18.
nqueens_maximum_size :: Int

-- | A <i>partial function</i> that returns the number of solutions for the
--   given input board size; this should only be used when you are sure
--   that the input is not greater than <a>nqueens_maximum_size</a>.
nqueensCorrectCount :: Word -> Word

-- | Generate solutions to the n-queens problem using <a>IntSet</a>s.
nqueensUsingSetsSolutions :: MonadPlus m => Word -> m NQueensSolution

-- | Generates the solution count to the n-queens problem with the given
--   board size; you need to sum over all these counts to obtain the total,
--   which is done by the <a>exploreTree</a> (and related) functions.
nqueensUsingSetsCount :: MonadPlus m => Word -> m WordSum

-- | Generate solutions to the n-queens problem using bitwise-operations.
nqueensUsingBitsSolutions :: MonadPlus m => Word -> m NQueensSolution

-- | Generates the solution count to the n-queens problem with the given
--   board size; you need to sum over all these counts to obtain the total,
--   which is done by the <a>exploreTree</a> (and related) functions.
nqueensUsingBitsCount :: MonadPlus m => Word -> m WordSum

-- | Interface to the main algorithm; note that α and β need to be
--   <a>Typeable</a> because of an optimization used in the C part of the
--   code. This function takes functions for its first two operators that
--   operate on partial solutions so that the same algorithm can be used
--   both for generating solutions and counting them; the advantage of this
--   approach is that it is much easier to find problems in the generated
--   solution than it is in their count, so we can test it by looking for
--   problems in the generated solutions, and when we are assured that it
--   works we can trust it to obtain the correct counts.
nqueensGeneric :: (MonadPlus m, Typeable α, Typeable β) => ([(Word, Word)] -> α -> α) -> (Word -> NQueensSymmetry -> α -> m β) -> α -> Word -> m β

-- | Generates the solutions to the n-queens problem with the given board
--   size.
nqueensSolutions :: MonadPlus m => Word -> m NQueensSolution

-- | Generates the solution count to the n-queens problem with the given
--   board size; you need to sum over all these counts to obtain the total,
--   which is done by the <a>exploreTree</a> (and related) functions.
nqueensCount :: MonadPlus m => Word -> m WordSum

-- | This newtype wrapper is used to provide an ArgVal instance that ensure
--   that an input board size is between 1 and <a>nqueens_maximum_size</a>.
--   In general you do not need to use this type directly but instead can
--   use the function <a>makeBoardSizeTermAtPosition</a>.
newtype BoardSize
BoardSize :: Word -> BoardSize
getBoardSize :: BoardSize -> Word

-- | This constructs a term for the <tt>cmdtheline</tt> command line parser
--   that expects a valid board size (i.e., a number between 1 and
--   <a>nqueens_maximum_size</a>) at the given positional argument.
makeBoardSizeTermAtPosition :: Int -> Term Word
instance ArgVal (Maybe BoardSize)
instance ArgVal BoardSize


-- | This module contains infrastructure for working with <a>Location</a>s,
--   which indicate a location within a tree but, unlike <a>Path</a>,
--   without the cached values.
module LogicGrowsOnTrees.Location

-- | The class <a>MonadLocatable</a> allows you to get your current
--   location within a tree.
class MonadPlus m => MonadLocatable m
getLocation :: MonadLocatable m => m Location

-- | A <a>Location</a> identifies a location in a tree; unlike <a>Path</a>
--   it only contains information about the list of branches that have been
--   taken, and not information about the cached values encounted along the
--   way.
data Location

-- | A <a>Solution</a> is a result tagged with the location of the leaf at
--   which it was found.
data Solution α
Solution :: Location -> α -> Solution α
solutionLocation :: Solution α -> Location
solutionResult :: Solution α -> α

-- | <a>LocatableT</a> is a monad transformer that allows you to take any
--   MonadPlus and add to it the ability to tell where you are in the tree
--   created by the <a>mplus</a>s.
newtype LocatableT m α
LocatableT :: ReaderT Location m α -> LocatableT m α
unwrapLocatableT :: LocatableT m α -> ReaderT Location m α

-- | A <a>Tree</a> augmented with the ability to get the current location
type LocatableTree = LocatableTreeT Identity

-- | Like <a>LocatableTree</a>, but running in the IO monad.
type LocatableTreeIO = LocatableTreeT IO

-- | Like <a>LocatableTree</a>, but running in an arbitrary monad.
newtype LocatableTreeT m α
LocatableTreeT :: LocatableT (TreeT m) α -> LocatableTreeT m α
unwrapLocatableTreeT :: LocatableTreeT m α -> LocatableT (TreeT m) α

-- | Append the path indicated by a checkpoint cursor to the given
--   location's path.
applyCheckpointCursorToLocation :: CheckpointCursor -> Location -> Location

-- | Append the path indicated by a context to the given location's path.
applyContextToLocation :: Context m α -> Location -> Location

-- | Append a path to a location's path.
applyPathToLocation :: Path -> Location -> Location

-- | Converts a location to a list of branch choices.
branchingFromLocation :: Location -> [BranchChoice]

-- | Converts a list (or other <a>Foldable</a>) of branch choices to a
--   location.
labelFromBranching :: Foldable t => t BranchChoice -> Location

-- | Contructs a <a>Location</a> representing the location within the tree
--   indicated by the <a>Context</a>.
labelFromContext :: Context m α -> Location

-- | Contructs a <a>Location</a> representing the location within the tree
--   indicated by the <a>Path</a>.
labelFromPath :: Path -> Location

-- | Returns the <a>Location</a> at the left branch of the given location.
leftBranchOf :: Location -> Location

-- | Convenience function takes a branch choice and returns a location
--   transformer that appends the branch choice to the given location.
locationTransformerForBranchChoice :: BranchChoice -> (Location -> Location)

-- | Converts a <a>LocatableTree</a> to a <a>Tree</a>.
normalizeLocatableTree :: LocatableTree α -> Tree α

-- | Converts a <a>LocatableTreeT</a> to a <a>TreeT</a>.
normalizeLocatableTreeT :: LocatableTreeT m α -> TreeT m α

-- | Returns the <a>Location</a> at the right branch of the given location.
rightBranchOf :: Location -> Location

-- | The location at the root of the tree.
rootLocation :: Location

-- | Runs a <a>LocatableT</a> to obtain the nested monad.
runLocatableT :: LocatableT m α -> m α

-- | Walks down a <a>Tree</a> to the subtree at the given <a>Location</a>.
--   This function is analogous to <a>sendTreeDownPath</a>, and shares the
--   same caveats.
sendTreeDownLocation :: Location -> Tree α -> Tree α

-- | Like <a>sendTreeDownLocation</a>, but for impure trees.
sendTreeTDownLocation :: Monad m => Location -> TreeT m α -> m (TreeT m α)

-- | Converts a list (or other <a>Foldable</a>) of solutions to a
--   <a>Map</a> from <a>Location</a>s to results.
solutionsToMap :: Foldable t => t (Solution α) -> Map Location α

-- | Explore all the nodes in a <a>LocatableTree</a> and sum over all the
--   results in the leaves.
exploreLocatableTree :: Monoid α => LocatableTree α -> α

-- | Same as <a>exploreLocatableTree</a>, but for an impure tree.
exploreLocatableTreeT :: (Monoid α, Monad m) => LocatableTreeT m α -> m α

-- | Same as <a>exploreLocatableTree</a>, but the results are discarded so
--   the tree is only explored for its side-effects.
exploreLocatableTreeTAndIgnoreResults :: Monad m => LocatableTreeT m α -> m ()

-- | Explores all of the nodes of a tree, returning a list of solutions
--   each tagged with the location at which it was found.
exploreTreeWithLocations :: Tree α -> [Solution α]

-- | Like <a>exploreTreeWithLocations</a> but for an impure tree.
exploreTreeTWithLocations :: Monad m => TreeT m α -> m [Solution α]

-- | Like <a>exploreTreeWithLocations</a>, but for a subtree whose location
--   is given by the first argument; the solutions are labeled by the
--   <i>absolute</i> location within the full tree (as opposed to their
--   relative location within the subtree).
exploreTreeWithLocationsStartingAt :: Location -> Tree α -> [Solution α]

-- | Like <a>exploreTreeWithLocationsStartingAt</a> but for an impure
--   trees.
exploreTreeTWithLocationsStartingAt :: Monad m => Location -> TreeT m α -> m [Solution α]

-- | Explores all the nodes in a <a>LocatableTree</a> until a result (i.e.,
--   a leaf) has been found; if a result has been found then it is returned
--   wrapped in <a>Just</a>, otherwise <a>Nothing</a> is returned.
exploreLocatableTreeUntilFirst :: LocatableTree α -> Maybe α

-- | Like <a>exploreLocatableTreeUntilFirst</a> but for an impure tree.
exploreLocatableTreeUntilFirstT :: Monad m => LocatableTreeT m α -> m (Maybe α)

-- | Explores all the nodes in a tree until a result (i.e., a leaf) has
--   been found; if a result has been found then it is returned tagged with
--   the location at which it was found and wrapped in <a>Just</a>,
--   otherwise <a>Nothing</a> is returned.
exploreTreeUntilFirstWithLocation :: Tree α -> Maybe (Solution α)

-- | Like <a>exploreTreeUntilFirstWithLocation</a> but for an impure tree.
exploreTreeTUntilFirstWithLocation :: Monad m => TreeT m α -> m (Maybe (Solution α))

-- | Like <a>exploreTreeUntilFirstWithLocation</a>, but for a subtree whose
--   location is given by the first argument; the solution (if present) is
--   labeled by the <i>absolute</i> location within the full tree (as
--   opposed to its relative location within the subtree).
exploreTreeUntilFirstWithLocationStartingAt :: Location -> Tree α -> Maybe (Solution α)

-- | Like <a>exploreTreeUntilFirstWithLocationStartingAt</a> but for an
--   impure tree.
exploreTreeTUntilFirstWithLocationStartingAt :: Monad m => Location -> TreeT m α -> m (Maybe (Solution α))
instance Eq Location
instance Eq α => Eq (Solution α)
instance Ord α => Ord (Solution α)
instance Show α => Show (Solution α)
instance Applicative m => Applicative (LocatableT m)
instance Functor m => Functor (LocatableT m)
instance Monad m => Monad (LocatableT m)
instance MonadIO m => MonadIO (LocatableT m)
instance MonadTrans LocatableT
instance Monad m => Alternative (LocatableTreeT m)
instance Monad m => Applicative (LocatableTreeT m)
instance Monad m => Functor (LocatableTreeT m)
instance Monad m => Monad (LocatableTreeT m)
instance MonadIO m => MonadIO (LocatableTreeT m)
instance Monad m => MonadLocatable (LocatableTreeT m)
instance Monad m => MonadPlus (LocatableTreeT m)
instance Monad m => Monoid (LocatableTreeT m α)
instance Monad m => MonadExplorableTrans (LocatableTreeT m)
instance MonadTrans LocatableTreeT
instance MonadPlus m => Monoid (LocatableT m α)
instance MonadExplorableTrans m => MonadExplorableTrans (LocatableT m)
instance MonadPlus m => MonadPlus (LocatableT m)
instance MonadPlus m => MonadLocatable (LocatableT m)
instance (Alternative m, Monad m) => Alternative (LocatableT m)
instance Show Location
instance Ord Location
instance Monoid Location


-- | This module contains infrastructure for working with <a>Workload</a>s,
--   which describe a portion of work to be performed by a worker.
module LogicGrowsOnTrees.Workload

-- | A <a>Workload</a> describes a portion of work to be performed by a
--   worker; it consists of a <a>Path</a> to the subtree where the workload
--   is located paired with a <a>Checkpoint</a> that indicates which parts
--   of that subtree have already been explored.
data Workload
Workload :: Path -> Checkpoint -> Workload
workloadPath :: Workload -> Path
workloadCheckpoint :: Workload -> Checkpoint

-- | A <a>Workload</a> that consists of the entire tree.
entire_workload :: Workload

-- | The depth of the workload, equal to the length of the <a>Path</a>
--   component.
workloadDepth :: Workload -> Int

-- | Explores the nodes in a pure tree given by a <a>Workload</a>, and sums
--   over all the results in the leaves.
exploreTreeWithinWorkload :: Monoid α => Workload -> Tree α -> α

-- | Same as <a>exploreTreeWithinWorkload</a> but for an impure tree.
exploreTreeTWithinWorkload :: (Monad m, Monoid α) => Workload -> TreeT m α -> m α

-- | Explores the nodes in a pure tree given by a <a>Workload</a> until a
--   result (i.e. a leaf) has been found; if a result has been found then
--   it is returned wrapped in <a>Just</a>, otherwise <a>Nothing</a> is
--   returned.
exploreTreeUntilFirstWithinWorkload :: Workload -> Tree α -> Maybe α

-- | Same as <a>exploreTreeUntilFirstWithinWorkload</a> but for an impure
--   tree.
exploreTreeTUntilFirstWithinWorkload :: Monad m => Workload -> TreeT m α -> m (Maybe α)

-- | Explores the nodes in a pure tree given by a <a>Workload</a>, summing
--   all results encountered (i.e., in the leaves) until the current
--   partial sum satisfies the condition provided by the first parameter.
--   
--   See <a>exploreTreeUntilFound</a> for more details.
exploreTreeUntilFoundWithinWorkload :: Monoid α => (α -> Bool) -> Workload -> Tree α -> (α, Bool)

-- | Same as <a>exploreTreeUntilFoundWithinWorkload</a> but for an impure
--   tree.
exploreTreeTUntilFoundWithinWorkload :: (Monoid α, Monad m) => (α -> Bool) -> Workload -> TreeT m α -> m (α, Bool)
instance Ord Workload
instance Serialize Workload
instance Eq Workload
instance Show Workload


-- | The <tt>Worker</tt> module contains the workhorse code of the
--   parallelization infrastructure in the form of the
--   <a>forkWorkerThread</a> function, which explores a tree step by step
--   while continuously polling for requests; for more details see
--   <a>forkWorkerThread</a>.
module LogicGrowsOnTrees.Parallel.Common.Worker

-- | A progress update sent to the supervisor; it has a component which
--   contains information about how much of the tree has been explored and
--   what results have been found so far, as well as the remaining
--   <a>Workload</a> to be completed by this worker.
data ProgressUpdate progress
ProgressUpdate :: progress -> Workload -> ProgressUpdate progress
progressUpdateProgress :: ProgressUpdate progress -> progress
progressUpdateRemainingWorkload :: ProgressUpdate progress -> Workload

-- | A convenient type alias for the type of <a>ProgressUpdate</a>
--   associated with the given exploration mode.
type ProgressUpdateFor exploration_mode = ProgressUpdate (ProgressFor exploration_mode)

-- | A stolen workload sent to the supervisor; in addition to a component
--   with the stolen <a>Workload</a> itself, it also has a
--   <a>ProgressUpdate</a> component, which is required in order to
--   maintain the invariant that all of the <a>Workload</a>s that the
--   supervisor has on file (both assigned to workers and unassigned) plus
--   the current progress equals the full tree.
data StolenWorkload progress
StolenWorkload :: ProgressUpdate progress -> Workload -> StolenWorkload progress
stolenWorkloadProgressUpdate :: StolenWorkload progress -> ProgressUpdate progress
stolenWorkload :: StolenWorkload progress -> Workload

-- | A convenient type alias for the type of <a>StolenWorkload</a>
--   associated with the the given exploration mode.
type StolenWorkloadFor exploration_mode = StolenWorkload (ProgressFor exploration_mode)

-- | A queue of worker requests.
--   
--   NOTE: Although the type is a list, and requests are added by
--   prepending them to the list, it still acts as a queue because the
--   worker will reverse the list before processing the requests.
type WorkerRequestQueue progress = IORef [WorkerRequest progress]

-- | A convenient type alias for the type of <a>WorkerRequestQueue</a>
--   associated with the given exploration mode.
type WorkerRequestQueueFor exploration_mode = WorkerRequestQueue (ProgressFor exploration_mode)

-- | The environment of a running worker.
data WorkerEnvironment progress
WorkerEnvironment :: Path -> ThreadId -> WorkerRequestQueue progress -> IVar () -> WorkerEnvironment progress

-- | the initial path of the worker's workload
workerInitialPath :: WorkerEnvironment progress -> Path

-- | the thread id of the worker thread
workerThreadId :: WorkerEnvironment progress -> ThreadId

-- | the request queue for the worker
workerPendingRequests :: WorkerEnvironment progress -> WorkerRequestQueue progress

-- | an IVar that is filled when the worker terminates
workerTerminationFlag :: WorkerEnvironment progress -> IVar ()

-- | A convenient type alias for the type of <a>WorkerEnvironment</a>
--   associated with the given exploration mode.
type WorkerEnvironmentFor exploration_mode = WorkerEnvironment (ProgressFor exploration_mode)

-- | The reason why a worker terminated.
data WorkerTerminationReason worker_final_progress

-- | worker completed normally without error; included is the final result
WorkerFinished :: worker_final_progress -> WorkerTerminationReason worker_final_progress

-- | worker failed; included is the message of the failure (this would have
--   been a value of type <tt>SomeException</tt> if it were not for the
--   fact that this value will often have to be sent over communication
--   channels and exceptions cannot be serialized (as they have unknown
--   type), meaning that it usually has to be turned into a <a>String</a>
--   via <a>show</a> anyway)
WorkerFailed :: String -> WorkerTerminationReason worker_final_progress

-- | worker was aborted by either an external request or the
--   <a>ThreadKilled</a> or <a>UserInterrupt</a> exceptions
WorkerAborted :: WorkerTerminationReason worker_final_progress

-- | A convenient type alias for the type of <a>WorkerTerminationReason</a>
--   associated with the given exploration mode.
type WorkerTerminationReasonFor exploration_mode = WorkerTerminationReason (WorkerFinishedProgressFor exploration_mode)

-- | The action that a worker can take to push a result to the supervisor;
--   this type is effectively null (with the exact value <a>absurd</a>) for
--   all modes except <a>FoundModeUsingPush</a>.

-- | The <a>forkWorkerThread</a> function is the workhorse of the
--   parallization infrastructure; it explores a tree in a separate thread
--   while polling for requests. Specifically, the worker alternates
--   between stepping through the tree and checking to see if there are any
--   new requests in the queue.
--   
--   The worker is optimized around the observation that the vast majority
--   of its time is spent exploring the tree rather than responding to
--   requests, and so the amount of overhead needed to check if any
--   requests are present needs to be minimized at the cost of possibly
--   delaying a response to an incoming request. For this reason, it uses
--   an <a>IORef</a> for the queue to minimize the cost of peeking at it
--   rather than an <tt>MVar</tt> or some other thread synchronization
--   variable; the trade-off is that if a request is added to the queue by
--   a different processor then it might not be noticed immediately the
--   caches get synchronized. Likewise, the request queue uses the List
--   type rather than something like <a>Data.Sequence</a> for simplicity;
--   the vast majority of the time the worker will encounter an empty list,
--   and on the rare occasion when the list is non-empty it will be short
--   enough that <a>reverse</a>ing it will not pose a significant cost.
--   
--   At any given point in the exploration, there is an initial path which
--   locates the subtree that was given as the original workload, a cursor
--   which indicates the subtree <i>within</i> this subtree that makes up
--   the <i>current</i> workload, and the context which indicates the
--   current location in the subtree that is being explored. All workers
--   start with an empty cursor; when a workload is stolen, decisions made
--   early on in the the context are frozen and moved into the cursor
--   because if they were not then when the worker backtracked it would
--   explore a workload that it just gave away, resulting in some results
--   being observed twice.
--   
--   The worker terminates either if it finishes exploring all the nodes in
--   its (current) workload, if an error occurs, or if it is aborted either
--   via. the <a>ThreadKilled</a> and <a>UserInterrupt</a> exceptions or by
--   an abort request placed in the request queue.
forkWorkerThread :: ExplorationMode exploration_mode -> Purity m n -> (WorkerTerminationReasonFor exploration_mode -> IO ()) -> TreeT m (ResultFor exploration_mode) -> Workload -> WorkerPushActionFor exploration_mode -> IO (WorkerEnvironmentFor exploration_mode)

-- | Sends a request to abort.
sendAbortRequest :: WorkerRequestQueue progress -> IO ()

-- | Sends a request for a progress update along with a response action to
--   perform when the progress update is available.
sendProgressUpdateRequest :: WorkerRequestQueue progress -> (ProgressUpdate progress -> IO ()) -> IO ()

-- | Sends a request to steal a workload along with a response action to
--   perform when the progress update is available.
sendWorkloadStealRequest :: WorkerRequestQueue progress -> (Maybe (StolenWorkload progress) -> IO ()) -> IO ()

-- | Explores a tree with the specified purity using the given mode by
--   forking a worker thread and waiting for it to finish; it exists to
--   facilitate testing and benchmarking and is not a function that you are
--   likely to ever have a need for yourself.
exploreTreeGeneric :: (WorkerPushActionFor exploration_mode ~ (Void -> ()), ResultFor exploration_mode ~ α) => ExplorationMode exploration_mode -> Purity m n -> TreeT m α -> IO (WorkerTerminationReason (FinalResultFor exploration_mode))
instance Eq worker_final_progress => Eq (WorkerTerminationReason worker_final_progress)
instance Show worker_final_progress => Show (WorkerTerminationReason worker_final_progress)
instance Functor WorkerTerminationReason
instance Serialize progress_1627696606 => Serialize (StolenWorkload progress_1627696606)
instance Eq progress => Eq (StolenWorkload progress)
instance Show progress => Show (StolenWorkload progress)
instance Serialize progress_1627696524 => Serialize (ProgressUpdate progress_1627696524)
instance Eq progress => Eq (ProgressUpdate progress)
instance Show progress => Show (ProgressUpdate progress)


-- | This module contains infrastructure for communicating with workers
--   over an inter-process channel.
module LogicGrowsOnTrees.Parallel.Common.Message

-- | A message from a worker to the supervisor; the worker id is assumed to
--   be known based on from where the message was received.
data MessageForSupervisor progress worker_final_progress

-- | The worker encountered a failure with the given message while
--   exploring the tree.
Failed :: String -> MessageForSupervisor progress worker_final_progress

-- | The worker has finished with the given final progress.
Finished :: worker_final_progress -> MessageForSupervisor progress worker_final_progress

-- | The worker has responded to the progress update request with the given
--   progress update.
ProgressUpdate :: (ProgressUpdate progress) -> MessageForSupervisor progress worker_final_progress

-- | The worker has responded to the workload steal request with possibly
--   the stolen workload (and <a>Nothing</a> if it was not possible to
--   steal a workload at this time).
StolenWorkload :: (Maybe (StolenWorkload progress)) -> MessageForSupervisor progress worker_final_progress

-- | The worker has quit the system and is no longer available
WorkerQuit :: MessageForSupervisor progress worker_final_progress

-- | Convenient type alias for the <a>MessageForSupervisor</a> type for the
--   given exploration mode.
type MessageForSupervisorFor exploration_mode = MessageForSupervisor (ProgressFor exploration_mode) (WorkerFinishedProgressFor exploration_mode)

-- | This data structure contains callbacks to be invoked when a message
--   has been received, depending on the kind of message.
data MessageForSupervisorReceivers exploration_mode worker_id
MessageForSupervisorReceivers :: (worker_id -> ProgressUpdate (ProgressFor exploration_mode) -> IO ()) -> (worker_id -> Maybe (StolenWorkload (ProgressFor exploration_mode)) -> IO ()) -> (worker_id -> String -> IO ()) -> (worker_id -> WorkerFinishedProgressFor exploration_mode -> IO ()) -> (worker_id -> IO ()) -> MessageForSupervisorReceivers exploration_mode worker_id

-- | to be called when a progress update has been received from a worker
receiveProgressUpdateFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> ProgressUpdate (ProgressFor exploration_mode) -> IO ()

-- | to be called when a (possibly) stolen workload has been received from
--   a worker
receiveStolenWorkloadFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> Maybe (StolenWorkload (ProgressFor exploration_mode)) -> IO ()

-- | to be called when a failure (with the given message) has been received
--   from a worker
receiveFailureFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> String -> IO ()

-- | to be called when a worker has finished with the given final progress
receiveFinishedFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> WorkerFinishedProgressFor exploration_mode -> IO ()

-- | to be called when a worker has quit the system and is no longer
--   available
receiveQuitFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> IO ()

-- | A message from the supervisor to a worker.
--   
--   NOTE: It is your responsibility not to send a workload to a worker
--   that already has one; if you do then the worker will report an error
--   and then terminate. The converse, however, is not true: it is okay to
--   send a progress request to a worker without a workload because the
--   worker might have finished between when you sent the message and when
--   it was received.
data MessageForWorker

-- | request a progress update
RequestProgressUpdate :: MessageForWorker

-- | request a stolen workload
RequestWorkloadSteal :: MessageForWorker

-- | start exploring the given workload
StartWorkload :: Workload -> MessageForWorker

-- | stop what you are doing and quit the system
QuitWorker :: MessageForWorker

-- | Continually performs the given IO action to read a message from a
--   worker with the given id and calls one of the given callbacks
--   depending on the content of the message.
receiveAndProcessMessagesFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> IO (MessageForSupervisorFor exploration_mode) -> worker_id -> IO ()

-- | The same as <a>receiveAndProcessMessagesFromWorker</a> except that
--   instead of giving it an IO action to fetch a message you provide a
--   <a>Handle</a> from which messsages (assumed to be deserializable) are
--   read.
receiveAndProcessMessagesFromWorkerUsingHandle :: (Serialize (ProgressFor exploration_mode), Serialize (WorkerFinishedProgressFor exploration_mode)) => MessageForSupervisorReceivers exploration_mode worker_id -> Handle -> worker_id -> IO ()
instance Serialize MessageForWorker
instance Eq MessageForWorker
instance Show MessageForWorker
instance (Serialize progress_1627715877, Serialize worker_final_progress_1627715878) => Serialize (MessageForSupervisor progress_1627715877 worker_final_progress_1627715878)
instance (Eq progress, Eq worker_final_progress) => Eq (MessageForSupervisor progress worker_final_progress)
instance (Show progress, Show worker_final_progress) => Show (MessageForSupervisor progress worker_final_progress)


-- | The Supervisor module contains logic that is common to all of the
--   adapters for the parallization infrastructure. The way to use it is to
--   package the logic for communicating with your workers into a
--   <a>SupervisorProgram</a> that runs in the <a>SupervisorMonad</a> with
--   your state just below the <a>SupervisorMonad</a> in the monad stack.
--   
--   A great deal of the logic in this module deals with gathering
--   statistics whose purpose is to provide data that can be used to figure
--   out what is going wrong if the runtime is not scaling inversely with
--   the number of workers.
module LogicGrowsOnTrees.Parallel.Common.Supervisor

-- | Statistics for a value obtained by integrating a value that is a
--   function of time --- i.e., a quantity that holds a single value at any
--   given point in time.
data FunctionOfTimeStatistics α
FunctionOfTimeStatistics :: !Word -> !Double -> !Double -> !α -> !α -> FunctionOfTimeStatistics α

-- | the number of points at which the function changed
timeCount :: FunctionOfTimeStatistics α -> !Word

-- | the average value of the function over the time period
timeAverage :: FunctionOfTimeStatistics α -> !Double

-- | the standard deviation of the function over the time period
timeStdDev :: FunctionOfTimeStatistics α -> !Double

-- | the minimum value of the function over the time period
timeMin :: FunctionOfTimeStatistics α -> !α

-- | the maximum value of the function over the time period
timeMax :: FunctionOfTimeStatistics α -> !α

-- | Statistics for a value obtained by collecting a number of independent
--   measurements.
data IndependentMeasurementsStatistics
IndependentMeasurementsStatistics :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> IndependentMeasurementsStatistics

-- | the number of measurements
statCount :: IndependentMeasurementsStatistics -> {-# UNPACK #-} !Int

-- | the average value
statAverage :: IndependentMeasurementsStatistics -> {-# UNPACK #-} !Double

-- | the standard deviation
statStdDev :: IndependentMeasurementsStatistics -> {-# UNPACK #-} !Double

-- | the minimum measurement value
statMin :: IndependentMeasurementsStatistics -> {-# UNPACK #-} !Double

-- | the maximum measurement value
statMax :: IndependentMeasurementsStatistics -> {-# UNPACK #-} !Double

-- | Statistics gathered about the run.
data RunStatistics
RunStatistics :: !UTCTime -> !UTCTime -> !NominalDiffTime -> !Float -> !Float -> !Int -> !Float -> !Float -> !(FunctionOfTimeStatistics NominalDiffTime) -> !IndependentMeasurementsStatistics -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Float) -> !(FunctionOfTimeStatistics Float) -> RunStatistics

-- | the start time of the run
runStartTime :: RunStatistics -> !UTCTime

-- | the end time of the run
runEndTime :: RunStatistics -> !UTCTime

-- | the wall time of the run
runWallTime :: RunStatistics -> !NominalDiffTime

-- | the fraction of the time the supervisor spent processing events
runSupervisorOccupation :: RunStatistics -> !Float

-- | the fraction of the time the supervisor spent processing events while
--   inside the <tt>SupervisorMonad</tt>
runSupervisorMonadOccupation :: RunStatistics -> !Float

-- | the number of calls made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runNumberOfCalls :: RunStatistics -> !Int

-- | the average amount of time per call made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runAverageTimePerCall :: RunStatistics -> !Float

-- | the fraction of the total time that workers were occupied
runWorkerOccupation :: RunStatistics -> !Float

-- | statistics for how long it took for workers to obtain a workload
runWorkerWaitTimes :: RunStatistics -> !(FunctionOfTimeStatistics NominalDiffTime)

-- | statistics for the time needed to steal a workload from a worker
runStealWaitTimes :: RunStatistics -> !IndependentMeasurementsStatistics

-- | statistics for the number of workers waiting for a workload
runWaitingWorkerStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the number of available workloads waiting for a worker
runAvailableWorkloadStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the instantaneous rate at which workloads were
--   requested (using an exponentially decaying sum)
runInstantaneousWorkloadRequestRateStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | statistics for the instantaneous time needed for workloads to be
--   stolen (using an exponentially decaying weighted average)
runInstantaneousWorkloadStealTimeStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | This is just a sum of <a>SupervisorMonadConstraint</a> and the
--   <a>SupervisorWorkerIdConstraint</a>.
type SupervisorFullConstraint worker_id m = (SupervisorWorkerIdConstraint worker_id, SupervisorMonadConstraint m)

-- | This is the constraint placed on the monad in which the supervisor is
--   running.
type SupervisorMonadConstraint m = (Functor m, MonadIO m)

-- | This is the constraint placed on the types that can be used as worker
--   ids.
type SupervisorWorkerIdConstraint worker_id = (Eq worker_id, Ord worker_id, Show worker_id, Typeable worker_id)

-- | Supervisor callbacks provide the means by which the supervisor logic
--   communicates to the adapter, usually in order to tell it what it wants
--   to say to various workers.
data SupervisorCallbacks exploration_mode worker_id m
SupervisorCallbacks :: ([worker_id] -> m ()) -> ([worker_id] -> m ()) -> (ProgressFor exploration_mode -> m ()) -> (Workload -> worker_id -> m ()) -> SupervisorCallbacks exploration_mode worker_id m

-- | send a progress update request to the given workers
broadcastProgressUpdateToWorkers :: SupervisorCallbacks exploration_mode worker_id m -> [worker_id] -> m ()

-- | send a workload steal request to the given workers
broadcastWorkloadStealToWorkers :: SupervisorCallbacks exploration_mode worker_id m -> [worker_id] -> m ()

-- | receive the result of the global progress update that was requested by
--   the controller
receiveCurrentProgress :: SupervisorCallbacks exploration_mode worker_id m -> ProgressFor exploration_mode -> m ()

-- | send the given workload to the given worker
sendWorkloadToWorker :: SupervisorCallbacks exploration_mode worker_id m -> Workload -> worker_id -> m ()

-- | This is the monad in which the supervisor logic is run; it keeps track
--   of the state of the system including the current workers and their
--   workloads, the current progress of the system, which workers we are
--   waiting for a progress update or stolen workload from, etc.
data SupervisorMonad exploration_mode worker_id m α

-- | The outcome of running the supervisor.
data SupervisorOutcome final_result progress worker_id
SupervisorOutcome :: SupervisorTerminationReason final_result progress worker_id -> RunStatistics -> [worker_id] -> SupervisorOutcome final_result progress worker_id

-- | the reason the supervisor terminated
supervisorTerminationReason :: SupervisorOutcome final_result progress worker_id -> SupervisorTerminationReason final_result progress worker_id

-- | the statistics for the run
supervisorRunStatistics :: SupervisorOutcome final_result progress worker_id -> RunStatistics

-- | the workers that were present when it finished
supervisorRemainingWorkers :: SupervisorOutcome final_result progress worker_id -> [worker_id]

-- | A convenient type alias for the <a>SupervisorOutcome</a> associated
--   with a given exploration mode.
type SupervisorOutcomeFor exploration_mode worker_id = SupervisorOutcome (FinalResultFor exploration_mode) (ProgressFor exploration_mode) worker_id

-- | A <a>SupervisorProgram</a> is a specification of an event loop to be
--   run inside the <a>SupervisorMonad</a>; it exists in order to help the
--   supervisor get an estimate for how much time it is spending doing work
--   as opposed to waiting for a message from a worker so that it can
--   generate accurate statistics about how much of the time it was
--   occupied at the end of the run.
data SupervisorProgram exploration_mode worker_id m

-- | A <a>BlockingProgram</a> has an event loop that executes an action
--   that pauses the thread until an event occurs and then reacts to that
--   event. The first argument is the supervisor action that initializes
--   the system, the second argument is an action that blocks until an
--   event has occurred, and the third argument is the supervisor action to
--   run in response to the event.
BlockingProgram :: (SupervisorMonad exploration_mode worker_id m ()) -> (m α) -> (α -> SupervisorMonad exploration_mode worker_id m ()) -> SupervisorProgram exploration_mode worker_id m

-- | A <a>PollingProgram</a> has an event loop that executes an action that
--   checks whether an event has occurred and if so then reacts to that
--   event. The first argument is the supervisor action that initializes
--   the system, the second argument is an action that checks whether an
--   event has occurred, and the third argument is the supervisor action to
--   run in response to an event.
PollingProgram :: (SupervisorMonad exploration_mode worker_id m ()) -> (m (Maybe α)) -> (α -> SupervisorMonad exploration_mode worker_id m ()) -> SupervisorProgram exploration_mode worker_id m

-- | An <a>UnrestrictedProgram</a> is an event loop that you implement
--   manually; note that it must run forever until the logic in the
--   <a>SupervisorMonad</a> decides to exit --- although you can always
--   force it to abort by calling <a>abortSupervisor</a>. This mode exists
--   for testing rather than to be used by an adapter, but if you do use it
--   then you take on responsibility for calling
--   <a>beginSupervisorOccupied</a> and <a>endSupervisorOccupied</a> when
--   respectively the supervisor has begun and ended processing events so
--   that the supervisor occupation statistics are correct.
UnrestrictedProgram :: (forall α. SupervisorMonad exploration_mode worker_id m α) -> SupervisorProgram exploration_mode worker_id m

-- | The reason why the supervisor terminated.
data SupervisorTerminationReason final_result progress worker_id

-- | the supervisor aborted before finishing; included is the current
--   progress at the time it aborted
SupervisorAborted :: progress -> SupervisorTerminationReason final_result progress worker_id

-- | the supervisor completed exploring the tree; included is the final
--   result
SupervisorCompleted :: final_result -> SupervisorTerminationReason final_result progress worker_id

-- | the supervisor failed to explore the tree; included is the worker
--   where the failure occured as well as the message and the current
--   progress at the time of failure
SupervisorFailure :: progress -> worker_id -> String -> SupervisorTerminationReason final_result progress worker_id

-- | A convenient type alias for the <a>SupervisorTerminationReason</a>
--   associated with a given exploration mode.
type SupervisorTerminationReasonFor exploration_mode = SupervisorTerminationReason (FinalResultFor exploration_mode) (ProgressFor exploration_mode)

-- | Informs the supervisor that a worker has been added to the system; the
--   supervisor will attempt to obtain a workload for it, stealing one if
--   necessary.
addWorker :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> SupervisorMonad exploration_mode worker_id m ()

-- | Request that a global progress update be performed; the supervisor
--   will send progress update requests to all workers, and when it has
--   received a response from everyone it will call the
--   <a>receiveCurrentProgress</a> callback in the
--   <a>SupervisorCallbacks</a>.
performGlobalProgressUpdate :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a progress update has been received by a
--   worker.
receiveProgressUpdate :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> ProgressUpdateFor exploration_mode -> SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a worker has responded to a workload steal
--   request; a <a>Nothing</a> indicates that the worker did not have a
--   workload that could be stolen (which occurs if it hadn't taken any
--   branches at the time the request was received).
receiveStolenWorkload :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> Maybe (StolenWorkloadFor exploration_mode) -> SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a worker has failed; the system will be
--   terminated and the given message returned as the failure message.
receiveWorkerFailure :: SupervisorFullConstraint worker_id m => worker_id -> String -> SupervisorMonad exploration_mode worker_id m α

-- | Informs the supervisor that a worker has finished its current workload
--   and returned the given final progress.
receiveWorkerFinished :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> WorkerFinishedProgressFor exploration_mode -> SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a worker has finished its current workload
--   and returned the given final progress; the worker will be removed
--   after its final progress has been processed.
receiveWorkerFinishedAndRemoved :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> WorkerFinishedProgressFor exploration_mode -> SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a worker has finished its current workload
--   and returned the given final progress; if the first argument is
--   <a>True</a> then the worker will be removed.
receiveWorkerFinishedWithRemovalFlag :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => Bool -> worker_id -> WorkerFinishedProgressFor exploration_mode -> SupervisorMonad exploration_mode worker_id m ()

-- | Informs the supervisor that a worker (which might have been active and
--   possibly even waited on for a progress update and/or stolen workload)
--   has been removed; the worker will be removed from the set of workers
--   with pending requests and its workload will be returned to the pool of
--   available workloads.
removeWorker :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> SupervisorMonad exploration_mode worker_id m ()

-- | Like <a>removeWorker</a>, but only acts if the worker is present.
removeWorkerIfPresent :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => worker_id -> SupervisorMonad exploration_mode worker_id m ()

-- | Aborts the supervisor.
abortSupervisor :: SupervisorFullConstraint worker_id m => SupervisorMonad exploration_mode worker_id m α

-- | Signals that the supervisor has begun processing an event.
beginSupervisorOccupied :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m ()

-- | Turns off debug mode; for more details see
--   <a>setSupervisorDebugMode</a>.
disableSupervisorDebugMode :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m ()

-- | Turns on debug mode; for more details see
--   <a>setSupervisorDebugMode</a>.
enableSupervisorDebugMode :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m ()

-- | Signals that the supervisor has finished processing an event.
endSupervisorOccupied :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m ()

-- | Sets whether the supervisor is in debug mode; when it is in this mode
--   it performs continuous self-consistency checks. This mode is intended
--   for assisting in debugging new adapters.
setSupervisorDebugMode :: SupervisorMonadConstraint m => Bool -> SupervisorMonad exploration_mode worker_id m ()

-- | Sets the workload buffer size, which is the minimum number of
--   workloads that the supervisor will attempt to have available at all
--   times so that requests for new workloads from workers can be responded
--   to immediately.
--   
--   Normally the default value of 4 will be fine, but if you run into a
--   problem where the amount of time needed to steal a workload is greater
--   than the average time between requests for new workloads, then setting
--   this to be proportional to the time needed to steal a workload divided
--   by the time between workload requests may help.
setWorkloadBufferSize :: SupervisorMonadConstraint m => Int -> SupervisorMonad exploration_mode worker_id m ()

-- | Gets the current progress of the system.
getCurrentProgress :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m (ProgressFor exploration_mode)

-- | Gets the current statistics of the system. (Unlike the other "get"
--   operations, there is a small but non-zero cost to do this as the
--   statistics exist in an intermediate state that needs to be finalized.)
getCurrentStatistics :: SupervisorFullConstraint worker_id m => SupervisorMonad exploration_mode worker_id m RunStatistics

-- | Gets the number of workers that are currently present in the system.
getNumberOfWorkers :: SupervisorMonadConstraint m => SupervisorMonad exploration_mode worker_id m Int

-- | If there exists any workers waiting for a workload, it returns the id
--   of one of them wrapped in <a>Just</a>; it not, it returns
--   <a>Nothing</a>. (This is useful, for example, if you want to reduce
--   the number of workers as it is best to start by removing ones that are
--   currently idle.)
tryGetWaitingWorker :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => SupervisorMonad exploration_mode worker_id m (Maybe worker_id)

-- | Runs the supervisor in the given exploration mode with the given
--   callbacks and program.
runSupervisor :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => ExplorationMode exploration_mode -> SupervisorCallbacks exploration_mode worker_id m -> SupervisorProgram exploration_mode worker_id m -> m (SupervisorOutcomeFor exploration_mode worker_id)

-- | Like <a>runSupervisor</a> but starting from the given progress.
runSupervisorStartingFrom :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => ExplorationMode exploration_mode -> ProgressFor exploration_mode -> SupervisorCallbacks exploration_mode worker_id m -> SupervisorProgram exploration_mode worker_id m -> m (SupervisorOutcomeFor exploration_mode worker_id)

-- | Runs the supervisor with a raw action in the <a>SupervisorMonad</a>.
--   
--   NOTE: You should not normally use this function, as it exists
--   primarily for testing purposes; see <a>SupervisorProgram</a> for
--   details.
runUnrestrictedSupervisor :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => ExplorationMode exploration_mode -> SupervisorCallbacks exploration_mode worker_id m -> (forall α. SupervisorMonad exploration_mode worker_id m α) -> m (SupervisorOutcomeFor exploration_mode worker_id)

-- | Like <a>runUnrestrictedSupervisor</a> but starting from the given
--   progress.
runUnrestrictedSupervisorStartingFrom :: (SupervisorMonadConstraint m, SupervisorWorkerIdConstraint worker_id) => ExplorationMode exploration_mode -> ProgressFor exploration_mode -> SupervisorCallbacks exploration_mode worker_id m -> (forall α. SupervisorMonad exploration_mode worker_id m α) -> m (SupervisorOutcomeFor exploration_mode worker_id)
instance (Monad m, Functor m) => Applicative (SupervisorMonad exploration_mode worker_id m)
instance Functor m => Functor (SupervisorMonad exploration_mode worker_id m)
instance Monad m => Monad (SupervisorMonad exploration_mode worker_id m)
instance MonadIO m => MonadIO (SupervisorMonad exploration_mode worker_id m)
instance WrappableIntoSupervisorMonad ContextMonad
instance WrappableIntoSupervisorMonad AbortMonad
instance MonadState s m => MonadState s (SupervisorMonad exploration_mode worker_id m)
instance MonadReader e m => MonadReader e (SupervisorMonad exploration_mode worker_id m)
instance MonadTrans (SupervisorMonad exploration_mode worker_id)


-- | To understand the purpose of this module, it helps to know that there
--   are two main loops running in the supervisor. The first loop runs
--   inside the <a>SupervisorMonad</a> and is usually taken over by the
--   adapter, which handles the communication between the supervisors and
--   the workers. The second loop (referred to as the <i>controller</i>) is
--   intended for the user to be able to submit requests such as a global
--   progress update to the supervisor, or possibly adapter-specific
--   requests (such as changing the number of workers).
--   
--   With this in mind, the purpose of this module is to create
--   infrastructure for the second loop (the controller) to submit requests
--   to the first loop. It provides this functionality through a class so
--   that specific adapters can extend this to provide requests specific to
--   that adapter (such as changing the number of workers).
module LogicGrowsOnTrees.Parallel.Common.RequestQueue

-- | This class provides the set of supervisor requests common to all
--   adapters.
class (HasExplorationMode m, Functor m, MonadCatchIO m) => RequestQueueMonad m
abort :: RequestQueueMonad m => m ()
fork :: RequestQueueMonad m => m () -> m ThreadId
getCurrentProgressAsync :: RequestQueueMonad m => (ProgressFor (ExplorationModeFor m) -> IO ()) -> m ()
getNumberOfWorkersAsync :: RequestQueueMonad m => (Int -> IO ()) -> m ()
requestProgressUpdateAsync :: RequestQueueMonad m => (ProgressFor (ExplorationModeFor m) -> IO ()) -> m ()
setWorkloadBufferSize :: RequestQueueMonad m => Int -> m ()

-- | A supervisor request.
type Request exploration_mode worker_id m = SupervisorMonad exploration_mode worker_id m ()

-- | A basic supervisor request queue.
data RequestQueue exploration_mode worker_id m
RequestQueue :: !(TChan (Request exploration_mode worker_id m)) -> !(IORef [ProgressFor exploration_mode -> IO ()]) -> !(IORef [ThreadId]) -> RequestQueue exploration_mode worker_id m

-- | the queue of requests to the supervisor
requests :: RequestQueue exploration_mode worker_id m -> !(TChan (Request exploration_mode worker_id m))

-- | a list of callbacks to invoke when a global progress update has
--   completed
receivers :: RequestQueue exploration_mode worker_id m -> !(IORef [ProgressFor exploration_mode -> IO ()])

-- | a list of the controller threads
controllerThreads :: RequestQueue exploration_mode worker_id m -> !(IORef [ThreadId])

-- | A basic supervisor request queue monad, which has an implicit
--   <a>RequestQueue</a> object that it uses to communicate with the
--   supervisor loop.
type RequestQueueReader exploration_mode worker_id m = ReaderT (RequestQueue exploration_mode worker_id m) IO

-- | Like <a>getCurrentProgressAsync</a>, but blocks until the result is
--   ready.
getCurrentProgress :: RequestQueueMonad m => m (ProgressFor (ExplorationModeFor m))

-- | Like <a>getNumberOfWorkersAsync</a>, but blocks until the result is
--   ready.
getNumberOfWorkers :: RequestQueueMonad m => m Int

-- | Like <a>requestProgressUpdateAsync</a>, but blocks until the progress
--   update has completed.
requestProgressUpdate :: RequestQueueMonad m => m (ProgressFor (ExplorationModeFor m))

-- | General utility function for converting an asynchronous request to a
--   synchronous request; it uses an <tt>MVar</tt> to hold the result of
--   the request and blocks until the <tt>MVar</tt> has been filled.
syncAsync :: MonadIO m => ((α -> IO ()) -> m ()) -> m α

-- | Adds a callback to the given <a>RequestQueue</a> that will be invoked
--   when the current global progress update has completed.
addProgressReceiver :: MonadIO m' => (ProgressFor exploration_mode -> IO ()) -> RequestQueue exploration_mode worker_id m -> m' ()

-- | Enqueues a supervisor request into the given queue.
enqueueRequest :: MonadIO m' => Request exploration_mode worker_id m -> RequestQueue exploration_mode worker_id m -> m' ()

-- | Like <a>enqueueRequest</a>, but does not return until the request has
--   been run
enqueueRequestAndWait :: (MonadIO m, MonadIO m') => Request exploration_mode worker_id m -> RequestQueue exploration_mode worker_id m -> m' ()

-- | Constructs a new <a>RequestQueue</a>.
newRequestQueue :: MonadIO m' => m' (RequestQueue exploration_mode worker_id m)

-- | Attempt to pop a request from the <a>RequestQueue</a>.
tryDequeueRequest :: MonadIO m' => RequestQueue exploration_mode worker_id m -> m' (Maybe (Request exploration_mode worker_id m))

-- | Processes all of the requests in the given <a>RequestQueue</a>, and
--   returns when the queue has been emptied.
processAllRequests :: MonadIO m => RequestQueue exploration_mode worker_id m -> SupervisorMonad exploration_mode worker_id m ()

-- | Invokes all of the callbacks with the given progress and then clears
--   the list of callbacks.
receiveProgress :: MonadIO m' => RequestQueue exploration_mode worker_id m -> ProgressFor exploration_mode -> m' ()

-- | Creates a supervisor program that loops forever processing requests
--   from the given queue.
requestQueueProgram :: MonadIO m => SupervisorMonad exploration_mode worker_id m () -> RequestQueue exploration_mode worker_id m -> SupervisorProgram exploration_mode worker_id m

-- | Forks a controller thread; it's <a>ThreadId</a> is added the list in
--   the request queue. We deliberately do not return the <a>ThreadId</a>
--   from this function because you must always call
--   <a>killControllerThreads</a> to kill the controller thread as this
--   makes sure that all child threads also get killed.
forkControllerThread :: MonadIO m' => RequestQueue exploration_mode worker_id m -> RequestQueueReader exploration_mode worker_id m () -> m' ()

-- | Kill all the controller threads and their children.
killControllerThreads :: MonadIO m' => RequestQueue exploration_mode worker_id m -> m' ()

-- | Submits a <a>Request</a> to the supervisor and invokes the given
--   callback with the result when it is available. (This function is used
--   by <a>getCurrentProgressAsync</a> and <a>getNumberOfWorkersAsync</a>.)
getQuantityAsync :: (MonadIO m', SupervisorFullConstraint worker_id m) => SupervisorMonad exploration_mode worker_id m α -> (α -> IO ()) -> RequestQueue exploration_mode worker_id m -> m' ()
instance (SupervisorFullConstraint worker_id m, MonadCatchIO m) => RequestQueueMonad (RequestQueueReader exploration_mode worker_id m)
instance HasExplorationMode (RequestQueueReader exploration_mode worker_id m)


-- | This module provides a framework for creating a program that explores
--   a tree in parallel. There are two families of functions that are
--   available. The first is more general and allows you to construct your
--   tree using arguments given on the command-line; they are described in
--   the section linked to by <a>LogicGrowsOnTrees.Parallel.Main#main</a>.
--   If you do not need run-time information via a command-line argument to
--   construct the tree, then you may prefer the simpler family of
--   functions which are described in the section linked to by
--   <a>LogicGrowsOnTrees.Parallel.Main#main-simple</a>.
--   
--   All of this functionality is adapter independent, so if you want to
--   use a different back end you only need to change the driver argument
--   and recompile.
module LogicGrowsOnTrees.Parallel.Main

-- | The <a>Driver</a> is the core type that abstracts the various adapters
--   behind a common interface that can be invoked by the main functions;
--   it specifies a function that is called to start the run with a set of
--   parameters specified in <a>DriverParameters</a>.
--   
--   (Unfortunately in haddock the type signature below can be difficult to
--   read because it puts all of the type on a single line; the type is
--   essentially just a map from <a>DriverParameters</a> to
--   <tt>result_monad ()</tt>, but involving a bunch of type variables and
--   some constraints on them. It might be easier to click the link to go
--   to the source.)
--   
--   Note that the <tt>controller_monad</tt> type parameter is within an
--   existential type; this is because the user of the driver should not
--   need to know what it is.
data Driver result_monad shared_configuration supervisor_configuration m n exploration_mode
Driver :: ((Serialize (ProgressFor exploration_mode), MonadIO result_monad) => DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> result_monad ()) -> Driver result_monad shared_configuration supervisor_configuration m n exploration_mode

-- | The <a>DriverParameters</a> type specifies the information that is
--   given to the driver in the main functions.
data DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad
DriverParameters :: Term shared_configuration -> Term supervisor_configuration -> TermInfo -> (shared_configuration -> IO ()) -> (shared_configuration -> supervisor_configuration -> IO (ProgressFor exploration_mode)) -> (shared_configuration -> supervisor_configuration -> RunOutcomeFor exploration_mode -> IO ()) -> (shared_configuration -> ExplorationMode exploration_mode) -> (shared_configuration -> TreeT m (ResultFor exploration_mode)) -> Purity m n -> (shared_configuration -> supervisor_configuration -> controller_monad exploration_mode ()) -> DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad

-- | configuration information shared between the supervisor and the worker
shared_configuration_term :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> Term shared_configuration

-- | configuration information specific to the supervisor
supervisor_configuration_term :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> Term supervisor_configuration

-- | program information; should at a minimum put a brief description of
--   the program in the <a>termDoc</a> field
program_info :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> TermInfo

-- | action that initializes the global state of each process --- that is,
--   once for each running instance of the executable, which depending on
--   the adapter might be a supervisor, a worker, or both
initializeGlobalState :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> IO ()

-- | in the supervisor, gets the starting progress for the exploration;
--   this is where a checkpoint is loaded, if one exists
getStartingProgress :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> supervisor_configuration -> IO (ProgressFor exploration_mode)

-- | in the supervisor, responds to the termination of the run
notifyTerminated :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> supervisor_configuration -> RunOutcomeFor exploration_mode -> IO ()

-- | constructs the exploration mode given the shared configuration
constructExplorationMode :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> ExplorationMode exploration_mode

-- | constructs the tree given the shared configuration
constructTree :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> TreeT m (ResultFor exploration_mode)

-- | the purity of the constructed tree
purity :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> Purity m n

-- | construct the controller, which runs in the supervisor and handles
--   things like periodic checkpointing
constructController :: DriverParameters shared_configuration supervisor_configuration m n exploration_mode controller_monad -> shared_configuration -> supervisor_configuration -> controller_monad exploration_mode ()

-- | A type that represents the outcome of a run.
data RunOutcome progress final_result
RunOutcome :: RunStatistics -> TerminationReason progress final_result -> RunOutcome progress final_result

-- | statistics gathered during the run, useful if the system is not
--   scaling with the number of workers as it should
runStatistics :: RunOutcome progress final_result -> RunStatistics

-- | the reason why the run terminated
runTerminationReason :: RunOutcome progress final_result -> TerminationReason progress final_result

-- | A convenient type alias for the type of <a>RunOutcome</a> associated
--   with the given exploration mode.
type RunOutcomeFor exploration_mode = RunOutcome (ProgressFor exploration_mode) (FinalResultFor exploration_mode)

-- | Statistics gathered about the run.
data RunStatistics
RunStatistics :: !UTCTime -> !UTCTime -> !NominalDiffTime -> !Float -> !Float -> !Int -> !Float -> !Float -> !(FunctionOfTimeStatistics NominalDiffTime) -> !IndependentMeasurementsStatistics -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Float) -> !(FunctionOfTimeStatistics Float) -> RunStatistics

-- | the start time of the run
runStartTime :: RunStatistics -> !UTCTime

-- | the end time of the run
runEndTime :: RunStatistics -> !UTCTime

-- | the wall time of the run
runWallTime :: RunStatistics -> !NominalDiffTime

-- | the fraction of the time the supervisor spent processing events
runSupervisorOccupation :: RunStatistics -> !Float

-- | the fraction of the time the supervisor spent processing events while
--   inside the <tt>SupervisorMonad</tt>
runSupervisorMonadOccupation :: RunStatistics -> !Float

-- | the number of calls made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runNumberOfCalls :: RunStatistics -> !Int

-- | the average amount of time per call made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runAverageTimePerCall :: RunStatistics -> !Float

-- | the fraction of the total time that workers were occupied
runWorkerOccupation :: RunStatistics -> !Float

-- | statistics for how long it took for workers to obtain a workload
runWorkerWaitTimes :: RunStatistics -> !(FunctionOfTimeStatistics NominalDiffTime)

-- | statistics for the time needed to steal a workload from a worker
runStealWaitTimes :: RunStatistics -> !IndependentMeasurementsStatistics

-- | statistics for the number of workers waiting for a workload
runWaitingWorkerStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the number of available workloads waiting for a worker
runAvailableWorkloadStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the instantaneous rate at which workloads were
--   requested (using an exponentially decaying sum)
runInstantaneousWorkloadRequestRateStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | statistics for the instantaneous time needed for workloads to be
--   stolen (using an exponentially decaying weighted average)
runInstantaneousWorkloadStealTimeStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | A type that represents the reason why a run terminated.
data TerminationReason progress final_result

-- | the run was aborted with the given progress
Aborted :: progress -> TerminationReason progress final_result

-- | the run completed with the given final result
Completed :: final_result -> TerminationReason progress final_result

-- | the run failed with the given progress for the given reason
Failure :: progress -> String -> TerminationReason progress final_result

-- | A convenient type alias for the type of <a>TerminationReason</a>
--   associated with the given exploration mode.
type TerminationReasonFor exploration_mode = TerminationReason (ProgressFor exploration_mode) (FinalResultFor exploration_mode)

-- | Explore the given pure tree in parallel; the results in the leaves
--   will be summed up using the <a>Monoid</a> instance.
mainForExploreTree :: (Monoid result, Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration Identity IO (AllMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) result -> IO ()) -> (tree_configuration -> Tree result) -> result_monad ()

-- | Explore the given IO tree in parallel; the results in the leaves will
--   be summed up using the <a>Monoid</a> instance.
mainForExploreTreeIO :: (Monoid result, Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration IO IO (AllMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) result -> IO ()) -> (tree_configuration -> TreeIO result) -> result_monad ()

-- | Explore the given impure tree in parallel; the results in all of the
--   leaves will be summed up using the <a>Monoid</a> instance.
mainForExploreTreeImpure :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration m m (AllMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) result -> IO ()) -> (tree_configuration -> TreeT m result) -> result_monad ()

-- | Explore the given pure tree in parallel, stopping if a solution is
--   found.
mainForExploreTreeUntilFirst :: (Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration Identity IO (FirstMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> (tree_configuration -> Tree result) -> result_monad ()

-- | Explore the given IO tree in parallel, stopping if a solution is
--   found.
mainForExploreTreeIOUntilFirst :: (Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration IO IO (FirstMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> (tree_configuration -> TreeIO result) -> result_monad ()

-- | Explore the given impure tree in parallel, stopping if a solution is
--   found.
mainForExploreTreeImpureUntilFirst :: (Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration m m (FirstMode result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> (tree_configuration -> TreeT m result) -> result_monad ()

-- | Explore the given pure tree in parallel until the sum of results meets
--   the given condition.
mainForExploreTreeUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad) => (tree_configuration -> result -> Bool) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration Identity IO (FoundModeUsingPull result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> Tree result) -> result_monad ()

-- | Explore the given IO tree in parallel until the sum of results meets
--   the given condition.
mainForExploreTreeIOUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad) => (tree_configuration -> result -> Bool) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration IO IO (FoundModeUsingPull result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> TreeIO result) -> result_monad ()

-- | Explore the given impure tree in parallel until the sum of results
--   meets the given condition.
mainForExploreTreeImpureUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (tree_configuration -> result -> Bool) -> (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration m m (FoundModeUsingPull result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> TreeT m result) -> result_monad ()

-- | Explore the given pure tree in parallel until the sum of results meets
--   the given condition.
mainForExploreTreeUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad) => (tree_configuration -> result -> Bool) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration Identity IO (FoundModeUsingPush result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> Tree result) -> result_monad ()

-- | Explore the given IO tree in parallel until the sum of results meets
--   the given condition.
mainForExploreTreeIOUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad) => (tree_configuration -> result -> Bool) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration IO IO (FoundModeUsingPush result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> TreeIO result) -> result_monad ()

-- | Explore the given impure tree in parallel until the sum of results
--   meets the given condition.
mainForExploreTreeImpureUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (tree_configuration -> result -> Bool) -> (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration m m (FoundModeUsingPush result) -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> (tree_configuration -> TreeT m result) -> result_monad ()

-- | This is just like the previous functions, except that it is
--   generalized over all tree purities and exploration modes. (In fact,
--   the specialized functions are just wrappers around this function.)
genericMain :: (MonadIO result_monad, ResultFor exploration_mode ~ result, Serialize (ProgressFor exploration_mode)) => (tree_configuration -> ExplorationMode exploration_mode) -> Purity m n -> Driver result_monad (SharedConfiguration tree_configuration) SupervisorConfiguration m n exploration_mode -> Term tree_configuration -> TermInfo -> (tree_configuration -> RunOutcomeFor exploration_mode -> IO ()) -> (tree_configuration -> TreeT m result) -> result_monad ()

-- | Explore the given pure tree in parallel; the results in the leaves
--   will be summed up using the <a>Monoid</a> instance.
simpleMainForExploreTree :: (Monoid result, Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration ()) SupervisorConfiguration Identity IO (AllMode result) -> (RunOutcome (Progress result) result -> IO ()) -> Tree result -> result_monad ()

-- | Explore the given IO tree in parallel; the results in the leaves will
--   be summed up using the <a>Monoid</a> instance.
simpleMainForExploreTreeIO :: (Monoid result, Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration ()) SupervisorConfiguration IO IO (AllMode result) -> (RunOutcome (Progress result) result -> IO ()) -> TreeIO result -> result_monad ()

-- | Explore the given impure tree in parallel; the results in all of the
--   leaves will be summed up using the <a>Monoid</a> instance.
simpleMainForExploreTreeImpure :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration m m (AllMode result) -> (RunOutcome (Progress result) result -> IO ()) -> TreeT m result -> result_monad ()

-- | Explore the given pure tree in parallel, stopping if a solution is
--   found.
simpleMainForExploreTreeUntilFirst :: (Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration ()) SupervisorConfiguration Identity IO (FirstMode result) -> (RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> Tree result -> result_monad ()

-- | Explore the given tree in parallel in IO, stopping if a solution is
--   found.
simpleMainForExploreTreeIOUntilFirst :: (Serialize result, MonadIO result_monad) => Driver result_monad (SharedConfiguration ()) SupervisorConfiguration IO IO (FirstMode result) -> (RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> TreeIO result -> result_monad ()

-- | Explore the given impure tree in parallel, stopping if a solution is
--   found.
simpleMainForExploreTreeImpureUntilFirst :: (Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration m m (FirstMode result) -> (RunOutcome Checkpoint (Maybe (Progress result)) -> IO ()) -> TreeT m result -> result_monad ()

-- | Explore the given pure tree in parallel until the sum of results meets
--   the given condition.
simpleMainForExploreTreeUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad) => (result -> Bool) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration Identity IO (FoundModeUsingPull result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> Tree result -> result_monad ()

-- | Explore the given IO tree in parallel until the sum of results meets
--   the given condition.
simpleMainForExploreTreeIOUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad) => (result -> Bool) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration IO IO (FoundModeUsingPull result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> TreeIO result -> result_monad ()

-- | Explore the given impure tree in parallel until the sum of results
--   meets the given condition.
simpleMainForExploreTreeImpureUntilFoundUsingPull :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (result -> Bool) -> (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration m m (FoundModeUsingPull result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> TreeT m result -> result_monad ()

-- | Explore the given pure tree in parallel until the sum of results meets
--   the given condition.
simpleMainForExploreTreeUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad) => (result -> Bool) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration Identity IO (FoundModeUsingPush result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> Tree result -> result_monad ()

-- | Explore the given IO tree in parallel until the sum of results meets
--   the given condition.
simpleMainForExploreTreeIOUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad) => (result -> Bool) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration IO IO (FoundModeUsingPush result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> TreeIO result -> result_monad ()

-- | Explore the given impure tree in parallel until the sum of results
--   meets the given condition.
simpleMainForExploreTreeImpureUntilFoundUsingPush :: (Monoid result, Serialize result, MonadIO result_monad, Functor m, MonadIO m) => (result -> Bool) -> (forall β. m β -> IO β) -> Driver result_monad (SharedConfiguration ()) SupervisorConfiguration m m (FoundModeUsingPush result) -> (RunOutcome (Progress result) (Either result (Progress result)) -> IO ()) -> TreeT m result -> result_monad ()

-- | Converts a <a>SupervisorOutcome</a> to a <a>RunOutcome</a>.
extractRunOutcomeFromSupervisorOutcome :: Show worker_id => SupervisorOutcome fv ip worker_id -> RunOutcome ip fv

-- | Parse the command line options using the given term and term info (the
--   latter of which has the program name added to it); if successful
--   return the result, otherwise throw an exception.
mainParser :: Term α -> TermInfo -> IO α
instance (Eq progress, Eq final_result) => Eq (TerminationReason progress final_result)
instance (Show progress, Show final_result) => Show (TerminationReason progress final_result)
instance (Eq progress, Eq final_result) => Eq (RunOutcome progress final_result)
instance (Show progress, Show final_result) => Show (RunOutcome progress final_result)
instance ArgVal Priority
instance Serialize tree_configuration_1627942814 => Serialize (SharedConfiguration tree_configuration_1627942814)
instance Eq CheckpointConfiguration
instance Show CheckpointConfiguration
instance Eq LoggingConfiguration
instance Show LoggingConfiguration
instance Eq StatisticsConfiguration
instance Show StatisticsConfiguration
instance Eq SupervisorConfiguration
instance Show SupervisorConfiguration
instance Eq tree_configuration => Eq (SharedConfiguration tree_configuration)
instance Show tree_configuration => Show (SharedConfiguration tree_configuration)
instance Serialize LoggingConfiguration


-- | This module provides most of the common functionality needed to
--   implement a adapter where the number of workers can be adjusted during
--   the run.
module LogicGrowsOnTrees.Parallel.Common.Workgroup

-- | A <a>WorkgroupRequestQueueMonad</a> is a <a>RequestQueueMonad</a> but
--   with the additional ability to change the number of workers in the
--   system.
class RequestQueueMonad m => WorkgroupRequestQueueMonad m
changeNumberOfWorkersAsync :: WorkgroupRequestQueueMonad m => (Word -> Word) -> (Word -> IO ()) -> m ()

-- | This is the monad in which the adapter specific code is run.
type InnerMonad inner_state = StateT inner_state IO

-- | This data structure contains callbacks to be invoked when a message
--   has been received, depending on the kind of message.
data MessageForSupervisorReceivers exploration_mode worker_id
MessageForSupervisorReceivers :: (worker_id -> ProgressUpdate (ProgressFor exploration_mode) -> IO ()) -> (worker_id -> Maybe (StolenWorkload (ProgressFor exploration_mode)) -> IO ()) -> (worker_id -> String -> IO ()) -> (worker_id -> WorkerFinishedProgressFor exploration_mode -> IO ()) -> (worker_id -> IO ()) -> MessageForSupervisorReceivers exploration_mode worker_id

-- | to be called when a progress update has been received from a worker
receiveProgressUpdateFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> ProgressUpdate (ProgressFor exploration_mode) -> IO ()

-- | to be called when a (possibly) stolen workload has been received from
--   a worker
receiveStolenWorkloadFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> Maybe (StolenWorkload (ProgressFor exploration_mode)) -> IO ()

-- | to be called when a failure (with the given message) has been received
--   from a worker
receiveFailureFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> String -> IO ()

-- | to be called when a worker has finished with the given final progress
receiveFinishedFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> WorkerFinishedProgressFor exploration_mode -> IO ()

-- | to be called when a worker has quit the system and is no longer
--   available
receiveQuitFromWorker :: MessageForSupervisorReceivers exploration_mode worker_id -> worker_id -> IO ()

-- | The type of worker ids used by this module (an alias for <a>Int</a>).
type WorkerId = Int

-- | A set of callbacks invoked by the supervisor code in this module.
data WorkgroupCallbacks inner_state
WorkgroupCallbacks :: (WorkerId -> InnerMonad inner_state ()) -> (WorkerId -> Bool -> InnerMonad inner_state ()) -> ([WorkerId] -> InnerMonad inner_state ()) -> (WorkerId -> InnerMonad inner_state ()) -> (WorkerId -> InnerMonad inner_state ()) -> (WorkerId -> Workload -> InnerMonad inner_state ()) -> WorkgroupCallbacks inner_state

-- | create a worker with the given id
createWorker :: WorkgroupCallbacks inner_state -> WorkerId -> InnerMonad inner_state ()

-- | destroy the worker with the given id; ideally this should be
--   implemented by signaling the worker to quit and then waiting for an
--   acknowledgement
destroyWorker :: WorkgroupCallbacks inner_state -> WorkerId -> Bool -> InnerMonad inner_state ()

-- | destroy all of the workers in the given list in a manner that ensures
--   they all terminate promptly; this will be called at the end of the run
--   (successful or not)
killAllWorkers :: WorkgroupCallbacks inner_state -> [WorkerId] -> InnerMonad inner_state ()

-- | send a progress update request to the given worker
sendProgressUpdateRequestTo :: WorkgroupCallbacks inner_state -> WorkerId -> InnerMonad inner_state ()

-- | send a workload steal request to the given worker
sendWorkloadStealRequestTo :: WorkgroupCallbacks inner_state -> WorkerId -> InnerMonad inner_state ()

-- | send a workload to the given worker
sendWorkloadTo :: WorkgroupCallbacks inner_state -> WorkerId -> Workload -> InnerMonad inner_state ()

-- | This is the monad in which the workgroup controller will run.
newtype WorkgroupControllerMonad inner_state exploration_mode α
C :: RequestQueueReader exploration_mode WorkerId (WorkgroupStateMonad inner_state) α -> WorkgroupControllerMonad inner_state exploration_mode α
unwrapC :: WorkgroupControllerMonad inner_state exploration_mode α -> RequestQueueReader exploration_mode WorkerId (WorkgroupStateMonad inner_state) α

-- | Like <a>changeNumberOfWorkersAsync</a>, but it blocks until the number
--   of workers has been changed and returns the new number of workers.
changeNumberOfWorkers :: WorkgroupRequestQueueMonad m => (Word -> Word) -> m Word

-- | Request that the number of workers be set to the given amount,
--   invoking the given callback when this has been done.
setNumberOfWorkersAsync :: WorkgroupRequestQueueMonad m => Word -> IO () -> m ()

-- | Like <a>setNumberOfWorkersAsync</a>, but blocks until the number of
--   workers has been set to the desired value.
setNumberOfWorkers :: WorkgroupRequestQueueMonad m => Word -> m ()

-- | Explores a tree using a workgroup; this function is only intended to
--   be used by adapters where the number of workers can be changed on
--   demand.
runWorkgroup :: ExplorationMode exploration_mode -> inner_state -> (MessageForSupervisorReceivers exploration_mode WorkerId -> WorkgroupCallbacks inner_state) -> ProgressFor exploration_mode -> WorkgroupControllerMonad inner_state exploration_mode () -> IO (RunOutcomeFor exploration_mode)
instance Applicative (WorkgroupControllerMonad inner_state exploration_mode)
instance Functor (WorkgroupControllerMonad inner_state exploration_mode)
instance Monad (WorkgroupControllerMonad inner_state exploration_mode)
instance MonadCatchIO (WorkgroupControllerMonad inner_state exploration_mode)
instance MonadIO (WorkgroupControllerMonad inner_state exploration_mode)
instance RequestQueueMonad (WorkgroupControllerMonad inner_state exploration_mode)
instance WorkgroupRequestQueueMonad (WorkgroupControllerMonad inner_state exploration_mode)
instance HasExplorationMode (WorkgroupControllerMonad inner_state exploration_mode)


-- | This adapter implements parallelism by spawning multiple worker
--   threads, the number of which can be changed arbitrarily during the
--   run.
--   
--   NOTE: For the use of threads to results in parallelization, you need
--   to make sure that the number of capabilities is at least as large as
--   the largest number of worker threads you will be spawning. If you are
--   using the <a>driver</a>, then this will be taken care of for you. If
--   not, then you will need to either call <a>setNumCapabilities</a> (but
--   only to increase the number of threads in GHC 7.4, and not too often
--   as it may crash) or use the command-line argument <tt>+RTS -N#</tt>,
--   where <tt>#</tt> is the number of threads you want to run in parallel.
--   The <a>driver</a> takes care of this automatically by calling
--   <a>setNumCapabilities</a> a single time to set the number of
--   capabilities equal to the number of request threads (provided via. a
--   command-line argument).
module LogicGrowsOnTrees.Parallel.Adapter.Threads

-- | This is the driver for the threads adapter. The number of workers is
--   specified via. the (required) command-line option <a>-n</a>;
--   <a>setNumCapabilities</a> is called exactly once to make sure that
--   there is an equal number of capabilities.
driver :: Driver IO shared_configuration supervisor_configuration m n exploration_mode

-- | This is the monad in which the thread controller will run.
data ThreadsControllerMonad exploration_mode α

-- | Abort the supervisor.
abort :: RequestQueueMonad m => m ()

-- | Change the number of workers; the first argument is a map that
--   computes the new number of workers given the old number of workers,
--   and the second argument is a callback that will be invoked with the
--   new number of workers.
--   
--   See <a>changeNumberOfWorkers</a> for the synchronous version of this
--   request.
--   
--   If you just want to set the number of workers to some fixed value,
--   then see <a>setNumberOfWorkers</a> / <a>setNumberOfWorkersAsync</a>.
changeNumberOfWorkersAsync :: WorkgroupRequestQueueMonad m => (Word -> Word) -> (Word -> IO ()) -> m ()

-- | Like <a>changeNumberOfWorkersAsync</a>, but it blocks until the number
--   of workers has been changed and returns the new number of workers.
changeNumberOfWorkers :: WorkgroupRequestQueueMonad m => (Word -> Word) -> m Word

-- | Changes the number of a parallel workers to equal the number of
--   capabilities as reported by <a>getNumCapabilities</a>.
changeNumberOfWorkersToMatchCapabilities :: ThreadsControllerMonad exploration_mode ()

-- | Fork a new thread running in this monad; all controller threads are
--   automnatically killed when the run is finished.
fork :: RequestQueueMonad m => m () -> m ThreadId

-- | Request the current progress, invoking the given callback with the
--   result; see <a>getCurrentProgress</a> for the synchronous version.
getCurrentProgressAsync :: RequestQueueMonad m => (ProgressFor (ExplorationModeFor m) -> IO ()) -> m ()

-- | Like <a>getCurrentProgressAsync</a>, but blocks until the result is
--   ready.
getCurrentProgress :: RequestQueueMonad m => m (ProgressFor (ExplorationModeFor m))

-- | Request the number of workers, invoking the given callback with the
--   result; see <a>getNumberOfWorkers</a> for the synchronous version.
getNumberOfWorkersAsync :: RequestQueueMonad m => (Int -> IO ()) -> m ()

-- | Like <a>getNumberOfWorkersAsync</a>, but blocks until the result is
--   ready.
getNumberOfWorkers :: RequestQueueMonad m => m Int

-- | Request that a global progress update be performed, invoking the given
--   callback with the result; see <a>requestProgressUpdate</a> for the
--   synchronous version.
requestProgressUpdateAsync :: RequestQueueMonad m => (ProgressFor (ExplorationModeFor m) -> IO ()) -> m ()

-- | Like <a>requestProgressUpdateAsync</a>, but blocks until the progress
--   update has completed.
requestProgressUpdate :: RequestQueueMonad m => m (ProgressFor (ExplorationModeFor m))

-- | Request that the number of workers be set to the given amount,
--   invoking the given callback when this has been done.
setNumberOfWorkersAsync :: WorkgroupRequestQueueMonad m => Word -> IO () -> m ()

-- | Like <a>setNumberOfWorkersAsync</a>, but blocks until the number of
--   workers has been set to the desired value.
setNumberOfWorkers :: WorkgroupRequestQueueMonad m => Word -> m ()

-- | Sets the size of the workload buffer; for more information, see
--   <a>setWorkloadBufferSize</a> (which links to the
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a> module).
setWorkloadBufferSize :: RequestQueueMonad m => Int -> m ()

-- | A type that represents the outcome of a run.
data RunOutcome progress final_result
RunOutcome :: RunStatistics -> TerminationReason progress final_result -> RunOutcome progress final_result

-- | statistics gathered during the run, useful if the system is not
--   scaling with the number of workers as it should
runStatistics :: RunOutcome progress final_result -> RunStatistics

-- | the reason why the run terminated
runTerminationReason :: RunOutcome progress final_result -> TerminationReason progress final_result

-- | Statistics gathered about the run.
data RunStatistics
RunStatistics :: !UTCTime -> !UTCTime -> !NominalDiffTime -> !Float -> !Float -> !Int -> !Float -> !Float -> !(FunctionOfTimeStatistics NominalDiffTime) -> !IndependentMeasurementsStatistics -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Int) -> !(FunctionOfTimeStatistics Float) -> !(FunctionOfTimeStatistics Float) -> RunStatistics

-- | the start time of the run
runStartTime :: RunStatistics -> !UTCTime

-- | the end time of the run
runEndTime :: RunStatistics -> !UTCTime

-- | the wall time of the run
runWallTime :: RunStatistics -> !NominalDiffTime

-- | the fraction of the time the supervisor spent processing events
runSupervisorOccupation :: RunStatistics -> !Float

-- | the fraction of the time the supervisor spent processing events while
--   inside the <tt>SupervisorMonad</tt>
runSupervisorMonadOccupation :: RunStatistics -> !Float

-- | the number of calls made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runNumberOfCalls :: RunStatistics -> !Int

-- | the average amount of time per call made to functions in
--   <a>LogicGrowsOnTrees.Parallel.Common.Supervisor</a>
runAverageTimePerCall :: RunStatistics -> !Float

-- | the fraction of the total time that workers were occupied
runWorkerOccupation :: RunStatistics -> !Float

-- | statistics for how long it took for workers to obtain a workload
runWorkerWaitTimes :: RunStatistics -> !(FunctionOfTimeStatistics NominalDiffTime)

-- | statistics for the time needed to steal a workload from a worker
runStealWaitTimes :: RunStatistics -> !IndependentMeasurementsStatistics

-- | statistics for the number of workers waiting for a workload
runWaitingWorkerStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the number of available workloads waiting for a worker
runAvailableWorkloadStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Int)

-- | statistics for the instantaneous rate at which workloads were
--   requested (using an exponentially decaying sum)
runInstantaneousWorkloadRequestRateStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | statistics for the instantaneous time needed for workloads to be
--   stolen (using an exponentially decaying weighted average)
runInstantaneousWorkloadStealTimeStatistics :: RunStatistics -> !(FunctionOfTimeStatistics Float)

-- | A type that represents the reason why a run terminated.
data TerminationReason progress final_result

-- | the run was aborted with the given progress
Aborted :: progress -> TerminationReason progress final_result

-- | the run completed with the given final result
Completed :: final_result -> TerminationReason progress final_result

-- | the run failed with the given progress for the given reason
Failure :: progress -> String -> TerminationReason progress final_result

-- | Explore the pure tree and sum over all results.
exploreTree :: Monoid result => ThreadsControllerMonad (AllMode result) () -> Tree result -> IO (RunOutcome (Progress result) result)

-- | Like <a>exploreTree</a> but with a starting progress.
exploreTreeStartingFrom :: Monoid result => Progress result -> ThreadsControllerMonad (AllMode result) () -> Tree result -> IO (RunOutcome (Progress result) result)

-- | Like <a>exploreTree</a> but with the tree running in IO.
exploreTreeIO :: Monoid result => ThreadsControllerMonad (AllMode result) () -> TreeIO result -> IO (RunOutcome (Progress result) result)

-- | Like <a>exploreTreeIO</a> but with a starting progress.
exploreTreeIOStartingFrom :: Monoid result => Progress result -> ThreadsControllerMonad (AllMode result) () -> TreeIO result -> IO (RunOutcome (Progress result) result)

-- | Like <a>exploreTree</a> but with a generic impure tree.
exploreTreeT :: (Monoid result, MonadIO m) => (forall α. m α -> IO α) -> ThreadsControllerMonad (AllMode result) () -> TreeT m result -> IO (RunOutcome (Progress result) result)

-- | Like <a>exploreTreeT</a>, but with a starting progress.
exploreTreeTStartingFrom :: (Monoid result, MonadIO m) => (forall α. m α -> IO α) -> Progress result -> ThreadsControllerMonad (AllMode result) () -> TreeT m result -> IO (RunOutcome (Progress result) result)

-- | Explore the pure tree until a result has been found.
exploreTreeUntilFirst :: ThreadsControllerMonad (FirstMode result) () -> Tree result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Like <a>exploreTreeUntilFirst</a> but with a starting progress.
exploreTreeUntilFirstStartingFrom :: Checkpoint -> ThreadsControllerMonad (FirstMode result) () -> Tree result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Like <a>exploreTreeUntilFirst</a> but with the tree running in IO.
exploreTreeIOUntilFirst :: ThreadsControllerMonad (FirstMode result) () -> TreeIO result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Like <a>exploreTreeIOUntilFirst</a> but with a starting progress.
exploreTreeIOUntilFirstStartingFrom :: Checkpoint -> ThreadsControllerMonad (FirstMode result) () -> TreeIO result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Like <a>exploreTreeUntilFirst</a> but with a generic impure tree.
exploreTreeTUntilFirst :: MonadIO m => (forall α. m α -> IO α) -> ThreadsControllerMonad (FirstMode result) () -> TreeT m result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Like <a>exploreTreeTUntilFirst</a>, but with a starting progress.
exploreTreeTUntilFirstStartingFrom :: MonadIO m => (forall α. m α -> IO α) -> Checkpoint -> ThreadsControllerMonad (FirstMode result) () -> TreeT m result -> IO (RunOutcome Checkpoint (Maybe (Progress result)))

-- | Explore the pure tree until the sum of resuts meets a condition.
exploreTreeUntilFoundUsingPull :: Monoid result => (result -> Bool) -> ThreadsControllerMonad (FoundModeUsingPull result) () -> Tree result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPull</a> but with a starting
--   progress.
exploreTreeUntilFoundUsingPullStartingFrom :: Monoid result => (result -> Bool) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPull result) () -> Tree result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPull</a> but with the tree running
--   in IO.
exploreTreeIOUntilFoundUsingPull :: Monoid result => (result -> Bool) -> ThreadsControllerMonad (FoundModeUsingPull result) () -> TreeIO result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeIOUntilFoundUsingPull</a> but with a starting
--   progress.
exploreTreeIOUntilFoundUsingPullStartingFrom :: Monoid result => (result -> Bool) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPull result) () -> TreeIO result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPull</a> but with a generic impure
--   tree.
exploreTreeTUntilFoundUsingPull :: (Monoid result, MonadIO m) => (result -> Bool) -> (forall α. m α -> IO α) -> ThreadsControllerMonad (FoundModeUsingPull result) () -> TreeT m result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeTUntilFoundUsingPull</a> but with a starting
--   progress.
exploreTreeTUntilFoundUsingPullStartingFrom :: (Monoid result, MonadIO m) => (result -> Bool) -> (forall α. m α -> IO α) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPull result) () -> TreeT m result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Explore the pure tree until the sum of resuts meets a condition.
exploreTreeUntilFoundUsingPush :: Monoid result => (result -> Bool) -> ThreadsControllerMonad (FoundModeUsingPush result) () -> Tree result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPush</a>, but with a starting
--   result.
exploreTreeUntilFoundUsingPushStartingFrom :: Monoid result => (result -> Bool) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPush result) () -> Tree result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPush</a> but with the tree running
--   in IO.
exploreTreeIOUntilFoundUsingPush :: Monoid result => (result -> Bool) -> ThreadsControllerMonad (FoundModeUsingPush result) () -> TreeIO result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeIOUntilFoundUsingPush</a>, but with a starting
--   result.
exploreTreeIOUntilFoundUsingPushStartingFrom :: Monoid result => (result -> Bool) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPush result) () -> TreeIO result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeUntilFoundUsingPush</a> but with a generic impure
--   tree.
exploreTreeTUntilFoundUsingPush :: (Monoid result, MonadIO m) => (result -> Bool) -> (forall α. m α -> IO α) -> ThreadsControllerMonad (FoundModeUsingPush result) () -> TreeT m result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Like <a>exploreTreeTUntilFoundUsingPush</a>, but with a starting
--   progress.
exploreTreeTUntilFoundUsingPushStartingFrom :: (Monoid result, MonadIO m) => (result -> Bool) -> (forall α. m α -> IO α) -> Progress result -> ThreadsControllerMonad (FoundModeUsingPush result) () -> TreeT m result -> IO (RunOutcome (Progress result) (Either result (Progress result)))

-- | Explores the given tree using multiple threads to achieve parallelism.
--   
--   This function grants access to all of the functionality of this
--   adapter, but because its generality complicates its use (primarily the
--   fact that the types are dependent on the first parameter) you may find
--   it easier to use one of the specialized functions in the preceding
--   section.
runExplorer :: ExplorationMode exploration_mode -> Purity m n -> (ProgressFor exploration_mode) -> ThreadsControllerMonad exploration_mode () -> TreeT m (ResultFor exploration_mode) -> IO (RunOutcomeFor exploration_mode)
instance Applicative (ThreadsControllerMonad exploration_mode)
instance Functor (ThreadsControllerMonad exploration_mode)
instance Monad (ThreadsControllerMonad exploration_mode)
instance MonadCatchIO (ThreadsControllerMonad exploration_mode)
instance MonadIO (ThreadsControllerMonad exploration_mode)
instance RequestQueueMonad (ThreadsControllerMonad exploration_mode)
instance WorkgroupRequestQueueMonad (ThreadsControllerMonad exploration_mode)
instance HasExplorationMode (ThreadsControllerMonad exploration_mode)


-- | This module contains functions that let one easily implement the
--   worker side of an adapter under the assumption that the worker uses a
--   two-way communication channel with the supervisor for sending and
--   receiving messages. (Examples of when this is NOT the case is the
--   threads adapter, where you can communicate with the worker threads
--   directly, and the MPI adapter, which has communication primitives that
--   don't quite align with this setup.)
module LogicGrowsOnTrees.Parallel.Common.Process

-- | This exception is thrown when the connection has been lost.
data ConnectionLost
ConnectionLost :: ConnectionLost

-- | Runs a loop that continually fetches and reacts to messages from the
--   supervisor until the worker quits.
runWorker :: ExplorationMode exploration_mode -> Purity m n -> TreeT m (ResultFor exploration_mode) -> IO MessageForWorker -> (MessageForSupervisorFor exploration_mode -> IO ()) -> IO ()

-- | The same as <a>runWorker</a>, but it lets you provide handles through
--   which the messages will be sent and received. (Note that the reading
--   and writing handles might be the same.)
runWorkerUsingHandles :: (Serialize (ProgressFor exploration_mode), Serialize (WorkerFinishedProgressFor exploration_mode)) => ExplorationMode exploration_mode -> Purity m n -> TreeT m (ResultFor exploration_mode) -> Handle -> Handle -> IO ()


-- | This modules contains utility functions for constructing perfect trees
--   for use in some of the tests and examples.
module LogicGrowsOnTrees.Utils.PerfectTree

-- | Generate a perfectly balanced tree with the given leaf value, arity,
--   and leaf.
perfectTree :: MonadPlus m => α -> Word -> Word -> m α

-- | Like <a>perfectTree</a> but with <tt>WordSum 1</tt> at the leaves.
trivialPerfectTree :: MonadPlus m => Word -> Word -> m WordSum

-- | Computes the number of leaves in a perfect tree. It returns a value of
--   type <a>Word</a> so that it can be easily compared to the
--   <a>WordSum</a> value returned by the tree generators, but a
--   consequence of this is that it will overflow if the arity and/or depth
--   arguments are too large.
numberOfLeaves :: Word -> Word -> Word

-- | Newtype wrapper for arities that has an <a>ArgVal</a> instance that
--   enforces that the arity be at least 2.
newtype Arity
Arity :: Word -> Arity
getArity :: Arity -> Word

-- | Datatype representing the arity and depth of a tree, used for command
--   line argument processing (see
--   <a>makeArityAndDepthTermAtPositions</a>).
data ArityAndDepth
ArityAndDepth :: !Word -> !Word -> ArityAndDepth
arity :: ArityAndDepth -> !Word
depth :: ArityAndDepth -> !Word

-- | Constructs a configuration term that expects the arity and depth to be
--   at the given command line argument positions.
makeArityAndDepthTermAtPositions :: Int -> Int -> Term ArityAndDepth

-- | A convenience function used when you have an value of type
--   <a>Arity</a> for the arity of the tree rather than a value of type
--   <a>Word</a> and want to construct a value of type
--   <a>ArityAndDepth</a>.
formArityAndDepth :: Arity -> Word -> ArityAndDepth
instance Eq Arity
instance Show Arity
instance Eq ArityAndDepth
instance Show ArityAndDepth
instance ArgVal (Maybe Arity)
instance ArgVal Arity
