-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of language-related Yi libraries.
--   
@package yi-language
@version 0.2.0


-- | Colors and friends.
module Yi.Style

-- | Visual text attributes to be applied during layout.
data Attributes
Attributes :: !Color -> !Color -> !Bool -> !Bool -> !Bool -> !Bool -> Attributes
foreground :: Attributes -> !Color
background :: Attributes -> !Color

-- | The text should be show as "active" or "selected". This can be
--   implemented by reverse video on the terminal.
reverseAttr :: Attributes -> !Bool
bold :: Attributes -> !Bool
italic :: Attributes -> !Bool
underline :: Attributes -> !Bool
emptyAttributes :: Attributes

-- | The style is used to transform attributes by modifying one or more of
--   the visual text attributes.
type Style = Endo Attributes

-- | The UI type
data UIStyle
UIStyle :: Attributes -> Style -> Attributes -> Style -> Style -> Attributes -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> Style -> UIStyle

-- | ground attributes for the modeline
modelineAttributes :: UIStyle -> Attributes

-- | transformation of modeline in focus
modelineFocusStyle :: UIStyle -> Style

-- | ground attributes for the tabbar
tabBarAttributes :: UIStyle -> Attributes

-- | a tab that currently holds the focus
tabInFocusStyle :: UIStyle -> Style

-- | a tab that does not have the current focus
tabNotFocusedStyle :: UIStyle -> Style

-- | ground attributes for the main text views
baseAttributes :: UIStyle -> Attributes

-- | the selected portion
selectedStyle :: UIStyle -> Style

-- | empty file marker colours
eofStyle :: UIStyle -> Style

-- | indicates errors in text
errorStyle :: UIStyle -> Style

-- | search matches<i>paren matches</i>other hints
hintStyle :: UIStyle -> Style

-- | current search match
strongHintStyle :: UIStyle -> Style

-- | all comments
commentStyle :: UIStyle -> Style

-- | additional only for block comments
blockCommentStyle :: UIStyle -> Style

-- | applied to language keywords
keywordStyle :: UIStyle -> Style

-- | numbers
numberStyle :: UIStyle -> Style

-- | preprocessor directive (often in Haskell or C)
preprocessorStyle :: UIStyle -> Style

-- | constant strings
stringStyle :: UIStyle -> Style

-- | additional style for long strings
longStringStyle :: UIStyle -> Style

-- | type name (such as class in an OO language)
typeStyle :: UIStyle -> Style

-- | data constructor
dataConstructorStyle :: UIStyle -> Style

-- | style of import names
importStyle :: UIStyle -> Style

-- | builtin things, e.g. Array in JavaScript
builtinStyle :: UIStyle -> Style

-- | regular expressions
regexStyle :: UIStyle -> Style

-- | any standard variable (identifier)
variableStyle :: UIStyle -> Style

-- | infix operators
operatorStyle :: UIStyle -> Style

-- | Style of a quotation (e.g. in template haskell)
quoteStyle :: UIStyle -> Style

-- | stuff that's passed to the shell in a Makefile
makeFileAction :: UIStyle -> Style

-- | makefile rule headers
makeFileRuleHead :: UIStyle -> Style

-- | A StyleName determines what style to use, taking into account the set
--   of rendering preferences given by a <a>UIStyle</a>. Typically, style
--   names will be <a>Style</a>-valued field names of <a>UIStyle</a>.
type StyleName = UIStyle -> Style

-- | A style that sets the foreground.
withFg :: Color -> Style

-- | A style that sets the background.
withBg :: Color -> Style

-- | A style that sets the font to bold
withBd :: Bool -> Style

-- | A style that sets the style to underlined
withReverse :: Bool -> Style

-- | A style that sets the style to underlined
withUnderline :: Bool -> Style

-- | A style that sets the style to italics
withItlc :: Bool -> Style

-- | The identity transform.
defaultStyle :: StyleName
data Color
RGB :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> Color

-- | The system-default color of the engine used. e.g. in Gtk this should
--   pick whatever the user has chosen as default color (background or
--   forground depending on usage) for the text.
Default :: Color

-- | Convert a color to its text specification, as to be accepted by
--   XParseColor
colorToText :: Color -> String
black :: Color
yellow :: Color
brown :: Color
green :: Color
darkgreen :: Color
red :: Color
darkred :: Color
lightGrey :: Color
grey :: Color
darkblue :: Color
brightwhite :: Color
white :: Color
cyan :: Color
darkcyan :: Color
magenta :: Color
purple :: Color
blue :: Color
instance Eq Color
instance Ord Color
instance Show Color
instance Eq Attributes
instance Ord Attributes
instance Show Attributes

module Yi.Style.Library
type Theme = Proto UIStyle

-- | Abstract theme that provides useful defaults.
defaultTheme :: Theme

-- | A Theme inspired by the darkblue colorscheme of Vim.
darkBlueTheme :: Theme


-- | Various utility functions and instances used throughout Yi. Some of
--   the functions from the now-removed Yi.Prelude found a new home here.
module Yi.Utils
io :: MonadBase IO m => IO a -> m a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
trd3 :: (a, b, c) -> c
class SemiNum absolute relative | absolute -> relative
(+~) :: SemiNum absolute relative => absolute -> relative -> absolute
(-~) :: SemiNum absolute relative => absolute -> relative -> absolute
(~-) :: SemiNum absolute relative => absolute -> absolute -> relative

-- | As <a>nub</a>, but with O(n*log(n)) behaviour.
nubSet :: Ord a => [a] -> [a]

-- | As Map.adjust, but the combining function is applied strictly.
mapAdjust' :: Ord k => (a -> a) -> k -> Map k a -> Map k a

-- | Generalisation of <a>fromList</a> to arbitrary foldables.
mapFromFoldable :: (Foldable t, Ord k) => t (k, a) -> Map k a

-- | Alternative to groupBy.
--   
--   <pre>
--   groupBy' (\a b -&gt; abs (a - b) &lt;= 1) [1,2,3] = [[1,2,3]]
--   </pre>
--   
--   whereas
--   
--   <pre>
--   groupBy (\a b -&gt; abs (a - b) &lt;= 1) [1,2,3] = [[1,2],[3]]
--   </pre>
--   
--   TODO: Check in ghc 6.12 release if groupBy == groupBy'.
groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]
chain :: (a -> a -> Bool) -> [a] -> ([a], [a])

-- | Return the longest common prefix of a set of lists.
--   
--   <pre>
--   P(xs) === all (isPrefixOf (commonPrefix xs)) xs
--   length s &gt; length (commonPrefix xs) --&gt; not (all (isPrefixOf s) xs)
--   </pre>
commonPrefix :: Eq a => [[a]] -> [a]

-- | Finds the first element satisfying the predicate, and returns a zipper
--   pointing at it.
findPL :: (a -> Bool) -> [a] -> Maybe (PointedList a)

-- | Given a function which moves the focus from index A to index B, return
--   a function which swaps the elements at indexes A and B and then moves
--   the focus. See Yi.Editor.swapWinWithFirstE for an example.
swapFocus :: (PointedList a -> PointedList a) -> (PointedList a -> PointedList a)
makeClassyWithSuffix :: String -> Name -> Q [Dec]
addSuffix :: Name -> String -> [DefName]
makeLensesWithSuffix :: String -> Name -> Q [Dec]
instance (Eq k, Hashable k, Binary k, Binary v) => Binary (HashMap k v)


-- | Basic types useful everywhere we play with buffers.
module Yi.Buffer.Basic

-- | Direction of movement inside a buffer
data Direction
Backward :: Direction
Forward :: Direction
reverseDir :: Direction -> Direction

-- | reverse if Backward
mayReverse :: Direction -> [a] -> [a]

-- | <tt>direction</tt> is in the same style of <a>maybe</a> or
--   <a>either</a> functions, It takes one argument per direction
--   (backward, then forward) and a direction to select the output.
directionElim :: Direction -> a -> a -> a

-- | A mark in a buffer
newtype Mark
Mark :: Int -> Mark
markId :: Mark -> Int

-- | Reference to a buffer.
newtype BufferRef
BufferRef :: Int -> BufferRef

-- | A point in a buffer
newtype Point
Point :: Int -> Point
fromPoint :: Point -> Int

-- | Size of a buffer region
newtype Size
Size :: Int -> Size
fromSize :: Size -> Int

-- | Window references
newtype WindowRef
WindowRef :: Int -> WindowRef
unWindowRef :: WindowRef -> Int
instance Typeable Direction
instance Typeable Mark
instance Typeable BufferRef
instance Typeable Point
instance Typeable WindowRef
instance Eq Direction
instance Ord Direction
instance Show Direction
instance Bounded Direction
instance Enum Direction
instance Generic Direction
instance Eq Mark
instance Ord Mark
instance Show Mark
instance Binary Mark
instance Eq BufferRef
instance Ord BufferRef
instance Binary BufferRef
instance Num BufferRef
instance Eq Point
instance Ord Point
instance Enum Point
instance Bounded Point
instance Binary Point
instance Ix Point
instance Num Point
instance Real Point
instance Integral Point
instance Show Size
instance Eq Size
instance Ord Size
instance Num Size
instance Enum Size
instance Real Size
instance Integral Size
instance Binary Size
instance Eq WindowRef
instance Ord WindowRef
instance Enum WindowRef
instance Show WindowRef
instance Binary WindowRef
instance Datatype D1Direction
instance Constructor C1_0Direction
instance Constructor C1_1Direction
instance Default WindowRef
instance SemiNum Point Size
instance Show Point
instance Show BufferRef
instance Binary Direction

module Yi.Regex
data SearchOption

-- | Compile for matching that ignores char case
IgnoreCase :: SearchOption

-- | Compile for newline-insensitive matching
NoNewLine :: SearchOption

-- | Treat the input not as a regex but as a literal string to search for.
QuoteRegex :: SearchOption
makeSearchOptsM :: [SearchOption] -> String -> Either String SearchExp
data SearchExp
SearchExp :: String -> Regex -> Regex -> [SearchOption] -> SearchExp
seInput :: SearchExp -> String
seCompiled :: SearchExp -> Regex
seBackCompiled :: SearchExp -> Regex
seOptions :: SearchExp -> [SearchOption]
searchString :: SearchExp -> String
searchRegex :: Direction -> SearchExp -> Regex
emptySearch :: SearchExp

-- | The regular expression that matches nothing.
emptyRegex :: Regex

-- | Return an escaped (for parseRegex use) version of the string.
regexEscapeString :: String -> String
instance Eq SearchOption
instance Generic SearchOption
instance Datatype D1SearchOption
instance Constructor C1_0SearchOption
instance Constructor C1_1SearchOption
instance Constructor C1_2SearchOption
instance Plated Pattern
instance Binary SearchExp
instance Binary SearchOption


-- | This module defines the Region ADT
module Yi.Region

-- | The region data type. The region is semi open: it includes the start
--   but not the end bound. This allows simpler region-manipulation
--   algorithms. Invariant : regionStart r &lt;= regionEnd r
data Region

-- | The empty region
emptyRegion :: Region
regionIsEmpty :: Region -> Bool

-- | Construct a region from its bounds, emacs style: the right bound is
--   excluded
mkRegion :: Point -> Point -> Region
mkRegion' :: Direction -> Point -> Point -> Region
mkSizeRegion :: Point -> Size -> Region
regionStart :: Region -> Point
regionEnd :: Region -> Point
regionSize :: Region -> Size
regionDirection :: Region -> Direction

-- | True if the given point is inside the given region.
inRegion :: Point -> Region -> Bool

-- | True if the given point is inside the given region or at the end of
--   it.
nearRegion :: Point -> Region -> Bool

-- | Returns if a region (1st arg) is included in another (2nd arg)
includedRegion :: Region -> Region -> Bool
fmapRegion :: (Point -> Point) -> Region -> Region

-- | Take the intersection of two regions
intersectRegion :: Region -> Region -> Region

-- | Take the union of two regions (including what is between them)
unionRegion :: Region -> Region -> Region
regionFirst :: Region -> Point
regionLast :: Region -> Point
regionsOverlap :: Bool -> Region -> Region -> Bool
instance Typeable Region
instance Generic Region
instance Datatype D1Region
instance Constructor C1_0Region
instance Selector S1_0_0Region
instance Selector S1_0_1Region
instance Selector S1_0_2Region
instance Show Region
instance Binary Region


-- | This module defines a common interface for syntax-awareness.
--   
--   There have been many tens of wasted hours in this and lexer modules.
--   This note is to commemorate those who have fallen in battle.
module Yi.Syntax

-- | The main type of syntax highlighters. This record type combines all
--   the required functions, and is parametrized on the type of the
--   internal state.
data Highlighter cache syntax
SynHL :: cache -> (Scanner Point Char -> Point -> cache -> cache) -> (cache -> WindowRef -> syntax) -> (Map WindowRef Region -> cache -> cache) -> Highlighter cache syntax

-- | The start state for the highlighter.
hlStartState :: Highlighter cache syntax -> cache
hlRun :: Highlighter cache syntax -> Scanner Point Char -> Point -> cache -> cache
hlGetTree :: Highlighter cache syntax -> cache -> WindowRef -> syntax

-- | focus at a given point, and return the coresponding node. (hint -- the
--   root can always be returned, at the cost of performance.)
hlFocus :: Highlighter cache syntax -> Map WindowRef Region -> cache -> cache
data Cache state result
data Scanner st a
Scanner :: st -> (st -> Point) -> a -> (st -> [(st, a)]) -> Scanner st a

-- | Initial state
scanInit :: Scanner st a -> st

-- | How far did the scanner look to produce this intermediate state? The
--   state can be reused as long as nothing changes before that point.
scanLooked :: Scanner st a -> st -> Point
scanEmpty :: Scanner st a -> a

-- | Running function returns a list of results and intermediate states.
--   Note: the state is the state <i>before</i> producing the result in the
--   second component.
scanRun :: Scanner st a -> st -> [(st, a)]
data ExtHL syntax
ExtHL :: (Highlighter cache syntax) -> ExtHL syntax
noHighlighter :: Highlighter () syntax

-- | This takes as input a scanner that returns the "full" result at each
--   element in the list; perhaps in a different form for the purpose of
--   incremental-lazy eval.
mkHighlighter :: Show state => (Scanner Point Char -> Scanner state result) -> Highlighter (Cache state result) result
skipScanner :: Int -> Scanner st a -> Scanner st a
emptyFileScan :: Scanner Point Char

-- | A point in a buffer
newtype Point
Point :: Int -> Point
fromPoint :: Point -> Int

-- | Size of a buffer region
newtype Size
Size :: Int -> Size
fromSize :: Size -> Int
type Length = Int
type Stroke = Span StyleName
data Span a
Span :: !Point -> !a -> !Point -> Span a
spanBegin :: Span a -> !Point
spanContents :: Span a -> !a
spanEnd :: Span a -> !Point
instance Show a => Show (Span a)
instance Functor Span
instance Foldable Span
instance Traversable Span
instance Functor (Scanner st)


-- | Utilities to turn a lexer generated by Alex into a <a>Scanner</a> that
--   can be used by Yi. Most lexers will use the types defined here. Some
--   things are exported for use by lexers themselves through the use of
--   <tt>Yi<i>Lexers</i>common.hsinc</tt>.
module Yi.Lexer.Alex

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
type Byte = Word8
type IndexedStr = [(Point, Char)]
type AlexInput = (Char, [Byte], IndexedStr)
type Action hlState token = IndexedStr -> hlState -> (hlState, token)

-- | Lexer state
data AlexState lexerState
AlexState :: lexerState -> !Point -> !Posn -> AlexState lexerState
stLexer :: AlexState lexerState -> lexerState
lookedOffset :: AlexState lexerState -> !Point
stPosn :: AlexState lexerState -> !Posn
data Tok t
Tok :: t -> Size -> Posn -> Tok t
tokT :: Tok t -> t
tokLen :: Tok t -> Size
tokPosn :: Tok t -> Posn
tokToSpan :: Tok t -> Span t
tokFromT :: t -> Tok t
tokBegin :: Tok t -> Point
tokEnd :: Tok t -> Point
data Posn
Posn :: !Point -> !Int -> !Int -> Posn
posnOfs :: Posn -> !Point
posnLine :: Posn -> !Int
posnCol :: Posn -> !Int
startPosn :: Posn
moveStr :: Posn -> IndexedStr -> Posn
moveCh :: Posn -> Char -> Posn
alexGetChar :: AlexInput -> Maybe (Char, AlexInput)
alexGetByte :: AlexInput -> Maybe (Word8, AlexInput)
alexCollectChar :: AlexInput -> [Char]
alexInputPrevChar :: AlexInput -> Char

-- | Return a constant token
actionConst :: token -> Action lexState token

-- | Return a constant token, and modify the lexer state
actionAndModify :: (lexState -> lexState) -> token -> Action lexState token

-- | Convert the parsed string into a token, and also modify the lexer
--   state
actionStringAndModify :: (s -> s) -> (String -> token) -> Action s token

-- | Convert the parsed string into a token
actionStringConst :: (String -> token) -> Action lexState token
type ASI s = (AlexState s, AlexInput)

-- | Function to (possibly) lex a single token and give us the remaining
--   input.
type TokenLexer l s t i = (l s, i) -> Maybe (t, (l s, i))

-- | Handy alias
type CharScanner = Scanner Point Char

-- | Generalises lexers. This allows us to easily use lexers which don't
--   want to be cornered into the types we have predefined here and use in
--   <tt>common.hsinc</tt>.
data Lexer l s t i
Lexer :: TokenLexer l s t i -> (s -> Point -> Posn -> l s) -> (Char -> [(Point, Char)] -> i) -> (l s -> Point) -> (l s -> Posn) -> t -> s -> Lexer l s t i
_step :: Lexer l s t i -> TokenLexer l s t i
_starting :: Lexer l s t i -> s -> Point -> Posn -> l s
_withChars :: Lexer l s t i -> Char -> [(Point, Char)] -> i
_looked :: Lexer l s t i -> l s -> Point
_statePosn :: Lexer l s t i -> l s -> Posn
_lexEmpty :: Lexer l s t i -> t
_startingState :: Lexer l s t i -> s

-- | Just like <a>Lexer</a> but also knows how to turn its tokens into
--   <a>StyleName</a>s.
data StyleLexer l s t i
StyleLexer :: (t -> StyleName) -> Lexer l s (Tok t) i -> StyleLexer l s t i
_tokenToStyle :: StyleLexer l s t i -> t -> StyleName
_styleLexer :: StyleLexer l s t i -> Lexer l s (Tok t) i

-- | <a>StyleLexer</a> over <a>ASI</a>.
type StyleLexerASI s t = StyleLexer AlexState s t AlexInput

-- | Defines a <a>Lexer</a> for <a>ASI</a>. This exists to make using the
--   new <a>lexScanner</a> easier if you're using <a>ASI</a> as all our
--   lexers do today, 23-08-2014.
commonLexer :: (ASI s -> Maybe (Tok t, ASI s)) -> s -> Lexer AlexState s (Tok t) AlexInput

-- | Combine a character scanner with a lexer to produce a token scanner.
--   May be used together with <tt>mkHighlighter</tt> to produce a
--   <a>Highlighter</a>, or with <tt>linearSyntaxMode</tt> to produce a
--   <tt>Mode</tt>.
lexScanner :: Lexer l s t i -> CharScanner -> Scanner (l s) t

-- | unfold lexer into a function that returns a stream of (state, token)
unfoldLexer :: ((state, input) -> Maybe (token, (state, input))) -> (state, input) -> [(state, token)]
posnOfsA :: Lens' Posn Point
posnLineA :: Lens' Posn Int
posnColA :: Lens' Posn Int
tokTA :: Lens' (Tok t_alXu) t_alXu
tokPosnA :: Lens' (Tok t_alXu) Posn
tokLenA :: Lens' (Tok t_alXu) Size
withChars :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) (Char -> [(Point, Char)] -> i_alXo)
step :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) (TokenLexer l_alXl s_alXm t_alXn i_alXo)
statePosn :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) (l_alXl s_alXm -> Posn)
startingState :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) s_alXm
starting :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) (s_alXm -> Point -> Posn -> l_alXl s_alXm)
looked :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) (l_alXl s_alXm -> Point)
lexEmpty :: Lens' (Lexer l_alXl s_alXm t_alXn i_alXo) t_alXn
tokenToStyle :: Lens' (StyleLexer l_alXh s_alXi t_alXj i_alXk) (t_alXj -> StyleName)
styleLexer :: Lens (StyleLexer l_alXh s_alXi t_alXj i_alXk) (StyleLexer l_amou s_amov t_alXj i_amow) (Lexer l_alXh s_alXi (Tok t_alXj) i_alXk) (Lexer l_amou s_amov (Tok t_alXj) i_amow)
(+~) :: SemiNum absolute relative => absolute -> relative -> absolute
(~-) :: SemiNum absolute relative => absolute -> absolute -> relative

-- | Size of a buffer region
newtype Size
Size :: Int -> Size
fromSize :: Size -> Int
type Stroke = Span StyleName
instance Eq Posn
instance Ix Posn
instance Functor Tok
instance Show lexerState => Show (AlexState lexerState)
instance Show Posn
instance Ord Posn
instance Show t => Show (Tok t)
instance Eq (Tok a)

module Yi.Lexer.Abella
lexer :: StyleLexerASI HlState Token
tokenToText :: Token -> Maybe String
type TT = Tok Token
isComment :: Token -> Bool
data Token
Number :: Token
VarIdent :: Token
ConsIdent :: Token
Reserved :: !Reserved -> Token
ReservedOp :: !ReservedOp -> Token
CommentLine :: Token
Skip :: Token
Unrecognized :: Token
type HlState = Int
data Reserved
Forall :: Reserved
Exists :: Reserved
Other :: Reserved
data ReservedOp
Or :: ReservedOp
And :: ReservedOp
BackSlash :: ReservedOp
RightArrow :: ReservedOp
DoubleRightArrow :: ReservedOp
Dot :: ReservedOp
OtherOp :: ReservedOp
instance Eq Reserved
instance Show Reserved
instance Eq ReservedOp
instance Show ReservedOp
instance Eq Token
instance Show Token
instance Functor AlexLastAcc

module Yi.Lexer.Cabal
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Clojure
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Compilation
lexer :: StyleLexerASI HlState Token
data Token
Report :: String -> Int -> Int -> String -> Token
Text :: String -> Token
instance Show Token
instance Functor AlexLastAcc

module Yi.Lexer.GNUMake
lexer :: StyleLexerASI HlState Token
instance Show HlState
instance Functor AlexLastAcc

module Yi.Lexer.GitCommit
lexer :: StyleLexerASI HlState Token
type Token = StyleName
instance Show HlState
instance Eq HlState
instance Functor AlexLastAcc

module Yi.Lexer.Haskell
initState :: HlState

-- | Scan one token. Return (maybe) a token and a new state.
alexScanToken :: (AlexState HlState, AlexInput) -> Maybe (Tok Token, (AlexState HlState, AlexInput))
tokenToStyle :: Token -> StyleName
tokenToText :: Token -> Maybe String
type TT = Tok Token
isErrorTok :: Token -> Bool
isSpecial :: String -> Token -> Bool
startsLayout :: Token -> Bool
isComment :: Token -> Bool
data Token
Number :: Token
CharTok :: Token
StringTok :: Token
VarIdent :: Token
ConsIdent :: Token
Reserved :: !ReservedType -> Token
ReservedOp :: !OpType -> Token
Special :: Char -> Token
ConsOperator :: String -> Token
Operator :: String -> Token
Comment :: !CommentType -> Token
THQuote :: Token
CppDirective :: Token
Unrecognized :: Token
type HlState = Int
data CommentType
Open :: CommentType
Close :: CommentType
Text :: CommentType
Line :: CommentType
data ReservedType
Hiding :: ReservedType
Qualified :: ReservedType
As :: ReservedType
Import :: ReservedType
Data :: ReservedType
NewType :: ReservedType
Type :: ReservedType
Where :: ReservedType
Let :: ReservedType
In :: ReservedType
Do :: ReservedType
Of :: ReservedType
OtherLayout :: ReservedType
Deriving :: ReservedType
Module :: ReservedType
Forall :: ReservedType
Other :: ReservedType
Class :: ReservedType
Instance :: ReservedType
data OpType
Pipe :: OpType
Equal :: OpType
BackSlash :: OpType
LeftArrow :: OpType
RightArrow :: OpType
DoubleRightArrow :: OpType
DoubleColon :: OpType
DoubleDot :: OpType
Arobase :: OpType
Tilda :: OpType
instance Eq CommentType
instance Show CommentType
instance Eq ReservedType
instance Show ReservedType
instance Eq OpType
instance Show OpType
instance Eq Token
instance Show Token
instance Functor AlexLastAcc

module Yi.Lexer.JSON
lexer :: StyleLexerASI HlState Token
type Token = StyleName
instance Functor AlexLastAcc

module Yi.Lexer.JavaScript
initState :: HlState

-- | Scan one token. Return (maybe) a token and a new state.
alexScanToken :: (AlexState HlState, AlexInput) -> Maybe (Tok Token, (AlexState HlState, AlexInput))

-- | Takes a <a>Token</a> and returns a style to be used for that type of
--   token.
--   
--   TODO: The <a>elem</a> check is potentially unnecessarily slow. We
--   could split the Const constructor into two different ones, one for
--   builtins and one for others.
tokenToStyle :: Token -> UIStyle -> Style
type TT = Tok Token

-- | The different tokens.
data Token
Unknown :: Token
Res :: !Reserved -> Token
Str :: !String -> Token
Rex :: !String -> Token
Op :: !Operator -> Token
Special :: !Char -> Token
Number :: !String -> Token
ValidName :: !String -> Token
Comment :: !CommentType -> Token
Const :: !String -> Token

-- | The constructors for <tt>Reserved</tt> have an apostrophe as a suffix
--   because <tt>Default</tt> is already used. Also note that
--   <tt>Undefined'</tt> is not intended as some sort of "backup" reserved
--   word for things we don't care about -- it really means the "undefined"
--   built-in in JavaScript.
data Reserved
Break' :: Reserved
Case' :: Reserved
Catch' :: Reserved
Continue' :: Reserved
Default' :: Reserved
Delete' :: Reserved
Do' :: Reserved
Else' :: Reserved
Finally' :: Reserved
For' :: Reserved
Function' :: Reserved
If' :: Reserved
In' :: Reserved
InstanceOf' :: Reserved
New' :: Reserved
Return' :: Reserved
Switch' :: Reserved
This' :: Reserved
Throw' :: Reserved
Try' :: Reserved
TypeOf' :: Reserved
Var' :: Reserved
Void' :: Reserved
While' :: Reserved
With' :: Reserved
True' :: Reserved
False' :: Reserved
Null' :: Reserved
Undefined' :: Reserved

-- | The constructors for <tt>Operator</tt> have an apostrophe as a suffix
--   because e.g. <tt>LT</tt> is already used by <tt>Prelude</tt>.
data Operator
Add' :: Operator
Subtract' :: Operator
Multiply' :: Operator
Divide' :: Operator
Modulo' :: Operator
Increment' :: Operator
Decrement' :: Operator
Assign' :: Operator
AddAssign' :: Operator
SubtractAssign' :: Operator
MultiplyAssign' :: Operator
DivideAssign' :: Operator
ModuloAssign' :: Operator
Equals' :: Operator
NotEquals' :: Operator
GT' :: Operator
GTE' :: Operator
LT' :: Operator
LTE' :: Operator
EqualsType' :: Operator
NotEqualsType' :: Operator
And' :: Operator
Or' :: Operator
Not' :: Operator
BitAnd' :: Operator
BitOr' :: Operator
BitXor' :: Operator
LeftShift' :: Operator
RightShift' :: Operator
RightShiftZ' :: Operator
BitNot' :: Operator
Qualify' :: Operator

-- | <tt>HlState</tt> is 0 when outside of a multi-line comment and -1 when
--   inside one.
type HlState = Int

-- | Prefix operators. NOTE: Add' is also a valid prefix operator, but
--   since it's completely useless in the real world, we don't care about
--   it here. Doing this makes parsing much, much easier.
prefixOperators :: [Operator]

-- | Infix operators.
infixOperators :: [Operator]

-- | Postfix operators.
postfixOperators :: [Operator]
instance Show CommentType
instance Eq CommentType
instance Show Reserved
instance Eq Reserved
instance Show Operator
instance Eq Operator
instance Show Token
instance Eq Token
instance Functor AlexLastAcc

module Yi.Lexer.Latex
initState :: HlState

-- | Scan one token. Return (maybe) a token and a new state.
alexScanToken :: (AlexState HlState, AlexInput) -> Maybe (Tok Token, (AlexState HlState, AlexInput))
data Token
Comment :: Token
Text :: Token
Special :: !Char -> Token
Command :: !String -> Token
Begin :: !String -> Token
End :: !String -> Token
NewCommand :: Token
type HlState = Int
tokenToText :: Token -> Maybe [Char]
instance Eq Token
instance Show Token
instance Ord Token
instance Functor AlexLastAcc

module Yi.Lexer.LiterateHaskell
initState :: HlState

-- | Scan one token. Return (maybe) a token and a new state.
alexScanToken :: (AlexState HlState, AlexInput) -> Maybe (Tok Token, (AlexState HlState, AlexInput))
data HlState
instance Eq HlState
instance Show HlState
instance Functor AlexLastAcc

module Yi.Lexer.OCaml
lexer :: StyleLexerASI HlState Token
data Token
Number :: Token
CharTok :: Token
StringTok :: Token
VarIdent :: Token
ConsIdent :: Token
IndentReserved :: Token
Reserved :: Token
ReservedOp :: Token
Special :: Char -> Token
ConsOperator :: Token
Operator :: Token
Comment :: Token
instance Eq Token
instance Show Token
instance Functor AlexLastAcc

module Yi.Lexer.Ott
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.SVNCommit
lexer :: StyleLexerASI HlState Token
instance Show HlState
instance Functor AlexLastAcc

module Yi.Lexer.Whitespace
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.C
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Cplusplus
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Java
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.ObjectiveC
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Perl
lexer :: StyleLexerASI HlState Token
instance Show HlState
instance Functor AlexLastAcc

module Yi.Lexer.Python
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.R
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Ruby
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc

module Yi.Lexer.Srmc
lexer :: StyleLexerASI HlState Token
instance Functor AlexLastAcc
