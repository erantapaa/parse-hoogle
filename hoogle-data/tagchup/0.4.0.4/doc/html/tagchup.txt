-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | alternative package for processing of tag soups
--   
@package tagchup
@version 0.4.0.4

module Text.HTML.Tagchup.Tag

-- | An HTML element, a document is <tt>[T]</tt>. There is no requirement
--   for <a>Open</a> and <a>Close</a> to match.
--   
--   The type parameter <tt>string</tt> lets you choose between
--   <tt>[Char]</tt> for interpreted HTML entity references and
--   <tt>[HTMLChar.T]</tt> for uninterpreted HTML entities. You will most
--   oftenly want plain <tt>Char</tt>, since <tt>HTMLChar.T</tt> is only
--   necessary if you want to know, whether a non-ASCII character was
--   encoded as HTML entity or as non-ASCII Unicode character.
data T name string

-- | An open tag with <a>T</a>s in their original order.
Open :: (Name name) -> [T name string] -> T name string

-- | A closing tag
Close :: (Name name) -> T name string

-- | A text node, guaranteed not to be the empty string
Text :: string -> T name string

-- | A comment
Comment :: String -> T name string

-- | A tag like <tt>&lt;!DOCTYPE ...&gt;</tt>
Special :: (Name name) -> String -> T name string

-- | A tag like <tt>&lt;?xml ...&gt;</tt>
Processing :: (Name name) -> (T name string) -> T name string

-- | Mark a syntax error in the input file
Warning :: String -> T name string
newtype Name ident :: * -> *
Name :: ident -> Name ident
mapName :: (Name name0 -> Name name1) -> (Name name0 -> Name name1) -> T name0 string -> T name1 string
open :: Name name -> [T name string] -> T name string

-- | Test if a <a>T</a> is a <a>Open</a>
isOpen :: T name string -> Bool
maybeOpen :: T name string -> Maybe (Name name, [T name string])
close :: Name name -> T name string

-- | Test if a <a>T</a> is a <a>Close</a>
isClose :: T name string -> Bool
maybeClose :: T name string -> Maybe (Name name)
text :: string -> T name string

-- | Test if a <a>T</a> is a <a>Text</a>
isText :: T name string -> Bool

-- | Extract the string from within <a>Text</a>, otherwise <a>Nothing</a>
maybeText :: T name string -> Maybe string

-- | Extract all text content from tags (similar to Verbatim found in
--   HaXml)
innerText :: Monoid string => [T name string] -> string
comment :: String -> T name string
isComment :: T name string -> Bool
maybeComment :: T name string -> Maybe String
special :: Name name -> String -> T name string
isSpecial :: T name string -> Bool
maybeSpecial :: T name string -> Maybe (Name name, String)
cdata :: Tag name => String -> T name string
isCData :: Tag name => T name string -> Bool
maybeCData :: Tag name => T name string -> Maybe String
processing :: Name name -> T name string -> T name string
isProcessing :: T name string -> Bool
maybeProcessing :: T name string -> Maybe (Name name, T name string)
warning :: String -> T name string
isWarning :: T name string -> Bool
maybeWarning :: T name string -> Maybe String
formatOpen :: (Tag name, Attribute name, C string) => Bool -> Name name -> [T name string] -> ShowS
formatClose :: Tag name => Name name -> ShowS

-- | Replace CDATA sections by plain text.
textFromCData :: (Tag name, C char) => T name [char] -> T name [char]

-- | Merge adjacent Text sections.
concatTexts :: Monoid string => [T name string] -> [T name string]

-- | Modify content of a Text or a CDATA part.
mapText :: Tag name => (String -> String) -> T name String -> T name String
mapTextA :: (Tag name, Applicative f) => (String -> f String) -> T name String -> f (T name String)
instance (Show name, Show string, Attribute name) => Show (T name string)
instance (Eq name, Eq string) => Eq (T name string)
instance (Ord name, Ord string) => Ord (T name string)
instance (Tag name, Attribute name, C string) => C (T name string)
instance Traversable (T name)
instance Foldable (T name)
instance Functor (T name)


-- | Convert a tag soup to its text representation respecting various
--   conventions for merging open and close tags.
module Text.HTML.Tagchup.Format

-- | All tags are formatted as they are.
xml :: (Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | Adjacent corresponding open and close tags are merged to a
--   self-closing tag. E.g. <tt><a>a</a><a>/a</a></tt> becomes
--   <tt><a>a/</a></tt>.
xmlCondensed :: (Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | All tags that are defined being self-closing by the HTML standard are
--   formatted only as open tag. E.g. <tt><a>br</a></tt>.
html :: (Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | All tags that are defined being self-closing by the XHTML standard are
--   formatted as self-closing open tag. E.g. <tt><a>br/</a></tt>.
xhtml :: (Tag name, Attribute name, C string) => [T name string] -> ShowS

-- | If the first tag is <tt><a>...?</a></tt> then format in XHTML style,
--   else in HTML style.
htmlOrXhtml :: (Tag name, Attribute name, C string) => [T name string] -> ShowS

module Text.HTML.Tagchup.Tag.Match
ignore :: a -> Bool

-- | match an opening tag
open :: (Name name -> Bool) -> ([T name string] -> Bool) -> T name string -> Bool

-- | match an closing tag
close :: (Name name -> Bool) -> T name string -> Bool

-- | match a text
text :: (string -> Bool) -> T name string -> Bool
comment :: (String -> Bool) -> T name string -> Bool
special :: (Name name -> Bool) -> (String -> Bool) -> T name string -> Bool

-- | match a opening tag's name literally
openLit :: Tag name => String -> ([T name string] -> Bool) -> T name string -> Bool

-- | match a closing tag's name literally
closeLit :: Tag name => String -> T name string -> Bool
openAttrLit :: (Attribute name, Tag name, Eq string) => String -> String -> string -> T name string -> Bool

-- | Match a tag with given name, that contains an attribute with given
--   name, that satisfies a predicate. If an attribute occurs multiple
--   times, all occurrences are checked.
openAttrNameLit :: (Attribute name, Tag name) => String -> String -> (string -> Bool) -> T name string -> Bool

-- | Check whether the <a>T</a> is <a>Open</a> and matches the given name
openNameLit :: Tag name => String -> T name string -> Bool

-- | Check whether the <a>T</a> is <a>Close</a> and matches the given name
closeNameLit :: Tag name => String -> T name string -> Bool

module Text.HTML.Tagchup.Process
type Encoding = String

-- | should be [Word8]
type Encoded = String
evalDecodeAdaptive :: State (Encoded -> String) a -> a

-- | Selects a decoder dynamically according to xml-encoding and
--   meta-http-equiv tags. The <tt>?xml</tt> tag should only appear at the
--   beginning of a document, but we respect it at every occurence.
--   
--   <pre>
--   import qualified Text.XML.HXT.DOM.Unicode as Unicode
--   </pre>
--   
--   <pre>
--   evalDecodeAdaptive .
--   decodeAdaptive
--      (maybe Unicode.latin1ToUnicode (fst.) .
--       Unicode.getDecodingFct)
--   </pre>
decodeAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> [T name [T]] -> State (Encoded -> String) [T name String]

-- | <tt>decodeTagAdaptive decoderSelector tag</tt> generates a state
--   monad, with a decoder as state. It decodes encoding specific byte
--   sequences using the current decoder and XML references using a fixed
--   table.
decodeTagAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> T name [T] -> State (Encoded -> String) (T name String)

-- | Check whether the first tag is an <tt>xml</tt> processing instruction
--   tag and return the value of its <tt>encoding</tt> attribute.
getXMLEncoding :: (Tag name, Attribute name) => [T name String] -> Maybe String

-- | Rather the same as <tt>wraxml:HTML.Tree.findMetaEncoding</tt>
findMetaEncoding :: (Tag name, Attribute name) => [T name String] -> Maybe String

-- | Extract META tags which contain HTTP-EQUIV attribute and present these
--   values like HTTP headers.
getMetaHTTPHeaders :: (Tag name, Attribute name) => [T name string] -> [(string, string)]
getHeadTags :: (Tag name, Attribute name) => [T name string] -> [T name string]

-- | Modify attributes and tags of certain parts. For limitations, see
--   <a>parts</a>.
partAttrs :: Tag name => (Name name -> Bool) -> (([T name string], [T name string]) -> ([T name string], [T name string])) -> [T name string] -> [T name string]

-- | Extract parts from the tag soup that are enclosed in corresponding
--   open and close tags. If a close tag is missing, the soup end is
--   considered as end of the part. However nested tags are not supported,
--   e.g. in <tt><a>a</a><a>a</a><a>/a</a><a>/a</a></tt> the second
--   <tt><a>a</a></tt> is considered to be enclosed in the first
--   <tt><a>a</a></tt> and the first <tt><a>/a</a></tt> and the second
--   <tt><a>/a</a></tt> is ignored.
parts :: Tag name => (Name name -> Bool) -> [T name string] -> [Either ((Name name, [T name string]), [T name string]) [T name string]]

module Text.HTML.Tagchup.PositionTag
data T name string
Cons :: T -> T name string -> T name string
position_ :: T name string -> T
tag_ :: T name string -> T name string
cons :: T -> T name string -> T name string
position :: T (T name string) T
tag :: T (T name string) (T name string)
lift :: (T name0 string0 -> T name1 string1) -> (T name0 string0 -> T name1 string1)
liftA :: Applicative f => (T name0 string0 -> f (T name1 string1)) -> (T name0 string0 -> f (T name1 string1))
textFromCData :: (Tag name, C char) => T name [char] -> T name [char]

-- | Merge adjacent Text sections.
concatTexts :: Monoid string => [T name string] -> [T name string]
instance Traversable (T name)
instance Foldable (T name)
instance Functor (T name)
instance (Attribute name, Show string, Show name) => Show (T name string)


-- | Parse a string into our custom tag soup data structure.
--   
--   The parser works only on proper Unicode texts. That is, you must have
--   decoded it before, e.g. using decoding functions from hxt or encoding
--   package. <a>findMetaEncoding</a> can assist you retrieving the
--   character set encoding from meta information of the document at hand.
module Text.HTML.Tagchup.Parser
class C char => CharType char

-- | Like <a>runSoupWithPositions</a> but hides source file positions.
runSoup :: (C source, StringType sink, Attribute name, Tag name) => source -> [T name sink]

-- | Parse an HTML document to a list of <a>T</a>. Automatically expands
--   out escape characters.
runSoupWithPositions :: (C source, StringType sink, Attribute name, Tag name) => source -> [T name sink]
runSoupWithPositionsName :: (C source, StringType sink, Attribute name, Tag name) => FilePath -> source -> [T name sink]

-- | Parse a single tag, throws an error if there is a syntax error. This
--   is useful for parsing a match pattern.
runTag :: (C source, StringType sink, Show sink, Attribute name, Tag name, Show name) => source -> T name sink

-- | Parse the inner of a single tag. That is, <tt>runTag
--   "&lt;bla&gt;"</tt> is the same as <tt>runInnerOfTag "bla"</tt>.
runInnerOfTag :: (StringType sink, Show sink, Attribute name, Tag name, Show name) => String -> T name sink
