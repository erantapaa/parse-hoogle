-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Attempto Controlled English parser and printer
--   
@package ace
@version 0.6


-- | Pretty printing types and classes.
module ACE.Types.Pretty

-- | Pretty print a syntax tree node to a string.
class Pretty p
pretty :: Pretty p => p -> Builder

-- | Prints no string if nothing.
instance Pretty a => Pretty (Maybe a)


-- | Tokens for ACE.
module ACE.Types.Tokens

-- | A token
data Token
Word :: !(Int, Int) -> !Text -> Token
QuotedString :: !(Int, Int) -> !Text -> Token
Period :: !(Int, Int) -> Token
Comma :: !(Int, Int) -> Token
QuestionMark :: !(Int, Int) -> Token
Genitive :: !(Int, Int) -> !Bool -> Token
Number :: !(Int, Int) -> !Integer -> Token

-- | Get the position of the token.
tokenPos :: Token -> (Int, Int)
instance Eq Token


-- | Parser combinators.
module ACE.Combinators

-- | Match a word with the given string.
string :: Stream s m Token => Text -> ParsecT s u m Text

-- | Match a Saxon genitive.
genitive :: Stream s m Token => ParsecT s u m Bool

-- | Match a word with the given string.
number :: Stream s m Token => ParsecT s u m Integer

-- | Quoted string.
quoted :: Stream s m Token => ParsecT s u m Text

-- | A comma.
comma :: Stream s m Token => ParsecT s u m ()

-- | A period.
period :: Stream s m Token => ParsecT s u m ()

-- | Try to match all the given strings, or none at all.
strings :: Stream s m Token => [Text] -> ParsecT s u m ()

-- | Satisfy the given predicate from the token stream.
satisfy :: Stream s m Token => (Token -> Maybe a) -> ParsecT s u m a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: Stream s m Token => ParsecT s u m Token

-- | Make a string out of the token, for error message purposes.
tokenString :: Token -> [Char]

-- | Update the position by the token.
tokenPosition :: SourcePos -> Token -> t -> SourcePos

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
notFollowedBy :: Stream s m Token => ParsecT s u m Token -> ParsecT s u m ()

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: Stream s m Token => ParsecT s u m ()


-- | Tokenizer for ACE. Tokens retain source locations (line and column).
module ACE.Tokenizer

-- | Tokenize some complete ACE text.
tokenize :: Text -> Either String [Token]

-- | The tokenizer.
tokenizer :: Parser ([Token], (Int, Int))

-- | Parse a token.
token :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a number.
number :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a quoted string, <tt>"foobar"</tt>.
quotedString :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a period ".".
period :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a comma ",".
comma :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a question mark "?".
questionMark :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse a word, which is any sequence of non-whitespace words containing
--   none of the other token characters.
word :: (Int, Int) -> Parser (Token, (Int, Int))

-- | Parse the Saxon genitive ' or 's. This is ran after parsing every
--   token, but is expected to fail most of the time.
genitive :: (Int, Int) -> Parser (Maybe (Token, (Int, Int)))

-- | Like <a>many</a>, but retains the current source position and supports
--   postfix-parsing of the genitive apostrophe.
manyWithPos :: (Monad m, Alternative m) => ((t, t1) -> m (a, (t, t1))) -> ((t, t1) -> m (Maybe (a, (t, t1)))) -> (t, t1) -> m ([a], (t, t1))

-- | Skip spaces (space, newline, tab (=4 spaces)) and keep positioning
--   information up to date.
spaces :: (Int, Int) -> Parser (Int, Int)


-- | Types for the syntax tree.
module ACE.Types.Syntax

-- | Specifications consist of a sentence coordination followed by a period
--   and optionally one ore more subsequent specifications.
data Specification
Specification :: !SentenceCoord -> !(Maybe Specification) -> Specification

-- | Sentences can be coordinated by <tt>and</tt> and <tt>or</tt>.
--   <tt>And</tt> refers to the logical conjunction, while <tt>or</tt>
--   de-notes the logical disjunction. The logical conjunction has a higher
--   precedence than the disjunction.
--   
--   Both connectors are right-associative. The expression
--   
--   A or B and C or D
--   
--   is therefore ordered like
--   
--   A ∨ ((B ∧ C) ∨ D)
--   
--   To enable more combinations, we have introduced comma-and and
--   comma-or. These expressions reverse the order of precedence. To
--   achieve the order
--   
--   A ∨ (B ∧ (C ∨ D))
--   
--   we can write
--   
--   A, or B, and C or D
--   
--   A sentence coordination in general consists of a sentence coordination
--   of a lower level (thus ensuring right-associativity) optionally
--   followed by the respective connector and a sentence coordination of
--   the same level.
data SentenceCoord
SentenceCoord :: !SentenceCoord_1 -> !(Maybe SentenceCoord) -> SentenceCoord
data SentenceCoord_1
SentenceCoord_1 :: !SentenceCoord_2 -> !(Maybe SentenceCoord_1) -> SentenceCoord_1
data SentenceCoord_2
SentenceCoord_2 :: !SentenceCoord_3 -> !(Maybe SentenceCoord_2) -> SentenceCoord_2
data SentenceCoord_3
SentenceCoord_3 :: !TopicalizedSentence -> !(Maybe SentenceCoord_3) -> SentenceCoord_3

-- | A topicalized sentence can start with an existential topic or a
--   universal topic. It needs, however, not be topicalized at all but can
--   just be an ordinary composite sentence.
data TopicalizedSentence

-- | Example: "There is a card such that the code of the card is valid."
TopicalizedSentenceExistential :: !ExistentialTopic -> !(Maybe SentenceCoord) -> TopicalizedSentence

-- | Example: "For every code there is a card such that the code belongs to
--   it."
TopicalizedSentenceUniversal :: !UniversalTopic -> !SentenceCoord -> TopicalizedSentence

-- | Example: "Homer is a man."
TopicalizedSentenceComposite :: !CompositeSentence -> TopicalizedSentence
data UniversalTopic
UniversalTopic :: !UniversalGlobalQuantor -> !N' -> UniversalTopic
data CompositeSentence
CompositeSentenceCond :: !ConditionalSentence -> CompositeSentence
CompositeSentenceNeg :: !NegatedSentence -> CompositeSentence
CompositeSentence :: !Sentence -> CompositeSentence
data ConditionalSentence
ConditionalSentence :: !SentenceCoord -> !SentenceCoord -> ConditionalSentence
data NegatedSentence
NegatedSentence :: !SentenceCoord -> NegatedSentence
data Sentence
Sentence :: !NPCoord -> !VPCoord -> Sentence
data ExistentialTopic
ExistentialTopic :: !ExistentialGlobalQuantor -> !NPCoord -> ExistentialTopic
data NPCoord
NPCoordDistributed :: !DistributiveMarker -> !UnmarkedNPCoord -> NPCoord
NPCoordUnmarked :: !UnmarkedNPCoord -> NPCoord
data UnmarkedNPCoord
UnmarkedNPCoord :: !NP -> !(Maybe UnmarkedNPCoord) -> UnmarkedNPCoord

-- | Modified noun.
data N'
N' :: !(Maybe AdjectiveCoord) -> !N -> !(Maybe ApposCoord) -> !(Maybe NPCoord) -> !(Maybe RelativeClauseCoord) -> N'

-- | Noun-phrase.
data NP
NP :: !Specifier -> !N' -> NP
NPPro :: !Pronoun -> NP
NPProper :: !ProperName -> NP
NPVar :: !Variable -> NP

-- | A noun.
data N
N :: !Text -> N
data PP
PP :: !Preposition -> !NPCoord -> PP
data Preposition
Preposition :: !Text -> Preposition
data ApposCoord
ApposCoord :: !Apposition -> !(Maybe ApposCoord) -> ApposCoord
data Apposition
AppositionVar :: !Variable -> Apposition
AppositionQuote :: !Quotation -> Apposition
data Quotation
Quotation :: !Text -> Quotation
data Variable
Variable :: !Text -> Variable
data RelativeClauseCoord
RelativeClauseCoord :: !RelativeClause -> !(Maybe (Coord, RelativeClauseCoord)) -> RelativeClauseCoord
data PossessiveNPCoord
PossessiveNPCoordGen :: !GenitiveNPCoord -> PossessiveNPCoord
PossessiveNPCoordPronoun :: !PossessivePronounCoord -> PossessiveNPCoord
data GenitiveNPCoord
GenitiveNPCoord :: !GenitiveSpecifier -> !GenitiveN' -> !GenitiveTail -> GenitiveNPCoord
GenitiveNPCoordName :: !ProperName -> !GenitiveTail -> GenitiveNPCoord
data ProperName
ProperName :: !Text -> ProperName
data PossessivePronounCoord
PossessivePronounCoord :: !PossessivePronoun -> !(Maybe PossessivePronounCoord) -> PossessivePronounCoord
data GenitiveTail
GenitiveTailSaxonTail :: !SaxonGenitiveTail -> GenitiveTail
GenitiveTailCoordtail :: !GenitiveCoordTail -> GenitiveTail
data GenitiveCoordTail
GenitiveCoordTail :: !GenitiveNPCoord -> GenitiveCoordTail
data SaxonGenitiveTail
SaxonGenitiveTail :: !SaxonGenitiveMarker -> !(Maybe (GenitiveN', SaxonGenitiveTail)) -> SaxonGenitiveTail
data RelativeClause
RelativeClauseThat :: !VPCoord -> RelativeClause
RelativeClauseNP :: !NPCoord -> !VPCoord -> RelativeClause
RelativeClauseThatNPVP :: !NPCoord -> !VPCoord -> RelativeClause
RelativeClauseNPVP :: !NPCoord -> !NPCoord -> !VPCoord -> RelativeClause
RelativeClausePP :: !PP -> !NPCoord -> !VPCoord -> RelativeClause
data VPCoord
VPCoord' :: !VP -> !Coord -> !VPCoord -> VPCoord
VPCoordVP :: !VP -> VPCoord
data GenitiveSpecifier
GenitiveSpecifierD :: !Determiner -> GenitiveSpecifier
GenitiveSpecifierPPC :: !PossessivePronounCoord -> GenitiveSpecifier
GenitiveSpecifierN :: !Integer -> GenitiveSpecifier
data GenitiveN'
GenitiveN' :: !(Maybe AdjectiveCoord) -> !N -> !(Maybe ApposCoord) -> GenitiveN'
data VP
VP :: !V' -> VP
VPNeg :: !Copula -> !V' -> VP
data V'
V' :: !(Maybe AdverbCoord) -> !ComplV -> ![VModifier] -> V'
data AdverbCoord
AdverbCoord :: !Adverb -> !(Maybe AdverbCoord) -> AdverbCoord
data ComplV
ComplVIV :: !IntransitiveV -> ComplV
ComplVPI :: !PhrasalIntransitiveV -> !PhrasalParticle -> ComplV
ComplVTV :: !TransitiveV -> !Compl -> ComplV
ComplVPV :: !PhrasalTransitiveV -> !PhrasalParticle -> !Compl -> ComplV
ComplVPV' :: !PhrasalTransitiveV -> !Compl -> !PhrasalParticle -> ComplV
ComplVDisV :: !DistransitiveV -> !Compl -> !Compl -> ComplV
ComplVPDV :: !PhrasalDistransitiveV -> !Compl -> !PhrasalParticle -> !Compl -> ComplV
ComplVCopula :: !Copula -> !CopulaCompl -> ComplV
data PhrasalTransitiveV
PhrasalTransitiveV :: !Text -> PhrasalTransitiveV
data PhrasalDistransitiveV
PhrasalDistransitiveV :: !Text -> PhrasalDistransitiveV
data CopulaCompl
CopulaComplAPC :: !APCoord -> CopulaCompl
CopulaComplNPC :: !NPCoord -> CopulaCompl
CopulaComplPP :: !PP -> CopulaCompl
data APCoord
APCoordAnd :: !APgrad -> !APCoord -> APCoord
APCoord :: !APgrad -> APCoord
data APgrad
APgradAPThan :: !AP -> !NPCoord -> APgrad
APgradAP :: !AP -> APgrad
data AP
APIntrans :: !IntransitiveAdjective -> AP
APTrans :: !TransitiveAdjective -> !PP -> AP
data TransitiveAdjective
TransitiveAdjective :: !Text -> TransitiveAdjective
data Compl
ComplNP :: !NPCoord -> Compl
ComplPP :: !PP -> Compl
data PhrasalIntransitiveV
PhrasalIntransitiveV :: !Text -> PhrasalIntransitiveV
data PhrasalParticle
PhrasalParticle :: !Text -> PhrasalParticle
data IntransitiveV
IntransitiveV :: !Text -> IntransitiveV
data TransitiveV
TransitiveV :: !Text -> TransitiveV
data DistransitiveV
DistransitiveV :: !Text -> DistransitiveV
data IntransitiveAdjective
IntransitiveAdjective :: !Text -> IntransitiveAdjective
data VModifier
VModifierVC :: !AdverbCoord -> VModifier
VModifierPP :: !PP -> VModifier
VModifierAVPP :: !AdverbialPP -> VModifier
data AdverbialPP
AdverbialPP :: !Preposition -> !AdverbCoord -> AdverbialPP
data Adverb
Adverb :: !Text -> Adverb
data Specifier
SpecifyDeterminer :: !Determiner -> Specifier
SpecifyPossessive :: !PossessiveNPCoord -> Specifier
SpecifyNumberP :: !NumberP -> Specifier
data AdjectiveCoord
AdjectiveCoord :: !IntransitiveAdjective -> !(Maybe AdjectiveCoord) -> AdjectiveCoord
data NumberP
NumberP :: !(Maybe GeneralizedQuantor) -> !Integer -> NumberP
data ExistentialGlobalQuantor
ExistentialGlobalQuantor :: !Copula -> ExistentialGlobalQuantor
data ExistentialGlobalQuestionQuantor
ExistentialGlobalQuestionQuantor :: !Copula -> ExistentialGlobalQuestionQuantor
data Aux

-- | "do"
Do :: Aux

-- | "does"
Does :: Aux
data Coord

-- | "and"
And :: Coord

-- | "or"
Or :: Coord
data Copula

-- | "is"
Is :: Copula

-- | "are"
Are :: Copula
data Determiner

-- | "the"
The :: Determiner

-- | "a"
A :: Determiner

-- | "an"
An :: Determiner

-- | "some"
Some :: Determiner

-- | "no"
No :: Determiner

-- | "every" / "each"
EveryEach :: Determiner

-- | "all"
All :: Determiner

-- | "not every"
NotEvery :: Determiner

-- | "not each"
NotEach :: Determiner

-- | "not all"
NotAll :: Determiner

-- | "which"
Which :: Determiner
data DistributiveGlobalQuantor

-- | "for each of"
ForEachOf :: DistributiveGlobalQuantor
data DistributiveMarker

-- | "each of"
EachOf :: DistributiveMarker
data GeneralizedQuantor

-- | "at most"
AtMost :: GeneralizedQuantor

-- | "at least"
AtLeast :: GeneralizedQuantor

-- | "more than"
MoreThan :: GeneralizedQuantor

-- | "less than"
LessThan :: GeneralizedQuantor

-- | "not more than"
NotMoreThan :: GeneralizedQuantor

-- | "not less than"
NotLessThan :: GeneralizedQuantor
data PossessivePronoun

-- | "his"
His :: PossessivePronoun

-- | "her"
Her :: PossessivePronoun

-- | "his/her"
HisHer :: PossessivePronoun

-- | "its"
Its :: PossessivePronoun

-- | "their"
Their :: PossessivePronoun

-- | "his own" <i> "her own" </i> "his/her own"
HisHerOwn :: PossessivePronoun

-- | "its own"
ItsOwn :: PossessivePronoun

-- | "their own"
TheirOwn :: PossessivePronoun

-- | "whose"
Whose :: PossessivePronoun
data Pronoun
It :: Pronoun
He :: Pronoun
She :: Pronoun
HeShe :: Pronoun
Him :: Pronoun
HerP :: Pronoun
HimHer :: Pronoun
They :: Pronoun
Them :: Pronoun
Itself :: Pronoun
Himself :: Pronoun
Herself :: Pronoun
HimselfHerself :: Pronoun
Themselves :: Pronoun
Someone :: Pronoun
Somebody :: Pronoun
Something :: Pronoun
NoOne :: Pronoun
Nobody :: Pronoun
NoThing :: Pronoun
Everyone :: Pronoun
Everybody :: Pronoun
Everything :: Pronoun
NotEveryone :: Pronoun
NotEverybody :: Pronoun
NotEverything :: Pronoun
What :: Pronoun
Who :: Pronoun
Whom :: Pronoun
WhichP :: Pronoun

-- | The Saxon genitive used for possession.
data SaxonGenitiveMarker

-- | "'"
Apostrophe :: SaxonGenitiveMarker

-- | "'s"
ApostropheS :: SaxonGenitiveMarker
data UniversalGlobalQuantor

-- | "for every"
ForEvery :: UniversalGlobalQuantor

-- | "for each"
ForEach :: UniversalGlobalQuantor

-- | "for all"
ForAll :: UniversalGlobalQuantor
instance Show N
instance Eq N
instance Show Preposition
instance Eq Preposition
instance Show Quotation
instance Eq Quotation
instance Show Variable
instance Eq Variable
instance Show Apposition
instance Eq Apposition
instance Show ApposCoord
instance Eq ApposCoord
instance Show ProperName
instance Eq ProperName
instance Show PhrasalTransitiveV
instance Eq PhrasalTransitiveV
instance Show PhrasalDistransitiveV
instance Eq PhrasalDistransitiveV
instance Show TransitiveAdjective
instance Eq TransitiveAdjective
instance Show PhrasalIntransitiveV
instance Eq PhrasalIntransitiveV
instance Show PhrasalParticle
instance Eq PhrasalParticle
instance Show IntransitiveV
instance Eq IntransitiveV
instance Show TransitiveV
instance Eq TransitiveV
instance Show DistransitiveV
instance Eq DistransitiveV
instance Show IntransitiveAdjective
instance Eq IntransitiveAdjective
instance Show Adverb
instance Eq Adverb
instance Show AdverbCoord
instance Eq AdverbCoord
instance Show AdverbialPP
instance Eq AdverbialPP
instance Show AdjectiveCoord
instance Eq AdjectiveCoord
instance Show GenitiveN'
instance Eq GenitiveN'
instance Show Aux
instance Eq Aux
instance Show Coord
instance Eq Coord
instance Show Copula
instance Eq Copula
instance Show ExistentialGlobalQuestionQuantor
instance Eq ExistentialGlobalQuestionQuantor
instance Show ExistentialGlobalQuantor
instance Eq ExistentialGlobalQuantor
instance Show Determiner
instance Eq Determiner
instance Show DistributiveGlobalQuantor
instance Eq DistributiveGlobalQuantor
instance Show DistributiveMarker
instance Eq DistributiveMarker
instance Show GeneralizedQuantor
instance Eq GeneralizedQuantor
instance Show NumberP
instance Eq NumberP
instance Show PossessivePronoun
instance Eq PossessivePronoun
instance Show PossessivePronounCoord
instance Eq PossessivePronounCoord
instance Show GenitiveSpecifier
instance Eq GenitiveSpecifier
instance Show Pronoun
instance Eq Pronoun
instance Show SaxonGenitiveMarker
instance Eq SaxonGenitiveMarker
instance Show SaxonGenitiveTail
instance Eq SaxonGenitiveTail
instance Show GenitiveTail
instance Eq GenitiveTail
instance Show GenitiveCoordTail
instance Eq GenitiveCoordTail
instance Show GenitiveNPCoord
instance Eq GenitiveNPCoord
instance Show PossessiveNPCoord
instance Eq PossessiveNPCoord
instance Show Specifier
instance Eq Specifier
instance Show NP
instance Eq NP
instance Show N'
instance Eq N'
instance Show RelativeClauseCoord
instance Eq RelativeClauseCoord
instance Show RelativeClause
instance Eq RelativeClause
instance Show VPCoord
instance Eq VPCoord
instance Show VP
instance Eq VP
instance Show V'
instance Eq V'
instance Show VModifier
instance Eq VModifier
instance Show PP
instance Eq PP
instance Show NPCoord
instance Eq NPCoord
instance Show UnmarkedNPCoord
instance Eq UnmarkedNPCoord
instance Show ComplV
instance Eq ComplV
instance Show Compl
instance Eq Compl
instance Show CopulaCompl
instance Eq CopulaCompl
instance Show APCoord
instance Eq APCoord
instance Show APgrad
instance Eq APgrad
instance Show AP
instance Eq AP
instance Show ExistentialTopic
instance Eq ExistentialTopic
instance Show Sentence
instance Eq Sentence
instance Show UniversalGlobalQuantor
instance Eq UniversalGlobalQuantor
instance Show UniversalTopic
instance Eq UniversalTopic
instance Show TopicalizedSentence
instance Eq TopicalizedSentence
instance Show CompositeSentence
instance Eq CompositeSentence
instance Show NegatedSentence
instance Eq NegatedSentence
instance Show SentenceCoord
instance Eq SentenceCoord
instance Show SentenceCoord_1
instance Eq SentenceCoord_1
instance Show SentenceCoord_2
instance Eq SentenceCoord_2
instance Show SentenceCoord_3
instance Eq SentenceCoord_3
instance Show ConditionalSentence
instance Eq ConditionalSentence
instance Show Specification
instance Eq Specification


-- | Parsers for ACE syntax types.
module ACE.Parsers

-- | Parser configuration.
data ACEParser s m
ACE :: ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ParsecT s (ACEParser s m) m Text -> ACEParser s m

-- | Parser for intransitive adjectives.
aceIntransitiveAdjective :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for transitive adjectives.
aceTransitiveAdjective :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for nouns.
aceNoun :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for prepositions.
acePreposition :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for variables.
aceVariable :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for proper names.
aceProperName :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for adverbs.
aceAdverb :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for intransitive verbs.
aceIntransitiveVerb :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for phrasal transitive verbs.
acePhrasalTransitiveV :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for phrasal distransitive verbs.
acePhrasalDistransitiveV :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for transitive verbs.
aceTransitiveVerb :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for distransitive verbs.
aceDistransitiveVerb :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for phrasal particles.
acePhrasalParticle :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | Parser for phrasal intransitive verbs.
acePhrasalIntransitiveV :: ACEParser s m -> ParsecT s (ACEParser s m) m Text

-- | A default ACE parser configuration. Just fills in all the parsers as
--   blanks: <tt>&lt;noun&gt;</tt>, <tt>&lt;prep&gt;</tt>, etc.
defaultACEParser :: Stream s m Token => ACEParser s m

-- | Some specification. A <a>sentenceCoord</a> followed by a
--   <a>period</a>, and optionally another <a>specification</a>.
specification :: Stream s m Token => ParsecT s (ACEParser s m) m Specification

-- | Coordinated sentence, by: or
sentenceCoord :: Stream s m Token => ParsecT s (ACEParser s m) m SentenceCoord

-- | Coordinated sentence, by: and
sentenceCoord_1 :: Stream s m Token => ParsecT s (ACEParser s m) m SentenceCoord_1

-- | Coordinated sentence, by: or
sentenceCoord_2 :: Stream s m Token => ParsecT s (ACEParser s m) m SentenceCoord_2

-- | Coordinated sentence, by: and
sentenceCoord_3 :: Stream s m Token => ParsecT s (ACEParser s m) m SentenceCoord_3

-- | A topicalized sentence.
topicalizedSentence :: Stream s m Token => ParsecT s (ACEParser s m) m TopicalizedSentence

-- | A universally quantified topic.
universalTopic :: Stream s m Token => ParsecT s (ACEParser s m) m UniversalTopic

-- | A composite sentence: <a>conditionalSentence</a>,
--   <a>negatedSentence</a> or <a>sentence</a>.
compositeSentence :: Stream s m Token => ParsecT s (ACEParser s m) m CompositeSentence

-- | A negated sentence: it is not the case that <a>sentenceCoord</a>
negatedSentence :: Stream s m Token => ParsecT s (ACEParser s m) m NegatedSentence

-- | A condition if <a>sentenceCoord</a> then <a>sentenceCoord</a>.
conditionalSentence :: Stream s m Token => ParsecT s (ACEParser s m) m ConditionalSentence

-- | Sentence: <a>npCoord</a> <a>vpCoord</a>: a cat meows
sentence :: Stream s m Token => ParsecT s (ACEParser s m) m Sentence

-- | Existential topic, a <a>existentialGlobalQuantor</a> and a
--   <a>npCoord</a>: there is a chair
existentialTopic :: Stream s m Token => ParsecT s (ACEParser s m) m ExistentialTopic

-- | A noun specifier: "a", "some", "1", "<a>proper-name</a>'s".
specifier :: Stream s m Token => ParsecT s (ACEParser s m) m Specifier

-- | A preposition. Configured by <a>acePreposition</a>.
preposition :: Monad m => ParsecT s (ACEParser s m) m Preposition

-- | A genitive tail: dave's and a dog's
genitiveTail :: Stream s m Token => ParsecT s (ACEParser s m) m GenitiveTail

-- | A genitive coordination tail: dave's and a dog's
genitiveCoordTail :: Stream s m Token => ParsecT s (ACEParser s m) m GenitiveCoordTail

-- | Genitive tail.
saxonGenitiveTail :: Stream s m Token => ParsecT s (ACEParser s m) m SaxonGenitiveTail

-- | Apposition: either a <a>variable</a> or a <a>quotation</a>.
apposition :: Stream s m Token => ParsecT s (ACEParser s m) m Apposition

-- | A apposition coordination: X and Y.
apposCoord :: Stream s m Token => ParsecT s (ACEParser s m) m ApposCoord

-- | A prepositional noun phrase coordination.
pp :: Stream s m Token => ParsecT s (ACEParser s m) m PP

-- | A <a>relativeClause</a> coordination: person that walks and cake a
--   person made.
relativeClauseCoord :: Stream s m Token => ParsecT s (ACEParser s m) m RelativeClauseCoord

-- | A noun surrounded by optional <a>adjectiveCoord</a>, a noun word
--   <a>n</a>, an optional <a>apposCoord</a>, an optional <a>ofPP</a>, an
--   optional <a>relativeClauseCoord</a>.
n' :: Stream s m Token => Bool -> ParsecT s (ACEParser s m) m N'

-- | Unmarked noun phrase coordination: some thing and a thing.
unmarkedNPCoord :: Stream s m Token => Bool -> ParsecT s (ACEParser s m) m UnmarkedNPCoord

-- | A noun phrase: a thing, some stuff, the thing.
np :: Stream s m Token => Bool -> ParsecT s (ACEParser s m) m NP

-- | A coordinated noun phrase. See <a>npCoordX</a>.
npCoord :: Stream s m Token => ParsecT s (ACEParser s m) m NPCoord

-- | A coordinated noun phrase. Inside a relative clause. See
--   <a>npCoordX</a>.
npCoord' :: Stream s m Token => ParsecT s (ACEParser s m) m NPCoord

-- | Relative clause: person that walks, cake a person made, cake that a
--   person made, etc.
relativeClause :: Stream s m Token => ParsecT s (ACEParser s m) m RelativeClause

-- | An "of" prepositional phrase: of the bank
ofPP :: Stream s m Token => ParsecT s (ACEParser s m) m NPCoord

-- | A coordinated noun phrase: each of some customers, some customers
npCoordX :: Stream s m Token => Bool -> ParsecT s (ACEParser s m) m NPCoord

-- | A variable. Customized by <a>aceVariable</a>.
variable :: Monad m => ParsecT s (ACEParser s m) m Variable

-- | A proper name. Customized by <a>aceProperName</a>.
properName :: Monad m => ParsecT s (ACEParser s m) m ProperName

-- | Some quotation: "foo bar"
quotation :: Stream s m Token => ParsecT s u m Quotation

-- | A noun. Customized by <a>aceNoun</a>.
n :: Monad m => ParsecT s (ACEParser s m) m N

-- | A verb phrase coordination is either a <a>vp</a> followed by a
--   <a>coord</a> and more <a>vpCoord</a>, or just a <a>vp</a>: walks,
--   walks and runs, bad and is not valid
vpCoord :: Stream s m Token => ParsecT s (ACEParser s m) m VPCoord

-- | A verb phrase. Can be normal <a>v'</a> or a <a>copula</a> followed by
--   "not" then <a>v'</a>: walks, is not valid, etc.
vp :: Stream s m Token => ParsecT s (ACEParser s m) m VP

-- | A genitive noun: dog, red cat, person 1, movie "We Need to Talk About
--   Kevin".
genitiveN' :: Stream s m Token => ParsecT s (ACEParser s m) m GenitiveN'

-- | A verb modifier: quickly and loudly, to a house, from now and forever
vModifier :: Stream s m Token => ParsecT s (ACEParser s m) m VModifier

-- | Adverbial prepositional phrase: until here, by then, until now and
--   then
adverbialPP :: Stream s m Token => ParsecT s (ACEParser s m) m AdverbialPP

-- | A verb. Consists of an optional <a>adverbCoord</a>, a complemented
--   verb (<a>complV</a>), and one or more verb modifiers.
--   
--   TODO: I'm not actually sure whether it should be zero-to-1 or
--   zero-to-many. The paper isn't clear what VModifier* means.
v' :: Stream s m Token => ParsecT s (ACEParser s m) m V'

-- | Genitive specifier: a, 1, some, his
genitiveSpecifier :: Stream s m Token => ParsecT s u m GenitiveSpecifier

-- | Either a <a>genitiveNPCoord</a>, or a <a>possessivePronounCoord</a>.
possessiveNPCoord :: Stream s m Token => ParsecT s (ACEParser s m) m PossessiveNPCoord

-- | A ' or 's saxon genitive.
saxonGenitiveMarker :: Stream s m Token => ParsecT s u m SaxonGenitiveMarker

-- | Possessive pronoun coordination: his and her
possessivePronounCoord :: Stream s m Token => ParsecT s u m PossessivePronounCoord

-- | A genitive noun phrase coordination: dave's, a dog's, a man and a
--   dog's
genitiveNPCoord :: Stream s m Token => ParsecT s (ACEParser s m) m GenitiveNPCoord

-- | A complemented verb. One of <a>complVCopula</a>, <a>complVPDV</a>,
--   <a>complVDisV</a>, <a>complVPV</a>, <a>complVPV'</a>, <a>complVTV</a>.
complV :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A complemented copula: is valid
complVCopula :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A distransitive phrasal verb: puts an error down to a customer
complVPDV :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A distransitive complemented verb: gives a card to a customer
complVDisV :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A complemented phrasal transitive verb: gives away a code
complVPV :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A complemented phrasal transitive verb, flipped: gives a code away
complVPV' :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | Complemented transitive verb: inserts a card
complVTV :: Stream s m Token => ParsecT s (ACEParser s m) m ComplV

-- | A phrasal distransitive verb: puts an error down to a customer
phrasalDistransitiveV :: Monad m => ParsecT s (ACEParser s m) m PhrasalDistransitiveV

-- | A phrasal transitive verb: give away a thing
phrasalTransitiveV :: Monad m => ParsecT s (ACEParser s m) m PhrasalTransitiveV

-- | Complemented non-copula verb, e.g. Mary sees him.
compl :: Stream s m Token => ParsecT s (ACEParser s m) m Compl

-- | An intransitive verb. Takes no complement. E.g. walks.
complVIV :: Monad m => ParsecT s (ACEParser s m) m ComplV

-- | A phrasal intransitive verb with a complement, in this case a
--   particle: gets in, sits up.
complVPI :: Monad m => ParsecT s (ACEParser s m) m ComplV

-- | A phrasal intransitive verb: gives, sits (e.g. gives up, sits down).
--   This is customized by <a>acePhrasalIntransitiveV</a>.
phrasalIntransitiveV :: Monad m => ParsecT s (ACEParser s m) m PhrasalIntransitiveV

-- | A phrasal verb particle, e.g. in, up, out (get in, get up, get out).
--   This is customized via <a>acePhrasalParticle</a>.
phrasalParticle :: Monad m => ParsecT s (ACEParser s m) m PhrasalParticle

-- | Either a graded adjective coordination ("better than a duck and faster
--   than a mouse"), or a noun phrase coordination ("a goose and an
--   ocelot"), or a prepositional phrase ("to a bucket or a kettle").
copulaCompl :: Stream s m Token => ParsecT s (ACEParser s m) m CopulaCompl

-- | A coordination of a graded adjective: "better than a potato and nicer
--   than some bacon"
apCoord :: Stream s m Token => ParsecT s (ACEParser s m) m APCoord

-- | A graded adjective. Either comparative adjective phrase ("better than
--   a potato"), or a simple adjective phrase (see <a>ap</a>).
apGrad :: Stream s m Token => ParsecT s (ACEParser s m) m APgrad

-- | An adjective phrase. Transitive (fond of Mary, interested in an
--   account) or intransitive (correct, green, valid).
ap :: Stream s m Token => ParsecT s (ACEParser s m) m AP

-- | Some intransitive verb: walks
intransitiveV :: Monad m => ParsecT s (ACEParser s m) m IntransitiveV

-- | Some transitive verb: inserts
transitiveV :: Monad m => ParsecT s (ACEParser s m) m TransitiveV

-- | Some distransitive verb: inserts
distransitiveV :: Monad m => ParsecT s (ACEParser s m) m DistransitiveV

-- | Adverb coordination: quickly and hastily and manually
adverbCoord :: Stream s m Token => ParsecT s (ACEParser s m) m AdverbCoord

-- | Adverb: quickly
adverb :: Monad m => ParsecT s (ACEParser s m) m Adverb

-- | Adjective coordination: correct and green
adjectiveCoord :: Stream s m Token => ParsecT s (ACEParser s m) m AdjectiveCoord

-- | Intransitive adjective: correct, green, valid
--   
--   The actual parser for this is provided as
--   <a>aceIntransitiveAdjective</a> in the parser configuration. You can
--   configure this.
intransitiveAdjective :: Monad m => ParsecT s (ACEParser s m) m IntransitiveAdjective

-- | Transitive adjective: correct, green, valid
transitiveAdjective :: Monad m => ParsecT s (ACEParser s m) m TransitiveAdjective

-- | A determiner: the, an, not every, etc.
determiner :: Stream s m Token => ParsecT s u m Determiner

-- | A number phrase: more than 5
numberP :: Stream s m Token => ParsecT s u m NumberP

-- | There is/are.
existentialGlobalQuantor :: Stream s m Token => ParsecT s u m ExistentialGlobalQuantor

-- | Is/are there?
existentialGlobalQuestionQuantor :: Stream s m Token => ParsecT s u m ExistentialGlobalQuestionQuantor

-- | Do/does.
aux :: Stream s m Token => ParsecT s u m Aux

-- | Pronouns.
pronoun :: Stream s m Token => ParsecT s u m Pronoun

-- | And/or.
coord :: Stream s m Token => ParsecT s u m Coord

-- | Is/are.
copula :: Stream s m Token => ParsecT s u m Copula

-- | A distributive global quantor: for each of
distributiveGlobalQuantor :: Stream s m Token => ParsecT s u m DistributiveGlobalQuantor

-- | A distributive marker: each of
distributiveMarker :: Stream s m Token => ParsecT s u m DistributiveMarker

-- | A generalized quantor: at most, at least, etc.
generalizedQuantor :: Stream s m Token => ParsecT s u m GeneralizedQuantor

-- | A possessive pronoun: his, her, his/her.
possessivePronoun :: Stream s m Token => ParsecT s u m PossessivePronoun

-- | A universal global quantor: for every/for each, for all.
universalGlobalQuantor :: Stream s m Token => ParsecT s u m UniversalGlobalQuantor


-- | Pretty printing classes.
module ACE.Pretty
instance Pretty UniversalGlobalQuantor
instance Pretty SaxonGenitiveMarker
instance Pretty Pronoun
instance Pretty PossessivePronoun
instance Pretty GeneralizedQuantor
instance Pretty DistributiveMarker
instance Pretty DistributiveGlobalQuantor
instance Pretty Determiner
instance Pretty Copula
instance Pretty Coord
instance Pretty Aux
instance Pretty ExistentialGlobalQuestionQuantor
instance Pretty ExistentialGlobalQuantor
instance Pretty NumberP
instance Pretty AdjectiveCoord
instance Pretty Specifier
instance Pretty Adverb
instance Pretty AdverbialPP
instance Pretty VModifier
instance Pretty IntransitiveAdjective
instance Pretty DistransitiveV
instance Pretty TransitiveV
instance Pretty IntransitiveV
instance Pretty PhrasalParticle
instance Pretty PhrasalIntransitiveV
instance Pretty Compl
instance Pretty TransitiveAdjective
instance Pretty AP
instance Pretty APgrad
instance Pretty APCoord
instance Pretty CopulaCompl
instance Pretty PhrasalDistransitiveV
instance Pretty PhrasalTransitiveV
instance Pretty ComplV
instance Pretty AdverbCoord
instance Pretty V'
instance Pretty VP
instance Pretty GenitiveN'
instance Pretty GenitiveSpecifier
instance Pretty VPCoord
instance Pretty RelativeClause
instance Pretty SaxonGenitiveTail
instance Pretty GenitiveCoordTail
instance Pretty GenitiveTail
instance Pretty PossessivePronounCoord
instance Pretty ProperName
instance Pretty GenitiveNPCoord
instance Pretty PossessiveNPCoord
instance Pretty RelativeClauseCoord
instance Pretty Variable
instance Pretty Quotation
instance Pretty Apposition
instance Pretty ApposCoord
instance Pretty Preposition
instance Pretty PP
instance Pretty N
instance Pretty NP
instance Pretty N'
instance Pretty UnmarkedNPCoord
instance Pretty NPCoord
instance Pretty ExistentialTopic
instance Pretty Sentence
instance Pretty NegatedSentence
instance Pretty ConditionalSentence
instance Pretty CompositeSentence
instance Pretty UniversalTopic
instance Pretty TopicalizedSentence
instance Pretty SentenceCoord_3
instance Pretty SentenceCoord_2
instance Pretty SentenceCoord_1
instance Pretty SentenceCoord
instance Pretty Specification


-- | Instances for pretty printing as HTML.
module ACE.Html
instance ToMarkup UniversalGlobalQuantor
instance ToMarkup SaxonGenitiveMarker
instance ToMarkup Pronoun
instance ToMarkup PossessivePronoun
instance ToMarkup GeneralizedQuantor
instance ToMarkup DistributiveMarker
instance ToMarkup DistributiveGlobalQuantor
instance ToMarkup Determiner
instance ToMarkup Copula
instance ToMarkup Coord
instance ToMarkup Aux
instance ToMarkup ExistentialGlobalQuestionQuantor
instance ToMarkup ExistentialGlobalQuantor
instance ToMarkup NumberP
instance ToMarkup AdjectiveCoord
instance ToMarkup Specifier
instance ToMarkup Adverb
instance ToMarkup AdverbialPP
instance ToMarkup VModifier
instance ToMarkup IntransitiveAdjective
instance ToMarkup DistransitiveV
instance ToMarkup TransitiveV
instance ToMarkup IntransitiveV
instance ToMarkup PhrasalParticle
instance ToMarkup PhrasalIntransitiveV
instance ToMarkup Compl
instance ToMarkup TransitiveAdjective
instance ToMarkup AP
instance ToMarkup APgrad
instance ToMarkup APCoord
instance ToMarkup CopulaCompl
instance ToMarkup PhrasalDistransitiveV
instance ToMarkup PhrasalTransitiveV
instance ToMarkup ComplV
instance ToMarkup AdverbCoord
instance ToMarkup V'
instance ToMarkup VP
instance ToMarkup GenitiveN'
instance ToMarkup GenitiveSpecifier
instance ToMarkup VPCoord
instance ToMarkup RelativeClause
instance ToMarkup SaxonGenitiveTail
instance ToMarkup GenitiveCoordTail
instance ToMarkup GenitiveTail
instance ToMarkup PossessivePronounCoord
instance ToMarkup ProperName
instance ToMarkup GenitiveNPCoord
instance ToMarkup PossessiveNPCoord
instance ToMarkup RelativeClauseCoord
instance ToMarkup Variable
instance ToMarkup Quotation
instance ToMarkup Apposition
instance ToMarkup ApposCoord
instance ToMarkup Preposition
instance ToMarkup PP
instance ToMarkup N
instance ToMarkup NP
instance ToMarkup N'
instance ToMarkup UnmarkedNPCoord
instance ToMarkup NPCoord
instance ToMarkup ExistentialTopic
instance ToMarkup Sentence
instance ToMarkup NegatedSentence
instance ToMarkup ConditionalSentence
instance ToMarkup CompositeSentence
instance ToMarkup UniversalTopic
instance ToMarkup TopicalizedSentence
instance ToMarkup SentenceCoord_3
instance ToMarkup SentenceCoord_2
instance ToMarkup SentenceCoord_1
instance ToMarkup SentenceCoord
instance ToMarkup Specification


-- | Attempto Controlled English parser and printer.
module ACE
