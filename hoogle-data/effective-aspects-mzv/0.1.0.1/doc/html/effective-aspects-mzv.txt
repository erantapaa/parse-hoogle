-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monadic embedding of aspect oriented programming, using "Monads, Zippers and Views" instead of mtl.
--   
--   A monadic embedding of aspect oriented programming, similar to AspectJ
@package effective-aspects-mzv
@version 0.1.0.1

module AOP.Internal.PolyTypeable
class PolyTypeable a
polyTypeOf :: PolyTypeable a => a -> TypeRep
class Analyze a b | a -> b
data W a
data TCon0 c
data TCon1 c a1
data TCon2 c a1 a2
data TCon3 c a1 a2 a3
data TCon4 c a1 a2 a3 a4
data TCon5 c a1 a2 a3 a4 a5
data TVar a
instance [incoherent] TypeEq'' () x y HFalse
instance [incoherent] TypeEq'' q x y b => TypeEq' q x y b
instance [incoherent] b ~ HTrue => TypeEq' () x x b
instance [incoherent] TypeEq' () x y b => TypeEq x y b
instance [incoherent] Nat a => Nat (S a)
instance [incoherent] Nat Z
instance [incoherent] HLen l n => HLen (HCons a l) (S n)
instance [incoherent] HLen HNil Z
instance [incoherent] HIndex x l n => HIndex' HFalse x (HCons a l) n
instance [incoherent] HLen l n => HIndex' HTrue x l n
instance [incoherent] (Nat n, TypeEq x a f, HIndex' f x (HCons a l) n) => HIndex x (HCons a l) n
instance [incoherent] HIndex x HNil Z
instance [incoherent] Nat n => MyTypeable'' (S n) g0 g0 (TVar a)
instance [incoherent] HLen g0 n1 => MyTypeable'' Z g0 (HCons a g0) (TVar a)
instance [incoherent] (HIndex a g0 n, MyTypeable'' n g0 gout (TVar a)) => MyTypeable' g0 gout (TVar a)
instance [incoherent] (Typeable c, MyTypeable' g0 g1 a1, MyTypeable' g1 g2 a2, MyTypeable' g2 g3 a3, MyTypeable' g3 g4 a4, MyTypeable' g4 g5 a5) => MyTypeable' g0 g5 (TCon5 c a1 a2 a3 a4 a5)
instance [incoherent] (Typeable c, MyTypeable' g0 g1 a1, MyTypeable' g1 g2 a2, MyTypeable' g2 g3 a3, MyTypeable' g3 g4 a4) => MyTypeable' g0 g4 (TCon4 c a1 a2 a3 a4)
instance [incoherent] (Typeable c, MyTypeable' g0 g1 a1, MyTypeable' g1 g2 a2, MyTypeable' g2 g3 a3) => MyTypeable' g0 g3 (TCon3 c a1 a2 a3)
instance [incoherent] (Typeable c, MyTypeable' g0 g a1, MyTypeable' g g2 a2) => MyTypeable' g0 g2 (TCon2 c a1 a2)
instance [incoherent] (Typeable c, MyTypeable' g0 g1 a1) => MyTypeable' g0 g1 (TCon1 c a1)
instance [incoherent] Typeable a => MyTypeable' g0 g0 (TCon0 a)
instance [incoherent] (Analyze a result, MyTypeable' HNil gout result) => PolyTypeable a
instance [incoherent] r ~ TVar a => Analyze (W a) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, Analyze (W a4) ra4, Analyze (W a5) ra5, r ~ TCon5 (c () () () () ()) ra1 ra2 ra3 ra4 ra5) => Analyze (c a1 a2 a3 a4 a5) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, Analyze (W a4) ra4, Analyze (W a5) ra5, r ~ TCon5 (c () () () () ()) ra1 ra2 ra3 ra4 ra5) => Analyze (W (c a1 a2 a3 a4 a5)) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, Analyze (W a4) ra4, r ~ TCon4 (c () () () ()) ra1 ra2 ra3 ra4) => Analyze (c a1 a2 a3 a4) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, Analyze (W a4) ra4, r ~ TCon4 (c () () () ()) ra1 ra2 ra3 ra4) => Analyze (W (c a1 a2 a3 a4)) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, r ~ TCon3 (c () () ()) ra1 ra2 ra3) => Analyze (c a1 a2 a3) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, Analyze (W a3) ra3, r ~ TCon3 (c () () ()) ra1 ra2 ra3) => Analyze (W (c a1 a2 a3)) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, r ~ TCon2 (c () ()) ra1 ra2) => Analyze (c a1 a2) r
instance [incoherent] (Analyze (W a1) ra1, Analyze (W a2) ra2, r ~ TCon2 (c () ()) ra1 ra2) => Analyze (W (c a1 a2)) r
instance [incoherent] (Analyze (W a1) ra1, r ~ TCon1 (c ()) ra1) => Analyze (c a1) r
instance [incoherent] (Analyze (W a1) ra1, r ~ TCon1 (c ()) ra1) => Analyze (W (c a1)) r
instance [incoherent] r ~ TCon0 Word64 => Analyze (W Word64) r
instance [incoherent] r ~ TCon0 Word64 => Analyze Word64 r
instance [incoherent] r ~ TCon0 Word32 => Analyze (W Word32) r
instance [incoherent] r ~ TCon0 Word32 => Analyze Word32 r
instance [incoherent] r ~ TCon0 Word16 => Analyze (W Word16) r
instance [incoherent] r ~ TCon0 Word16 => Analyze Word16 r
instance [incoherent] r ~ TCon0 Word8 => Analyze (W Word8) r
instance [incoherent] r ~ TCon0 Word8 => Analyze Word8 r
instance [incoherent] r ~ TCon0 Int64 => Analyze (W Int64) r
instance [incoherent] r ~ TCon0 Int64 => Analyze Int64 r
instance [incoherent] r ~ TCon0 Int32 => Analyze (W Int32) r
instance [incoherent] r ~ TCon0 Int32 => Analyze Int32 r
instance [incoherent] r ~ TCon0 Int16 => Analyze (W Int16) r
instance [incoherent] r ~ TCon0 Int16 => Analyze Int16 r
instance [incoherent] r ~ TCon0 Int8 => Analyze (W Int8) r
instance [incoherent] r ~ TCon0 Int8 => Analyze Int8 r
instance [incoherent] r ~ TCon0 Double => Analyze (W Double) r
instance [incoherent] r ~ TCon0 Double => Analyze Double r
instance [incoherent] r ~ TCon0 Float => Analyze (W Float) r
instance [incoherent] r ~ TCon0 Float => Analyze Float r
instance [incoherent] r ~ TCon0 Integer => Analyze (W Integer) r
instance [incoherent] r ~ TCon0 Integer => Analyze Integer r
instance [incoherent] r ~ TCon0 Int => Analyze (W Int) r
instance [incoherent] r ~ TCon0 Int => Analyze Int r
instance [incoherent] r ~ TCon0 Ordering => Analyze (W Ordering) r
instance [incoherent] r ~ TCon0 Ordering => Analyze Ordering r
instance [incoherent] r ~ TCon0 Char => Analyze (W Char) r
instance [incoherent] r ~ TCon0 Char => Analyze Char r
instance [incoherent] r ~ TCon0 Bool => Analyze (W Bool) r
instance [incoherent] r ~ TCon0 Bool => Analyze Bool r
instance [incoherent] r ~ TCon0 () => Analyze (W ()) r
instance [incoherent] r ~ TCon0 () => Analyze () r

module AOP.Internal.PolyTypeableUtils

-- | Monad andmap
mmap :: Monad m => (a -> a' -> m Bool) -> [a] -> [a'] -> m Bool

-- | Applies a function on the first component of a pair
first :: (a -> a') -> (a, b) -> (a', b)

-- | Returns True iff t1 is less general than t2 | We use a hashmap to
--   compute a substitution from t2 to t1
isLessGeneral :: TypeRep -> TypeRep -> Bool

module AOP.Internal.StableNamesEq

-- | Equality of functions based on the StableName API
stableNamesEq :: a -> b -> Bool

module AOP.Internal.Typeable1Monad

-- | Support for PolyTypeable when using monads and monad transformers
class (Typeable1 m, Monad m) => Typeable1Monad m
instance (Typeable1Monad m, Typeable s) => Typeable1 (ErrorT s m)
instance (Typeable1Monad m, Typeable s) => Typeable1 (WriterT s m)
instance (Typeable1Monad m, Typeable s) => Typeable1 (StateT s m)
instance Typeable1 Identity
instance (Typeable1 m, Monad m) => Typeable1Monad m

module AOP.Internal.LessGen

-- | If LessGen a b, then b is less general than a. That is, there exists
--   substitution s such that (s b = a).
class LessGen a b

-- | If LeastGen a b c holds then there exists a substitution s and type c
--   such that (s c = (a, b)).
class LeastGen a b c
class Analyze a b | a -> b
class (Substitution sin, Substitution sout) => LeastGen' a b c sin sout | sin a b c -> sout

-- | Encoding of substitutions as partial maps
data SubstEmpty
instance [incoherent] r ~ TCon0 Bit2 => Analyze (W Bit2) r
instance [incoherent] r ~ TCon0 Bit2 => Analyze Bit2 r
instance [incoherent] r ~ TCon0 Bit1 => Analyze (W Bit1) r
instance [incoherent] r ~ TCon0 Bit1 => Analyze Bit1 r
instance [incoherent] r ~ TCon0 I419 => Analyze (W I419) r
instance [incoherent] r ~ TCon0 I419 => Analyze I419 r
instance [incoherent] (Substitution s, MapsTo s x sx) => MapsTo (SubstCons x' sx' s) x sx
instance [incoherent] Substitution s => MapsTo (SubstCons x sx s) x (Some sx)
instance [incoherent] MapsTo SubstEmpty x None
instance [incoherent] MaybeType (Some a)
instance [incoherent] MaybeType None
instance [incoherent] Substitution s => Substitution (SubstCons x sx s)
instance [incoherent] Substitution SubstEmpty
instance [incoherent] Substitution sin => VarCase (Some c) ab c sin sin
instance [incoherent] Substitution sin => VarCase None ab c sin (SubstCons ab c sin)
instance [incoherent] (Substitution sin, Substitution sout, MapsTo sin (a, b) c', VarCase c' (a, b) c sin sout, Analyze (W c) (TVar c)) => LeastGen' a b c sin sout
instance [incoherent] (LeastGen' a1 b1 c1 s0 s1, LeastGen' a2 b2 c2 s1 s2, LeastGen' a3 b3 c3 s2 s3, LeastGen' a4 b4 c4 s3 s4, LeastGen' a5 b5 c5 s4 s5, d ~ d', d c1 c2 c3 c4 c5 ~ c) => LeastGen' (TCon5 (d () () () () ()) a1 a2 a3 a4 a5) (TCon5 (d' () () () () ()) b1 b2 b3 b4 b5) c s0 s5
instance [incoherent] (LeastGen' a1 b1 c1 s0 s1, LeastGen' a2 b2 c2 s1 s2, LeastGen' a3 b3 c3 s2 s3, LeastGen' a4 b4 c4 s3 s4, d ~ d', d c1 c2 c3 c4 ~ c) => LeastGen' (TCon4 (d () () () ()) a1 a2 a3 a4) (TCon4 (d' () () () ()) b1 b2 b3 b4) c s0 s4
instance [incoherent] (LeastGen' a1 b1 c1 s0 s1, LeastGen' a2 b2 c2 s1 s2, LeastGen' a3 b3 c3 s2 s3, d ~ d', d c1 c2 c3 ~ c) => LeastGen' (TCon3 (d () () ()) a1 a2 a3) (TCon3 (d' () () ()) b1 b2 b3) c s0 s3
instance [incoherent] (LeastGen' a1 b1 c1 s0 s1, LeastGen' a2 b2 c2 s1 s2, d ~ d', d c1 c2 ~ c) => LeastGen' (TCon2 (d () ()) a1 a2) (TCon2 (d' () ()) b1 b2) c s0 s2
instance [incoherent] (LeastGen' a1 b1 c1 s0 s1, d ~ d', d c1 ~ c) => LeastGen' (TCon1 (d ()) a1) (TCon1 (d' ()) b1) c s0 s1
instance [incoherent] (Substitution s0, a ~ c) => LeastGen' (TCon0 a) (TCon0 a) c s0 s0
instance [incoherent] (Analyze a _a, Analyze b _b, LeastGen' _a _b b SubstEmpty sout, Unifies sout a b) => LessGen a b
instance [incoherent] a ~ b => Unifies (SubstCons x y s) a b
instance [incoherent] a ~ b => Unifies SubstEmpty a b
instance [incoherent] (Analyze a _a, Analyze b _b, LeastGen' _a _b c SubstEmpty sout) => LeastGen a b c

module AOP.Internal.JoinpointModel
type FunctionTag = Integer
defaultFunctionTag :: Integer

-- | Join points are function applications. We store the function and the
--   argument, and the function type representation. | We add a FunctionTag
--   value to use for quantification.
data Jp m a b
Jp :: (a -> m b) -> FunctionTag -> a -> TypeRep -> Jp m a b

-- | Creates a join point with given function, tag, and argument
newjp :: (Typeable1Monad m, PolyTypeable (a -> m b)) => (a -> m b) -> FunctionTag -> a -> Jp m a b

-- | Comparing identity of functions:
compareFun :: (Typeable1Monad m, PolyTypeable (a -> m b)) => t -> FunctionTag -> Jp m a b -> Bool

-- | Compare types to see if type representation t is less general | than
--   the type of the function associated to the join point
compareType :: (Typeable1Monad m, PolyTypeable (a -> m b)) => TypeRep -> Jp m a b -> Bool

-- | Gets the argument bound to the join point
getJpArg :: Monad m => Jp m a b -> a

-- | A pointcut is a predicate on the current join point. It is used to
--   identify join points of interest.
data PC m a b
PC :: (forall a' b'. m (Jp m a' b' -> m Bool)) -> PC m a b
mpcond :: PC m a b -> forall a' b'. m (Jp m a' b' -> m Bool)

-- | Extracts the computation resulting of applying a join point to the
--   pointcut
runPC :: Monad m => PC m t t1 -> Jp m a' b' -> m Bool

-- | A RequirePC is not a valid standalone pointcut, it reflects a type
--   requirement and must be combined with a standard PC.
data RequirePC m a b
RequirePC :: (forall a' b'. m (Jp m a' b' -> m Bool)) -> RequirePC m a b
mpcond' :: RequirePC m a b -> forall a' b'. m (Jp m a' b' -> m Bool)
type Advice m a b = (a -> m b) -> a -> m b

-- | Coerces t2 to be compatible with the advice. It passes t1 as a the
--   proceed argument of the advice. This coercion is safe, as described in
--   the paper.
applyAdv :: Advice m a b -> t2 -> t2

-- | Typed first-class aspect. An aspect is tagged with a Unique value,
--   used for identity
data Aspect m a b c d
Aspect :: (PC m a b) -> (Advice m c d) -> AspectHandle -> Aspect m a b c d

-- | Constructs a well-typed aspect
aspect :: (Typeable1Monad m, LessGen (a1 -> b1) (a2 -> m b2)) => PC m a1 b1 -> Advice m a2 b2 -> Aspect m a1 b1 a2 b2

-- | Deletes asp from the aspect environment, used in undeploy
deleteAsp :: Typeable1Monad m => EAspect m -> AspectEnv m -> AspectEnv m

-- | Aspect with hidden types, to be used in the aspect environment
data EAspect m
EAspect :: (Aspect m a b c d) -> EAspect m

-- | Aspect environment
type AspectEnv m = [EAspect m]
instance Typeable1Monad m => Eq (EAspect m)
instance PolyTypeable Unique
instance Show (EAspect m)
instance Show (Aspect m a b c d)
instance Show AspectHandle
instance Typeable1 m => Typeable2 (RequirePC m)
instance Typeable1 m => Typeable2 (PC m)
instance Typeable1 m => Typeable2 (Jp m)

module AOP.Internal.OpenApp
class Typeable1Monad m => OpenApp m
(#) :: (OpenApp m, PolyTypeable (a -> m b)) => (a -> m b) -> a -> m b
class Typeable1Monad m => TaggedApp m
taggedApp :: (TaggedApp m, PolyTypeable (a -> m b)) => FunctionTag -> (a -> m b) -> a -> m b

module AOP.Internal.AOPMonad
class (Typeable1Monad m, OpenApp m) => AOPMonad m
deploy :: (AOPMonad m, LessGen (a -> b) (c -> m d)) => Aspect m a b c d -> m ()
undeploy :: (AOPMonad m, LessGen (a -> b) (c -> m d)) => Aspect m a b c d -> m ()
class (Typeable1Monad m, Typeable1Monad (t m)) => MonadDeploy t m
deployInEnv :: (MonadDeploy t m, LessGen (a -> b) (c -> t m d)) => Aspect (t m) a b c d -> AspectEnv (t m) -> m (AspectEnv (t m))
undeployInEnv :: (MonadDeploy t m, LessGen (a -> b) (c -> t m d)) => Aspect (t m) a b c d -> AspectEnv (t m) -> m (AspectEnv (t m))

module AOP.Internal.PointcutLanguage

-- | Built-in pointcuts pcCall and pcType, and pointcut combinators pcAnd,
--   pcOr and pcNot. Using typeclasses, pointcuts are open for new
--   definitions of functions, like the Function wrapper. We also define
--   pcSeq, that matches a sequence of two join points.
pcCall :: (Typeable1Monad m, PolyTypeable (a -> b)) => (a -> b) -> PC m a b
pcType :: (Typeable1Monad m, PolyTypeable (a -> b)) => (a -> b) -> PC m a b
pcAnd :: (PCAnd m a1 b1 a2 b2 pct, PCAndCtx m a1 b1 a2 b2 pct) => PC m a1 b1 -> pct m a2 b2 -> PC m a1 b1
pcTag :: (Typeable1Monad m, PolyTypeable (a -> b)) => FunctionTag -> PC m a' b'

-- | Logical Or pointcut combinator.
pcOr :: (Typeable1Monad m, LeastGen (a1 -> b1) (a2 -> b2) (agen -> bgen)) => PC m a1 b1 -> PC m a2 b2 -> PC m agen bgen

-- | Logical Not pointcut combinator.
pcNot :: Typeable1Monad m => PC m a1 b1 -> PC m a2 b2
instance Typeable1Monad m => PCAnd m a1 b1 a2 b2 RequirePC
instance Typeable1Monad m => PCAnd m a1 b1 a2 b2 PC

module AOP.Internal.AOT
data AOT m a
mkAOT :: (AspectEnv (AOT m) -> m (a, AspectEnv (AOT m))) -> AOT m a

-- | Runs an AOT computation to obtain a computation in the underlying
--   monad
runAOT :: Typeable1Monad m => AOT m a -> m a

-- | Implementation of woven application for AOT, used in the overloading
--   of #.
wappt :: (Typeable1Monad m, PolyTypeable (a -> AOT m b)) => FunctionTag -> (a -> AOT m b) -> a -> AOT m b
run :: AOT m a -> AspectEnv (AOT m) -> m (a, AspectEnv (AOT m))

-- | Like mapStateT, but specialized to work on the same monad.
mapAOT :: (m (a, AspectEnv (AOT m)) -> m (b, AspectEnv (AOT m))) -> AOT m a -> AOT m b
instance Monad m => Functor (AOT m)
instance Monad m => Monad (AOT m)
instance MonadPlus m => MonadPlus (AOT m)
instance MonadCont m => MonadCont (AOT m)
instance MonadIO m => MonadIO (AOT m)
instance (Typeable1Monad m, MonadReader r m) => MonadReader r (AOT m)
instance (Typeable1Monad m, MonadWriter w m) => MonadWriter w (AOT m)
instance (Typeable1Monad m, MonadError s m) => MonadError s (AOT m)
instance MonadState s m => MonadState s (AOT m)
instance MonadTrans AOT
instance (Typeable1Monad m, MonadDeploy AOT m) => AOPMonad (AOT m)
instance Typeable1Monad m => Typeable1 (AOT m)
instance Typeable1Monad m => TaggedApp (AOT m)
instance Typeable1Monad m => OpenApp (AOT m)

module AOP.ProtectedPointcuts
data ProtectedPC m a b t c d
protectPC :: (Typeable1Monad m, LessGen (a -> b) (c -> m d)) => PC m a b -> Combinator t m c d -> ProtectedPC m a b t c d

-- | Creates a protected aspect based on a given protected pc
pAspect :: (Monad m, LessGen (a -> b) (c -> m d)) => ProtectedPC m a b t c d -> t -> Aspect m a b c d

-- | Logical and combinator for protected pointcuts
ppcAnd :: Typeable1Monad m => ProtectedPC m a b t c d -> ProtectedPC m a b t c d -> ProtectedPC m a b t c d

-- | Logical or combinator for protected pointcuts
ppcOr :: (Typeable1Monad m, LeastGen (a -> b) (c -> d) (agen -> bgen), LessGen (agen -> bgen) (a' -> m b')) => ProtectedPC m a b t a' b' -> ProtectedPC m c d t a' b' -> ProtectedPC m agen bgen t a' b'


-- | Default aspect semantics, aspects are deployed and undeployed at the
--   top level.
module AOP.Default
instance (Typeable1Monad m, Typeable1Monad (t m)) => MonadDeploy t m
