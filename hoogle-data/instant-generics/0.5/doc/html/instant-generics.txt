-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic programming library with a sum of products view
--   
@package instant-generics
@version 0.5


-- | This module defines the basic representation types and the conversion
--   functions <a>to</a> and <a>from</a>. A typical instance for a
--   user-defined datatype would be:
--   
--   <pre>
--   -- Example datatype
--   data Exp = Const Int | Plus Exp Exp
--   
--   -- Auxiliary datatypes for constructor representations
--   data Const
--   data Plus
--   
--   instance Constructor Const where conName _ = "Const"
--   instance Constructor Plus  where conName _ = "Plus"
--   
--   -- Representable instance
--   instance Representable Exp where
--     type Rep Exp = C Const (Var Int) :+: C Plus (Rec Exp :*: Rec Exp)
--   
--     from (Const n)   = L (C (Var n))
--     from (Plus e e') = R (C (Rec e :*: Rec e'))
--   
--     to (L (C (Var n)))            = Const n
--     to (R (C (Rec e :*: Rec e'))) = Plus e e'
--   </pre>
module Generics.Instant.Base
data Z
data U
U :: U
data (:+:) a b
L :: a -> (:+:) a b
R :: b -> (:+:) a b
data (:*:) a b
(:*:) :: a -> b -> (:*:) a b
data CEq c p q a
C :: a -> CEq c p p a
type C c a = CEq c () () a
data Var a
Var :: a -> Var a
data Rec a
Rec :: a -> Rec a

-- | Class for datatypes that represent data constructors. For non-symbolic
--   constructors, only <a>conName</a> has to be defined.
class Constructor c where conFixity = const Prefix conIsRecord = const False
conName :: Constructor c => t c p q a -> String
conFixity :: Constructor c => t c p q a -> Fixity
conIsRecord :: Constructor c => t c p q a -> Bool

-- | Datatype to represent the fixity of a constructor. An infix
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | Datatype to represent the associativy of a constructor.
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
class Representable a where type family Rep a
to :: Representable a => Rep a -> a
from :: Representable a => a -> Rep a
data Nat
Ze :: Nat
Su :: Nat -> Nat
instance Read a => Read (CEq c p p a)
instance Show a => Show (CEq c p q a)
instance Show U
instance Read U
instance (Show a, Show b) => Show (a :+: b)
instance (Read a, Read b) => Read (a :+: b)
instance (Show a, Show b) => Show (a :*: b)
instance (Read a, Read b) => Read (a :*: b)
instance Show a => Show (Var a)
instance Read a => Read (Var a)
instance Show a => Show (Rec a)
instance Read a => Read (Rec a)
instance Eq Associativity
instance Show Associativity
instance Ord Associativity
instance Read Associativity
instance Eq Fixity
instance Show Fixity
instance Ord Fixity
instance Read Fixity


-- | This module defines instances of the <a>Representable</a> class for a
--   number of basic Prelude types.
module Generics.Instant.Instances
instance Constructor Tuple_Pair_
instance Representable (a, b)
instance Constructor Maybe_Just_
instance Constructor Maybe_Nothing_
instance Representable (Maybe a)
instance Constructor List_Cons_
instance Constructor List_Nil_
instance Representable [a]
instance Representable a => Representable (Rec a)
instance Representable a => Representable (Var a)
instance Representable a => Representable (CEq c p q a)
instance (Representable a, Representable b) => Representable (a :+: b)
instance (Representable a, Representable b) => Representable (a :*: b)
instance Representable U
instance Representable Float
instance Representable Bool
instance Representable Char
instance Representable Int


-- | This module contains Template Haskell code that can be used to
--   automatically generate the boilerplate code for the generic deriving
--   library.
module Generics.Instant.TH

-- | Given the type and the name (as string) for the type to derive,
--   generate the <a>Constructor</a> instances and the <a>Representable</a>
--   instance.
deriveAll :: Name -> Q [Dec]

-- | Same as <a>deriveAll</a>, but taking a list as input.
deriveAllL :: [Name] -> Q [Dec]

-- | Given a datatype name, derive datatypes and instances of class
--   <a>Constructor</a>.
deriveConstructors :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the Representable type
--   synonym to derive, generate the <a>Representable</a> instance.
deriveRepresentable :: Name -> Q [Dec]

-- | Derive only the <a>Rep</a> type synonym. Not needed if
--   <a>deriveRepresentable</a> is used.
deriveRep :: Name -> Q [Dec]

-- | Given the names of a generic class, a type to instantiate, a function
--   in the class and the default implementation, generates the code for a
--   basic generic instance.
simplInstance :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Given the names of a generic class, a GADT type to instantiate, a
--   function in the class and the default implementation, generates the
--   code for a basic generic instance. This is tricky in general because
--   we have to analyze the return types of each of the GADT constructors
--   and give instances accordingly.
gadtInstance :: Name -> Name -> Name -> Name -> Q [Dec]
genRepName :: Name -> Name
typeVariables :: Info -> [TyVarBndr]
tyVarBndrToName :: TyVarBndr -> Name
instance Show TypeArgsEqs
instance Lift Associativity
instance Lift Fixity


-- | Generically produce a single finite value of a datatype.
module Generics.Instant.Functions.Empty
class Empty a
empty' :: Empty a => a
empty :: (Representable a, Empty (Rep a)) => a

-- | We use <a>HasRec</a> to check for recursion in the structure. This is
--   used to avoid selecting a recursive branch in the sum case for
--   <a>Empty</a>.
class HasRec a where hasRec' _ = False
hasRec' :: HasRec a => a -> Bool
instance [overlap ok] HasRec Char
instance [overlap ok] HasRec Double
instance [overlap ok] HasRec Float
instance [overlap ok] HasRec Integer
instance [overlap ok] HasRec Int
instance [overlap ok] HasRec (Rec a)
instance [overlap ok] HasRec a => HasRec (CEq c p q a)
instance [overlap ok] (HasRec a, HasRec b) => HasRec (a :+: b)
instance [overlap ok] (HasRec a, HasRec b) => HasRec (a :*: b)
instance [overlap ok] HasRec (Var a)
instance [overlap ok] HasRec U
instance [overlap ok] (Empty a, Empty b) => Empty (a, b)
instance [overlap ok] Empty a => Empty [a]
instance [overlap ok] Empty a => Empty (Maybe a)
instance [overlap ok] Empty Bool
instance [overlap ok] Empty Char
instance [overlap ok] Empty Double
instance [overlap ok] Empty Float
instance [overlap ok] Empty Integer
instance [overlap ok] Empty Int
instance [overlap ok] Empty a => Empty (Rec a)
instance [overlap ok] Empty a => Empty (Var a)
instance [overlap ok] Empty a => Empty (CEq c p p a)
instance [overlap ok] (Empty a, Empty b) => Empty (a :*: b)
instance [overlap ok] (HasRec a, Empty a, Empty b) => Empty (a :+: b)
instance [overlap ok] Empty U


-- | Generically enumerate values
module Generics.Instant.Functions.Enum
class GEnum a
genum' :: GEnum a => [a]
genum :: (Representable a, GEnum (Rep a)) => [a]
instance [overlap ok] GEnum Int
instance [overlap ok] (GEnum f, GEnum g) => GEnum (f :*: g)
instance [overlap ok] (GEnum f, GEnum g) => GEnum (f :+: g)
instance [overlap ok] GEnum (CEq c p q a)
instance [overlap ok] GEnum a => GEnum (CEq c p p a)
instance [overlap ok] GEnum a => GEnum (Var a)
instance [overlap ok] GEnum a => GEnum (Rec a)
instance [overlap ok] GEnum U


-- | Simplified generic show function.
module Generics.Instant.Functions.Show
class GShow a
gshow :: GShow a => a -> String
gshowDefault :: (Representable a, GShow' (Rep a)) => a -> String
instance [overlap ok] GShow a => GShow (Maybe a)
instance [overlap ok] (GShow a, GShow b) => GShow (a, b)
instance [overlap ok] GShow [Char]
instance [overlap ok] GShow a => GShow [a]
instance [overlap ok] GShow Bool
instance [overlap ok] GShow Char
instance [overlap ok] GShow Double
instance [overlap ok] GShow Float
instance [overlap ok] GShow Integer
instance [overlap ok] GShow Int
instance [overlap ok] GShow a => GShow' (Rec a)
instance [overlap ok] GShow a => GShow' (Var a)
instance [overlap ok] (GShow' a, Constructor c) => GShow' (CEq c p q a)
instance [overlap ok] (GShow' a, GShow' b) => GShow' (a :*: b)
instance [overlap ok] (GShow' a, GShow' b) => GShow' (a :+: b)
instance [overlap ok] GShow' U


-- | The equality function.
module Generics.Instant.Functions.Eq
class GEq a
geq :: GEq a => a -> a -> Bool
geqDefault :: (Representable a, GEq' (Rep a)) => a -> a -> Bool
instance [overlap ok] (GEq a, GEq b) => GEq (a, b)
instance [overlap ok] GEq a => GEq [a]
instance [overlap ok] GEq a => GEq (Maybe a)
instance [overlap ok] GEq Bool
instance [overlap ok] GEq Char
instance [overlap ok] GEq Double
instance [overlap ok] GEq Float
instance [overlap ok] GEq Integer
instance [overlap ok] GEq Int
instance [overlap ok] GEq a => GEq' (Rec a)
instance [overlap ok] GEq a => GEq' (Var a)
instance [overlap ok] GEq' a => GEq' (CEq c p q a)
instance [overlap ok] (GEq' a, GEq' b) => GEq' (a :*: b)
instance [overlap ok] (GEq' a, GEq' b) => GEq' (a :+: b)
instance [overlap ok] GEq' U


-- | This module simply reexports all the generic functions' modules.
module Generics.Instant.Functions


-- | Top-level module which re-exports the basic combinators and the
--   generic instances for common datatypes.
module Generics.Instant
