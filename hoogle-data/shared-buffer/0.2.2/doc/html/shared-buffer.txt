-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A circular buffer built on shared memory
--   
--   A circular buffer built on shared memory
@package shared-buffer
@version 0.2.2

module System.Posix.AtomicOps

-- | A reference to a value held in a Foreign Ptr
data FPRef a
newFPRef :: Storable a => a -> IO (FPRef a)
readFPRef :: Storable a => FPRef a -> IO a
writeFPRef :: Storable a => FPRef a -> a -> IO ()

-- | fetch the previous value in an <a>FPRef</a>, and increment the FPRef
--   by the given amount. This operation is atomic.
fetchAddFPRef :: FPRef Int -> Int -> IO Int

-- | increment the FPRef by the given amount and return the new value. This
--   operation is atomic.
addFetchFPRef :: FPRef Int -> Int -> IO Int

module System.Posix.Semaphore.Unsafe

-- | Attempt to lock the semaphore without blocking. Immediately return
--   False if it is not available.
unsafeSemTryWait :: Semaphore -> IO Bool

-- | Unlock the semaphore.
unsafeSemPost :: Semaphore -> IO ()

-- | Return the semaphore's current value.
unsafeSemGetValue :: Semaphore -> IO Int

-- | Attempt to lock the semaphore without blocking, and call error if the
--   semaphore is unavailable.
--   
--   This function should only be called when you want to lock the
--   semaphore, and can guarantee that doing so will not block.
unsafeSemLock :: Semaphore -> IO ()

-- | Wait on a semaphore with a timeout value. Returns True if a lock was
--   acquired, False if it timed out before acquiring a lock.
--   
--   if interrupted by a signal, semTimedWait will retry. An exception will
--   be raised if sem_timedwait() fails for any other reason.
semTimedWait :: Int -> Int -> Semaphore -> IO Bool
instance Show SemT
instance Storable SemT

module System.Posix.SharedBuffer

-- | Open a shared memory object, then mmap it, with the specified flags.
openSBuffer :: String -> CInt -> ShmOpenFlags -> [Protection] -> FileMode -> IO SharedBuffer

-- | Close a reference to a shared memory object. Just calls
--   <tt>munmap</tt>.
closeSharedBuffer :: SharedBuffer -> IO ()

-- | Close a reference to a shared memory object and removes it. Calls
--   <tt>munmap</tt> followed by <tt>shm_unlink</tt>
removeSharedBuffer :: SharedBuffer -> IO ()

-- | Unlink a shared buffer (shm_unlink) without closing the reference to
--   it. Any processes that have already opened the buffer (including this
--   one) should be able to continue accessing it.
--   
--   After <a>unlinkSharedBuffer</a>, references should be closed with
--   closeSharedBuffer.
unlinkSharedBuffer :: SharedBuffer -> IO ()

-- | A shared memory object
data SharedBuffer
SharedBuffer :: {-# UNPACK #-} !(Ptr ()) -> {-# UNPACK #-} !CInt -> String -> SharedBuffer
sbPtr :: SharedBuffer -> {-# UNPACK #-} !(Ptr ())
sbLen :: SharedBuffer -> {-# UNPACK #-} !CInt
sbName :: SharedBuffer -> String
data Flags
MapShared :: Flags
MapPrivate :: Flags

-- | mmap protection level
data Protection
ProtNone :: Protection
ProtRead :: Protection
ProtWrite :: Protection
ProtExec :: Protection
getProtection :: [Protection] -> CInt
writeProtection :: [Protection]
data ShmOpenFlags :: *
ShmOpenFlags :: Bool -> Bool -> Bool -> Bool -> ShmOpenFlags

-- | If true, open the shm object read-write rather than read-only.
shmReadWrite :: ShmOpenFlags -> Bool

-- | If true, create the shm object if it does not exist.
shmCreate :: ShmOpenFlags -> Bool

-- | If true, throw an exception if the shm object already exists.
shmExclusive :: ShmOpenFlags -> Bool

-- | If true, wipe the contents of the shm object after opening it.
shmTrunc :: ShmOpenFlags -> Bool
openReadWriteFlags :: ShmOpenFlags
openReadFlags :: ShmOpenFlags
instance Show SharedBuffer
instance Eq Protection
instance Show Protection
instance Ord Protection
instance Bounded Protection
instance Eq Flags
instance Ord Flags
instance Show Flags
instance Enum Flags
instance Enum Protection


-- | Create a circular buffer over shared memory that can be accessed from
--   separate processes.
--   
--   This module assumes that exactly one WriteBuffer and one ReadBuffer
--   will be used to access the same shared memory object. The ReadBuffer
--   and WriteBuffer may exist in separate processes.
--   
--   to use this library, in one process
--   
--   <pre>
--   bracket (createBuffer "aBuffer" "aSemaphore" 256 0o600) (removeBuffer)
--           (\buffer -&gt; doSomethingWith buffer)
--   </pre>
--   
--   and in the other
--   
--   <pre>
--   bracket (openBuffer "aBuffer" "aSemaphore" 256 0o600) (closeBuffer)
--           (\buffer -&gt; doSomethingWith buffer)
--   </pre>
--   
--   The buffer may be opened from either the reader or writer end, but you
--   should ensure that the buffer is created before it is opened.
--   
--   As the underlying objects (shm and named posix semaphores) exist in
--   the file system, failing to call removeBuffer will leave stale objects
--   in the filesystem.
--   
--   Opening multiple ReadBuffers or WriteBuffers with the same names
--   (whether in one process or several) results in undefined behavior.
module System.Posix.CircularBuffer
data WriteBuffer a
data ReadBuffer a

-- | Functions for creating<i>opening</i>closing/removing shared buffers.
class Shared b
createBuffer :: Shared b => String -> String -> Int -> FileMode -> IO b
openBuffer :: Shared b => String -> String -> Int -> FileMode -> IO b
closeBuffer :: Shared b => b -> IO ()
removeBuffer :: Shared b => b -> IO ()
unlinkBuffer :: Shared b => b -> IO ()
data WaitStrategy
KBlocking :: WaitStrategy
Spin :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> WaitStrategy
SpinContinuous :: {-# UNPACK #-} !Int -> WaitStrategy

-- | Write a value to the writer end.
--   
--   This function is thread-safe.
putBuffer :: Storable a => WriteBuffer a -> a -> IO ()

-- | read the next value from the reader end.
--   
--   This function is *NOT* thread-safe.
getBuffer :: Storable a => WaitStrategy -> ReadBuffer a -> IO a

-- | Try to read the next value from the reader end.
--   
--   This function is *NOT* thread-safe.
tryGetBuffer :: Storable a => ReadBuffer a -> IO (Maybe a)

-- | Write a list of values to the writer end.
--   
--   This function is thread-safe.
putBufferList :: Storable a => WriteBuffer a -> [a] -> IO ()

-- | read all currently available values from the reader end.
--   
--   This function is *NOT* thread-safe.
getAvailable :: Storable a => ReadBuffer a -> IO [a]
sizeOfInt :: Int
instance Shared CircularBuffer
instance Storable a => Shared (ReadBuffer a)
instance Storable a => Shared (WriteBuffer a)


-- | Create a circular buffer over shared memory that can be accessed from
--   separate processes.
--   
--   This module assumes that exactly one WriteBuffer and one ReadBuffer
--   will be used to access the same shared memory object. The ReadBuffer
--   and WriteBuffer may exist in separate processes.
--   
--   to use this library, in one process
--   
--   <pre>
--   bracket (createBuffer "aBuffer" "aSemaphore" 256 0o600) (removeBuffer)
--           (\buffer -&gt; doSomethingWith buffer)
--   </pre>
--   
--   and in the other
--   
--   <pre>
--   bracket (openBuffer "aBuffer" "aSemaphore" 256 0o600) (closeBuffer)
--           (\buffer -&gt; doSomethingWith buffer)
--   </pre>
--   
--   The buffer may be opened from either the reader or writer end, but you
--   should ensure that the buffer is created before it is opened.
--   
--   As the underlying objects (shm and named posix semaphores) exist in
--   the file system, failing to call removeBuffer will leave stale objects
--   in the filesystem.
--   
--   Opening multiple ReadBuffers or WriteBuffers with the same names
--   (whether in one process or several) results in undefined behavior.
module System.Posix.MQueue
data WriteBuffer a
data ReadBuffer a

-- | Functions for creating<i>opening</i>closing/removing shared buffers.
class Shared b
createBuffer :: Shared b => String -> String -> Int -> FileMode -> IO b
openBuffer :: Shared b => String -> String -> Int -> FileMode -> IO b
closeBuffer :: Shared b => b -> IO ()
removeBuffer :: Shared b => b -> IO ()
unlinkBuffer :: Shared b => b -> IO ()

-- | Write a value to the writer end.
--   
--   This function is thread-safe.
putBuffer :: Storable a => WriteBuffer a -> a -> IO ()

-- | read the next value from the reader end.
--   
--   This function is *NOT* thread-safe.
getBuffer :: Storable a => ReadBuffer a -> IO a

-- | Write a list of values to the writer end.
--   
--   This function is thread-safe.
putBufferList :: Storable a => WriteBuffer a -> [a] -> IO ()

-- | read all currently available values from the reader end.
--   
--   This function is *NOT* thread-safe.
getAvailable :: Storable a => ReadBuffer a -> IO [a]
instance Storable a => Shared (ReadBuffer a)
instance Storable a => Shared (WriteBuffer a)
