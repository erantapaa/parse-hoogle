-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for using the Fay Haskell-to-JS compiler with Yesod.
--   
@package yesod-fay
@version 0.8.0


-- | Module to be shared between server and client.
--   
--   This module must be valid for both GHC and Fay.
module Fay.Yesod

-- | A proxy type for specifying what type a command should return. The
--   final field for each data constructor in a command datatype should be
--   <tt>Returns</tt>.
data Returns a
Returns :: Returns a

-- | Call a command.
call :: (Returns a -> command) -> (a -> Fay ()) -> Fay ()
callWithErrorHandling :: (Returns a -> command) -> (a -> Fay ()) -> (Fay ()) -> Fay ()

-- | Run the AJAX command.
ajaxCommand :: Automatic command -> (Automatic a -> Fay ()) -> Fay ()

-- | Run the AJAX command, handling errors as well
ajaxCommandWithErrorHandling :: Automatic command -> (Automatic a -> Fay ()) -> (Fay ()) -> Fay ()
instance Typeable Returns
instance Eq (Returns a)
instance Show (Returns a)
instance Read (Returns a)
instance Data a => Data (Returns a)


-- | Utility functions for using Fay from a Yesod application.
--   
--   This module is intended to be used from your Yesod application, not
--   from your Fay programs.
--   
--   We assume a specific file structure, namely that there is a
--   <tt>fay</tt> folder containing client-side code, and
--   <tt>fay-shared</tt> containing code to be used by both the client and
--   server.
--   
--   The <tt>Fay.Yesod</tt> module (part of this package) is required by
--   both client and server code. However, since Fay does not currently
--   have package management support, we use a bit of a hack: the TH calls
--   in this package will automatically create the necessary
--   <tt>fay/Fay/Yesod.hs</tt> file. Ultimately, we will use a more elegant
--   solution.
--   
--   In the future, if this package proves popular enough, Fay support will
--   likely be built into the scaffolding. In the meantime, you must
--   manually integrate it. In order to take advantage of this module, you
--   should modify your Yesod application as follows:
--   
--   <ul>
--   <li>Modify your <tt>cabal</tt> file to include the <tt>fay-shared</tt>
--   folder when compiling. This can be done by adding a
--   <tt>hs-source-dirs: ., fay-shared</tt> line to your library
--   section.</li>
--   <li>Create the module <tt>SharedTypes</tt> in <tt>fay-shared</tt> and
--   create a <tt>Command</tt> datatype. For an example of what this file
--   should look like, see
--   <a>https://github.com/snoyberg/yesod-fay/blob/master/sample/fay-shared/SharedTypes.hs</a>.</li>
--   <li>Add the function <tt>fayFile</tt> to your <tt>Import</tt> module.
--   See
--   <a>https://github.com/snoyberg/yesod-fay/blob/master/sample/Import.hs</a>
--   for an example.</li>
--   <li>Add a new route at for the Fay subsite. Generally, it will look
--   like <tt>/fay-command FaySiteR FaySite getFaySite</tt>.</li>
--   <li>Import the <tt>SharedTypes</tt> and <tt>Yesod.Fay</tt> modules
--   into your <tt>Foundation.hs</tt> module. Add an instance of
--   <tt>YesodFay</tt> for your application. You should set the
--   <tt>YesodFayCommand</tt> associated type to the <tt>Command</tt>
--   datatype you created. (You may also need to add a <tt>YesodJquery</tt>
--   instance.) Note that this instance must appear after your
--   <tt>parseRoutes</tt>. Set the method <tt>fayRoute</tt> to
--   <tt>FaySiteR</tt> (or whatever you called the subsite route), and
--   implement <tt>yesodFayCommand</tt>. It will generally look something
--   like <tt>yesodFayCommand render command = case command of { ...
--   }</tt>.</li>
--   <li>In order to use Fay, add <tt>$(fayFile "MyModule")</tt> to a
--   widget, and then write the corresponding <tt>fay/MyModule.hs</tt>
--   file. For an example, see
--   <a>https://github.com/snoyberg/yesod-fay/blob/master/sample/fay/Home.hs</a>.</li>
--   </ul>
module Yesod.Fay

-- | Type class for applications using Fay.
--   
--   We depend on <tt>YesodJquery</tt> since the generated client-side code
--   uses jQuery for making Ajax calls. We have an associated type stating
--   the command datatype. Since this datatype must be used by both the
--   client and server, you should place its definition in the
--   <tt>fay-shared</tt> folder.
class YesodJquery master => YesodFay master where fayEncode = const showToFay
yesodFayCommand :: YesodFay master => CommandHandler master
fayRoute :: YesodFay master => Route FaySite -> Route master
fayEncode :: (YesodFay master, Data a) => master -> a -> Maybe Value

-- | A setttings data type for indicating whether the generated Javascript
--   should contain a copy of the Fay runtime or not.
data YesodFaySettings
YesodFaySettings :: String -> Maybe (FilePath, Exp) -> (String -> IO String) -> Maybe (FilePath, Exp) -> Bool -> [String] -> Bool -> YesodFaySettings
yfsModuleName :: YesodFaySettings -> String
yfsSeparateRuntime :: YesodFaySettings -> Maybe (FilePath, Exp)
yfsPostProcess :: YesodFaySettings -> String -> IO String
yfsExternal :: YesodFaySettings -> Maybe (FilePath, Exp)

-- | Note that the server call functions provided for your Fay code require
--   jQuery to be present. If you disable this option and still use the
--   provided server call functions, your code will break.
yfsRequireJQuery :: YesodFaySettings -> Bool
yfsPackages :: YesodFaySettings -> [String]

-- | Perform typechecking when in devel mode?
--   
--   Default: False
yfsTypecheckDevel :: YesodFaySettings -> Bool
yesodFaySettings :: String -> YesodFaySettings

-- | Does a full compile of the Fay code via GHC for type checking, and
--   then embeds the Fay-generated Javascript as a static string. File
--   changes during runtime will not be reflected.
fayFileProd :: YesodFaySettings -> Q Exp

-- | Performs no type checking on the Fay code. Each time the widget is
--   requested, the Fay code will be compiled from scratch to Javascript.
fayFileReload :: YesodFaySettings -> Q Exp

-- | Like <a>fayFileProd</a>, but also takes a function so that the fay
--   configuration can be modified.
--   
--   Since 0.6.1
fayFileProdWithConfig :: (Config -> Config) -> YesodFaySettings -> Q Exp

-- | Like <a>fayFileReload</a>, but also takes the name of a function used
--   to modify the fay configuration can be modified. The type of this
--   function is expected to be <tt>(Config -&gt; Config)</tt>.
--   
--   Since 0.6.1
fayFileReloadWithConfig :: Name -> YesodFaySettings -> Q Exp

-- | A function that takes a String giving the Fay module name, and returns
--   an TH splice that generates a <tt>Widget</tt>.
type FayFile = String -> Q Exp

-- | A function provided by the developer describing how to answer
--   individual commands from client-side code.
--   
--   Due to restrictions of the type system in Fay, we use a relatively
--   simple approach for encoding the return type. In order to specify
--   this, an extra parameter- <tt>Returns</tt>- is passed around, with a
--   phantom type variable stating the expected return type.
--   
--   The first argument to your function is the "respond" function: it
--   takes the extra <tt>Returns</tt> parameter as well as the actual value
--   to be returned, and produces the expected result.
type CommandHandler master = forall s. (forall a. Data a => Returns a -> a -> HandlerT master IO s) -> Value -> HandlerT master IO s

-- | A proxy type for specifying what type a command should return. The
--   final field for each data constructor in a command datatype should be
--   <tt>Returns</tt>.
data Returns a

-- | The Fay subsite.
data FaySite

-- | To be used from your routing declarations.
getFaySite :: a -> FaySite

-- | The <a>type-safe URLs</a> associated with a site argument.
class YesodJquery a
urlJqueryJs :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiJs :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiCss :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiDateTimePicker :: YesodJquery a => a -> Either (Route a) Text
instance YesodFay master => YesodSubDispatch FaySite (HandlerT master IO)
