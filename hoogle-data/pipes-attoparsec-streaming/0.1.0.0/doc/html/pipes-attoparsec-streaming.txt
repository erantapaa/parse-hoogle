-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streaming parsing in the pipes-core framework with Attoparsec.
--   
--   This module exports the single function parse, which can be used to
--   run an Attoparsec parser in a streaming fashion, which means that the
--   parser is not only run incrementally across the input (which can be
--   done with plain Attoparsec or packages like pipes-attoparsec), but
--   that the parse results are delivered incrementally. This package can
--   be seen as a kind of dual to pipes-attoparsec: the latter runs parser
--   incrementally over their input, whereas the former incrementally
--   delivers output.
@package pipes-attoparsec-streaming
@version 0.1.0.0


-- | This module exports the single function parse, which can be used to
--   run an Attoparsec parser in a streaming fashion, which means that the
--   parser is not only run incrementally across the input (which can be
--   done with plain Attoparsec or packages like pipes-attoparsec), but
--   that the parse results are delivered incrementally. This package can
--   be seen as a kind of dual to pipes-attoparsec: the latter runs parser
--   incrementally over their input, whereas the former incrementally
--   delivers output.
--   
--   The following example (to be found with comments in
--   examples/MimeParser.hs in the source tarball) shows an example for
--   parsing e-mail messages incrementally.
--   
--   <pre>
--   import Control.Pipe.Attoparsec.Stream
--   
--   import Data.Word
--   import Control.Pipe
--   import Control.Pipe.Combinators as Combinators
--   import Data.Attoparsec(Parser)
--   import qualified Data.Attoparsec as A
--   import qualified Data.Attoparsec.Char8 as A8
--   import Data.ByteString(ByteString)
--   import qualified Data.ByteString as B
--   import Control.Applicative
--   import Control.Monad.Trans.Class(lift)
--   
--   isToken :: Word8 -&gt; Bool
--   isToken w = w &lt;= 127 &amp;&amp; A.notInClass "\0-\31()&lt;&gt;@,;:\\\"/[]?={} \t" w
--   
--   takeSpaces :: Parser ByteString
--   takeSpaces = B.cons &lt;$&gt; A.satisfy A8.isHorizontalSpace &lt;*&gt; A.takeWhile A8.isHorizontalSpace
--   
--   endOfLine :: Parser ByteString
--   endOfLine = (A.word8 10 &gt;&gt; return "\n") &lt;|&gt; A.string "\r\n"
--   
--   takeAtMost :: Int -&gt; Parser ByteString
--   takeAtMost n = A.scan n (\ n' c -&gt; if n' == 0 then Nothing else (Just (n' - 1)))
--   
--   data Event
--     = Header ByteString ByteString [(ByteString, ByteString, ByteString)]
--     | EndOfHeader ByteString
--     | BodyChunk ByteString
--     | EndOfInput
--     deriving (Show)
--   
--   messageHeader :: Parser (PartialResult Event)
--   messageHeader = do
--     header &lt;- B.cons &lt;$&gt; A.satisfy isToken &lt;*&gt; A.takeWhile isToken
--     delim &lt;- B.snoc &lt;$&gt; A.takeWhile A8.isHorizontalSpace &lt;*&gt; A8.char8 ':'
--     body &lt;-  (,,) &lt;$&gt; A.takeWhile A8.isHorizontalSpace &lt;*&gt;
--                       A.takeTill A8.isEndOfLine &lt;*&gt; endOfLine
--     bodies &lt;- many $ (,,) &lt;$&gt; takeSpaces &lt;*&gt; A.takeTill A8.isEndOfLine &lt;*&gt; endOfLine
--     return (PartialResult (Just (Header header delim (body:bodies))) (Just messageHeader))
--    &lt;|&gt;
--     return (PartialResult Nothing (Just headerEnd))
--   
--   headerEnd :: Parser (PartialResult Event)
--   headerEnd = do
--     s &lt;- endOfLine
--     return $! PartialResult (Just (EndOfHeader s)) (Just bodyChunk)
--   
--   bodyChunk :: Parser (PartialResult Event)
--   bodyChunk = do
--     s &lt;- takeAtMost 10
--     if B.null s
--       then return $ PartialResult (Just EndOfInput) Nothing
--       else return $ PartialResult (Just (BodyChunk s)) (Just bodyChunk)
--   
--   msg :: ByteString
--   msg =
--     "Received  : foo\r\n  cont'd\r\nDate: now\r\n\r\nblabla\r\nsecond line - longer"
--   
--   dump :: Pipe Event Void IO ()
--   dump = go
--    where
--      go = do
--        e &lt;- await
--        lift $ print e
--        go
--   
--   main :: IO ()
--   main = do
--     runPipe $ fromList [msg] &gt;+&gt; parse messageHeader &gt;+&gt; dump
--   </pre>
module Control.Pipe.Attoparsec.Stream

-- | This is the type of exceptions that may be thrown by the streaming
--   parser.
--   
--   Currently, only one exception i defined: it reports Attoparsec parse
--   errors. The values carried by the exceptions are the parse context and
--   the error message, just as in the <tt>Fail</tt> case of Attoparsec's
--   <tt>Result</tt> type.
data StreamException

-- | Parsing failed.
ParseException :: [String] -> String -> StreamException

-- | Parsers which are to be used with the streaming parser Pipe must
--   return values of the following type:
--   
--   <ul>
--   <li>The first parameter of type <tt>Maybe a</tt> is the parser result.
--   When it is a <tt>Just</tt> value, the carried value is delivered to
--   the next Pipe in the Pipeline. When it is <tt>Nothing</tt>, no value
--   is yield.</li>
--   <li>When the second parameter is a <tt>Just p</tt>, the parser
--   <tt>p</tt> is used to continue the parsing process. When it is
--   <tt>Nothing</tt>, the parsing process ends and the Pipeline
--   terminates.</li>
--   </ul>
data PartialResult a
PartialResult :: (Maybe a) -> (Maybe (Parser (PartialResult a))) -> PartialResult a

-- | This function converts an Attoparsec parser over bytestrings which
--   returns a <tt>PartialResult a</tt> into a Pipe that consumes a stream
--   of bytestrings and delivers a stream of <tt>a</tt> values.
parse :: Monad m => Parser (PartialResult a) -> Pipe ByteString a m ()
instance Typeable StreamException
instance Show StreamException
instance Exception StreamException
