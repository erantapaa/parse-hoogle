-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for bindings to the LLVM compiler toolkit.
--   
--   <ul>
--   <li>Exposing the LLVM.Core.Util from llvm to make llvm-base much
--   easier to use. It's for people where llvm high level interface is not
--   suitable but llvm-base is too low level to use</li>
--   </ul>
@package llvm-base-util
@version 3.0.1.0

module LLVM.Core.Util

-- | Type of top level modules.
newtype Module
Module :: ModuleRef -> Module
fromModule :: Module -> ModuleRef
withModule :: Module -> (ModuleRef -> IO a) -> IO a
createModule :: String -> IO Module

-- | Free all storage related to a module. *Note*, this is a dangerous
--   call, since referring to the module after this call is an error. The
--   reason for the explicit call to free the module instead of an
--   automatic lifetime management is that modules have a somewhat
--   complicated ownership. Handing a module to a module provider changes
--   the ownership of the module, and the module provider will free the
--   module when necessary.
destroyModule :: Module -> IO ()

-- | Write a module to a file.
writeBitcodeToFile :: String -> Module -> IO ()

-- | Read a module from a file.
readBitcodeFromFile :: String -> IO Module
getModuleValues :: Module -> IO [(String, Value)]
getFunctions :: Module -> IO [(String, Value)]
getGlobalVariables :: Module -> IO [(String, Value)]
valueHasType :: Value -> Type -> Bool

-- | A module provider is used by the code generator to get access to a
--   module.
newtype ModuleProvider
ModuleProvider :: ForeignPtr ModuleProvider -> ModuleProvider
fromModuleProvider :: ModuleProvider -> ForeignPtr ModuleProvider
withModuleProvider :: ModuleProvider -> (ModuleProviderRef -> IO a) -> IO a

-- | Turn a module into a module provider.
createModuleProviderForExistingModule :: Module -> IO ModuleProvider

-- | Manage compile passes.
newtype PassManager
PassManager :: ForeignPtr PassManager -> PassManager
fromPassManager :: PassManager -> ForeignPtr PassManager
withPassManager :: PassManager -> (PassManagerRef -> IO a) -> IO a

-- | Create a pass manager.
createPassManager :: IO PassManager

-- | Create a pass manager for a module.
createFunctionPassManager :: ModuleProvider -> IO PassManager
runFunctionPassManager :: PassManager -> Function -> IO Int
initializeFunctionPassManager :: PassManager -> IO Int
finalizeFunctionPassManager :: PassManager -> IO Int
newtype Builder
Builder :: ForeignPtr Builder -> Builder
fromBuilder :: Builder -> ForeignPtr Builder
withBuilder :: Builder -> (BuilderRef -> IO a) -> IO a
createBuilder :: IO Builder
positionAtEnd :: Builder -> BasicBlockRef -> IO ()
getInsertBlock :: Builder -> IO BasicBlockRef
type BasicBlock = BasicBlockRef
appendBasicBlock :: Function -> String -> IO BasicBlock
getBasicBlocks :: Value -> IO [(String, Value)]
type Function = ValueRef
addFunction :: Module -> Linkage -> String -> Type -> IO Function
getParam :: Function -> Int -> Value
getParams :: Value -> IO [(String, Value)]
structType :: [Type] -> Bool -> Type
addGlobal :: Module -> Linkage -> String -> Type -> IO Value
constString :: String -> (Value, Int)
constStringNul :: String -> (Value, Int)
constVector :: Int -> [Value] -> Value
constArray :: Type -> Int -> [Value] -> Value
constStruct :: [Value] -> Bool -> Value
makeCall :: Function -> BuilderRef -> [Value] -> IO Value
makeInvoke :: BasicBlock -> BasicBlock -> Function -> BuilderRef -> [Value] -> IO Value
makeCallWithCc :: CallingConvention -> Function -> BuilderRef -> [Value] -> IO Value
makeInvokeWithCc :: CallingConvention -> BasicBlock -> BasicBlock -> Function -> BuilderRef -> [Value] -> IO Value
withValue :: Value -> (Value -> IO a) -> IO a
getInstructions :: Value -> IO [(String, Value)]
getOperands :: Value -> IO [(String, Value)]
hasUsers :: Value -> IO Bool
getUsers :: [Use] -> IO [(String, Value)]
getUses :: Value -> IO [Use]
getUser :: Use -> IO Value
isChildOf :: BasicBlock -> Value -> IO Bool
getDep :: Use -> IO (String, String)

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withEmptyCString :: (CString -> IO a) -> IO a
functionType :: Bool -> Type -> [Type] -> Type
buildEmptyPhi :: BuilderRef -> Type -> IO Value
addPhiIns :: Value -> [(Value, BasicBlock)] -> IO ()
showTypeOf :: Value -> IO String
getValueNameU :: Value -> IO String
getObjList :: (t1 -> (t2 -> IO [Ptr a]) -> t) -> (t2 -> IO (Ptr a)) -> (Ptr a -> IO (Ptr a)) -> t1 -> t
annotateValueList :: [Value] -> IO [(String, Value)]
isConstant :: Value -> IO Bool

-- | Add a control flow graph simplification pass to the manager.
addCFGSimplificationPass :: PassManager -> IO ()

-- | Add a constant propagation pass to the manager.
addConstantPropagationPass :: PassManager -> IO ()
addDemoteMemoryToRegisterPass :: PassManager -> IO ()

-- | Add a global value numbering pass to the manager.
addGVNPass :: PassManager -> IO ()
addInstructionCombiningPass :: PassManager -> IO ()
addPromoteMemoryToRegisterPass :: PassManager -> IO ()
addReassociatePass :: PassManager -> IO ()
addTargetData :: TargetDataRef -> PassManager -> IO ()
instance Typeable Module
instance Typeable ModuleProvider
instance Typeable Builder
instance Typeable PassManager
instance Show Module
instance Show ModuleProvider
instance Show Builder
instance Show PassManager
