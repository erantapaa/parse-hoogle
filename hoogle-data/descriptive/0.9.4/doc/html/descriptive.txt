-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.
--   
@package descriptive
@version 0.9.4


-- | Descriptive parsers.
module Descriptive

-- | Run a consumer.
consume :: Consumer s d Identity a -> s -> Result (Description d) a

-- | Describe a consumer.
describe :: Consumer s d Identity a -> s -> Description d

-- | Run a consumer.
runConsumer :: Monad m => Consumer s d m a -> StateT s m (Result (Description d) a)

-- | Describe a consumer.
runDescription :: Monad m => Consumer s d m a -> StateT s m (Description d)

-- | Description of a consumable thing.
data Description a
Unit :: !a -> Description a
Bounded :: !Integer -> !Bound -> !(Description a) -> Description a
And :: !(Description a) -> !(Description a) -> Description a
Or :: !(Description a) -> !(Description a) -> Description a
Sequence :: ![Description a] -> Description a
Wrap :: a -> !(Description a) -> Description a
None :: Description a

-- | The bounds of a many-consumable thing.
data Bound
NaturalBound :: !Integer -> Bound
UnlimitedBound :: Bound

-- | A consumer.
data Consumer s d m a
Consumer :: StateT s m (Description d) -> StateT s m (Result (Description d) a) -> Consumer s d m a
consumerDesc :: Consumer s d m a -> StateT s m (Description d)
consumerParse :: Consumer s d m a -> StateT s m (Result (Description d) a)

-- | Some result.
data Result e a

-- | The whole process failed.
Failed :: e -> Result e a

-- | The whole process succeeded.
Succeeded :: a -> Result e a

-- | There were errors but we continued to collect all the errors.
Continued :: e -> Result e a

-- | Make a self-describing consumer.
consumer :: (StateT s m (Description d)) -> (StateT s m (Result (Description d) a)) -> Consumer s d m a

-- | Wrap a consumer with another consumer. The type looks more
--   intimidating than it actually is. The source code is trivial. It
--   simply allows for a way to transform the type of the state.
wrap :: (StateT t m (Description d) -> StateT s m (Description d)) -> (StateT t m (Description d) -> StateT t m (Result (Description d) a) -> StateT s m (Result (Description d) b)) -> Consumer t d m a -> Consumer s d m b
instance Show Bound
instance Eq Bound
instance Show a => Show (Description a)
instance Eq a => Eq (Description a)
instance Functor Description
instance (Show e, Show a) => Show (Result e a)
instance (Eq e, Eq a) => Eq (Result e a)
instance (Ord e, Ord a) => Ord (Result e a)
instance (Monoid a, Monad m) => Monoid (Consumer s d m a)
instance Monoid a => Monoid (Result (Description d) a)
instance Monad m => Alternative (Consumer s d m)
instance Monad m => Applicative (Consumer s d m)
instance Monad m => Functor (Consumer s d m)
instance Bifunctor Result
instance Monoid (Description d)


-- | Consuming form a list of characters.
module Descriptive.Char

-- | Consume any character.
anyChar :: Monad m => Consumer [Char] Text m Char

-- | A character consumer.
char :: Monad m => Char -> Consumer [Char] Text m Char

-- | A string consumer.
string :: Monad m => [Char] -> Consumer [Char] Text m [Char]


-- | Validating form with named inputs.
module Descriptive.Form

-- | Consume any input value.
input :: Monad m => Text -> Consumer (Map Text Text) (Form d) m Text

-- | Validate a form input with a description of what's required.
validate :: Monad m => d -> (a -> StateT s m (Maybe b)) -> Consumer s (Form d) m a -> Consumer s (Form d) m b

-- | Form descriptor.
data Form d
Input :: !Text -> Form d
Constraint :: !d -> Form d
instance Show d => Show (Form d)
instance Eq d => Eq (Form d)


-- | Validating indexed formlet with auto-generated input names.
module Descriptive.Formlet

-- | Consume any character.
indexed :: Monad m => Consumer FormletState Formlet m Text

-- | State used when running a formlet.
data FormletState
FormletState :: (Map Integer Text) -> !Integer -> FormletState
formletMap :: FormletState -> (Map Integer Text)
formletIndex :: FormletState -> !Integer

-- | Description of a formlet.
data Formlet
Index :: !Integer -> Formlet
Constrained :: !Text -> Formlet
instance Show Formlet
instance Eq Formlet
instance Show FormletState
instance Eq FormletState


-- | Command-line options parser.
module Descriptive.Options

-- | Find a value flag which must succeed. Removes it from the argument
--   list if it succeeds.
flag :: Monad m => Text -> Text -> v -> Consumer [Text] (Option a) m v

-- | Find a boolean flag. Always succeeds. Omission counts as <a>False</a>.
--   Removes it from the argument list if it returns True.
switch :: Monad m => Text -> Text -> Consumer [Text] (Option a) m Bool

-- | Find an argument prefixed by -X. Removes it from the argument list
--   when it succeeds.
prefix :: Monad m => Text -> Text -> Consumer [Text] (Option a) m Text

-- | Find a named argument e.g. <tt>--name value</tt>. Removes it from the
--   argument list when it succeeds.
arg :: Monad m => Text -> Text -> Consumer [Text] (Option a) m Text

-- | Consume one argument from the argument list and pops it from the start
--   of the list.
anyString :: Monad m => Text -> Consumer [Text] (Option a) m Text

-- | Consume one argument from the argument list which must match the given
--   string, and also pops it off the argument list.
constant :: Monad m => Text -> Text -> v -> Consumer [Text] (Option a) m v

-- | If the consumer succeeds, stops the whole parser and returns
--   <a>Stopped</a> immediately.
stop :: Monad m => Consumer [Text] (Option a) m a -> Consumer [Text] (Option a) m ()

-- | Description of a commandline option.
data Option a
AnyString :: !Text -> Option a
Constant :: !Text -> !Text -> Option a
Flag :: !Text -> !Text -> Option a
Arg :: !Text -> !Text -> Option a
Prefix :: !Text -> !Text -> Option a
Stops :: Option a
Stopped :: !a -> Option a

-- | Make a text description of the command line options.
textDescription :: Description (Option a) -> Text

-- | Make a text description of an option.
textOpt :: (Option a) -> Text
instance Show a => Show (Option a)
instance Eq a => Eq (Option a)


-- | A JSON API which describes itself.
module Descriptive.JSON

-- | Parse from a consumer.
parse :: Monad m => d -> (a -> StateT s m (Maybe b)) -> Consumer s d m a -> Consumer s d m b

-- | Consume an object.
object :: Monad m => Text -> Consumer Object (Doc d) m a -> Consumer Value (Doc d) m a

-- | Consume from object at the given key.
key :: Monad m => Text -> Consumer Value (Doc d) m a -> Consumer Object (Doc d) m a

-- | Optionally consume from object at the given key, only if it exists.
keyMaybe :: Monad m => Text -> Consumer Value (Doc d) m a -> Consumer Object (Doc d) m (Maybe a)

-- | Consume an array.
array :: Monad m => Text -> Consumer Value (Doc d) m a -> Consumer Value (Doc d) m (Vector a)

-- | Consume a string.
string :: Monad m => Text -> Consumer Value (Doc d) m Text

-- | Consume an integer.
integer :: Monad m => Text -> Consumer Value (Doc d) m Integer

-- | Consume an double.
double :: Monad m => Text -> Consumer Value (Doc d) m Double

-- | Parse a boolean.
bool :: Monad m => Text -> Consumer Value (Doc d) m Bool

-- | Expect null.
null :: Monad m => Text -> Consumer Value (Doc d) m ()

-- | Wrap a consumer with a label e.g. a type tag.
label :: Monad m => d -> Consumer s (Doc d) m a -> Consumer s (Doc d) m a

-- | Description of parseable things.
data Doc a
Integer :: !Text -> Doc a
Double :: !Text -> Doc a
Text :: !Text -> Doc a
Boolean :: !Text -> Doc a
Null :: !Text -> Doc a
Object :: !Text -> Doc a
Key :: !Text -> Doc a
Array :: !Text -> Doc a
Label :: !a -> Doc a
instance Typeable Doc
instance Eq a => Eq (Doc a)
instance Show a => Show (Doc a)
instance Data a => Data (Doc a)
