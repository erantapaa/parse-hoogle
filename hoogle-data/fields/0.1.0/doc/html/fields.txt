-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | First-class record field combinators with infix
record field syntax.
--   
--   Using records, especially nested records, in Haskell can sometimes be
--   a bit of a chore. Fortunately, there are several libraries in hackage
--   that make working with records easier. This library is my attempt to
--   build on top of these libraries to make working with records even more
--   pleasant!
--   
--   In most imperative languages, records are accessed using the infix dot
--   operator. Record fields can be read simply by suffixing a record value
--   with '.field' and they can be modified by simply assigning to that
--   location. Although this is not the only way to access records (indeed,
--   Haskell does not use it), many people (including myself) like it. This
--   library attempts to support this style for Haskell records in the
--   following manner:
--   
--   <pre>
--   record.field.subfield      becomes     record .# field # subfield
--   record.field = value       becomes     record .# field =: value
--   </pre>
--   
--   Of course, the infix assignment in Haskell is pure and doesn't
--   actually mutate anything. Rather, a modified version of the record is
--   returned.
--   
--   In addition, the following features are supported:
--   
--   <ul>
--   <li>Accessing several fields simultaneously using tuples. Example:
--   <tt>record .# (field1, field2, field3)</tt></li>
--   <li>Accessing records inside a <tt><a>Functor</a></tt>. Example:
--   <tt>recordInFunctor &lt;.#&gt; field</tt></li>
--   <li>Composing fields with <tt><a>Applicative</a></tt> functors and
--   <tt><a>Monad</a></tt>s. Example: <tt>record .# applicativeField
--   &lt;#&gt; subfield</tt></li>
--   <li>Pattern matching using <tt>ViewPatterns</tt>. Example: <tt>case
--   record of (match field -&gt; 1) -&gt; ...</tt></li>
--   <li>Easy comparisons etc. using <tt><a>onField</a></tt>. Example:
--   <tt>sortBy (compare `onField` field#subfield) records</tt></li>
--   </ul>
--   
--   For a detailed description of usage, see <a>Data.Record.Field</a>.
--   
--   This library is a work-in-progress. Some limitations, deficiencies,
--   points of interest and possible future improvements include:
--   
--   <ul>
--   <li>Currently, a <tt><a>Field</a></tt> instance is only provided for
--   <tt><a>fclabels</a></tt> lenses, since that is what I have personally
--   used. However, there should be nothing in principle that would prevent
--   adding instances for <tt><a>data-accessor</a></tt> and
--   <tt><a>lenses</a></tt>. However, doing this would make this package
--   depend on several record libraries at once, which might not be the
--   best approach. Perhaps this package should be split into several
--   packages?</li>
--   <li>Similarly, the <tt><a>field</a></tt> method currently returns an
--   <tt><a>fclabels</a></tt> lens. To fully decouple this package from
--   <tt><a>fclabels</a></tt>, the <tt><a>field</a></tt> method probably
--   has to be split into <tt>getField</tt>, <tt>setField</tt> and
--   <tt>modField</tt> or something similar.</li>
--   <li>For monad transformers, <tt><a>transformers</a></tt> and
--   <tt><a>monads-fd</a></tt> are used, since those are what
--   <tt><a>fclabels</a></tt> uses. This might be a problem for a program
--   that uses <tt><a>mtl</a></tt> instead.</li>
--   <li>To avoid lots of parentheses, <tt><a>fields</a></tt> uses
--   high-precedence operators at three operator precedence levels. The
--   goal was to make field accesses directly usable in arithmetic
--   expressions (e.g. <tt>r1.#int + r2.#int</tt>). Unfortunately, since
--   Haskell has a finite number of precedence levels, this goal was not
--   properly met, since <tt>(<a>*</a>)</tt> and all higher-precedence
--   arithmetic operators have conflicting precedence levels.</li>
--   <li>Performance has not been analyzed at all. To my knowledge, GHC
--   doesn't do type class specialization or method inlining by default, so
--   needlessly generic code might be generated, even if all types are
--   statically known. I'm hoping that this can be addressed using
--   <tt>SPECIALIZE</tt> and <tt>INLINE</tt> pragmas if it turns out to be
--   an issue.</li>
--   </ul>
@package fields
@version 0.1.0


-- | The <tt><a>Field</a></tt> class and basic operations.
module Data.Record.Field.Basic

-- | Instances of this class can be combined with the functions and
--   operators in this package.
class Field a where { type family Src a :: *; type family Dst a :: *; }
field :: (Field a) => a -> (Src a :-> Dst a)

-- | Return the value of the field in the given record.
(.#) :: (Field a) => Src a -> a -> Dst a

-- | Infix assignment lookalike.
--   
--   <pre>
--   r.#f =: v
--   </pre>
--   
--   returns a modified version of <tt>r</tt> so that the field
--   corresponding to <tt>f</tt> are set to <tt>v</tt>.
(=:) :: (Field a) => a -> Dst a -> Src a :-> Src a

-- | Infix modification lookalike.
--   
--   <pre>
--   r.#f =~ g
--   </pre>
--   
--   returns a modified version of <tt>r</tt> so that the fields
--   corresponding to <tt>f</tt> are modified with the function <tt>g</tt>.
(=~) :: (Field a) => a -> (Dst a -> Dst a) -> Src a :-> Src a

-- | Convenience function for use with the <tt>ViewPatterns</tt> extension.
--   
--   <pre>
--   case r of
--        (match int -&gt; 5)                   -&gt; "It's 5!"
--        (match (int,str#$length) -&gt; (i,l))
--              | i == l                     -&gt; "They're equal!"
--              | otherwise                  -&gt; "Not equal."
--        _                                  -&gt; "Something else."
--   </pre>
match :: (Field a) => a -> Src a -> Dst a
instance Field (a :-> b)


-- | Composition operators for collection fields.
module Data.Record.Field.Indexable

-- | Class of collection types that can be indexed into.
--   
--   TODO: This should probably be a single-parameter type class with two
--   associated types instead.
class Indexable a i where { type family Element a :: *; { unsafeIndexGet i a = maybe notFound id $ indexGet i a where notFound = error "unsafeIndexGet: element not found" } }
indexGet :: (Indexable a i) => i -> a -> Maybe (Element a)
indexSet :: (Indexable a i) => i -> Maybe (Element a) -> a -> a
unsafeIndexGet :: (Indexable a i) => i -> a -> Element a

-- | Compose a field with an <tt><a>Indexable</a></tt> collection safely.
--   
--   <pre>
--   r .# coll #! idx
--   </pre>
--   
--   returns <tt>Nothing</tt> if <tt>idx</tt> was not found from the
--   collection, and <tt>Just v</tt> if <tt>v</tt> was found.
--   
--   <pre>
--   r .# coll #! idx =: Just v
--   </pre>
--   
--   sets the value at <tt>idx</tt> in the collection to be <tt>v</tt>. If
--   the value wasn't in the collection, it's inserted. The exact semantics
--   of insertion depend on the actual collection in question.
--   
--   <pre>
--   r .# coll #! idx =: Nothing
--   </pre>
--   
--   removes the value at <tt>idx</tt> from the collection, if possible.
(#!) :: (Field a, Indexable (Dst a) i) => a -> i -> Src a :-> Maybe (Element (Dst a))

-- | As <tt>(#!)</tt>, but reading a nonexistent value will likely result
--   in a bottom value being returned. Also, the resulting field cannot be
--   used to remove values.
(#!!) :: (Field a, Indexable (Dst a) i) => a -> i -> Src a :-> Element (Dst a)
instance Indexable IntSet Int
instance (a1 ~ a2, Ord a1) => Indexable (Set a1) a2
instance (i1 ~ i2, IArray a e, Ix i1) => Indexable (a i1 e) i2
instance Indexable (IntMap a) Int
instance (k1 ~ k2, Ord k1) => Indexable (Map k1 a) k2
instance (Integral i) => Indexable [a] i


-- | Field combinators.
module Data.Record.Field.Combinators

-- | Identity lens.
idL :: a :-> a

-- | Field composition with arguments in OO-like order.
(#) :: (Field a, Field b, (Dst a) ~ (Src b)) => a -> b -> Src a :-> Dst b

-- | Compose fields with ordinary functions. As functions are one-way, the
--   resulting field cannot be used to set values.
(#$) :: (Field a) => a -> (Dst a -> b) -> Src a :-> b

-- | Infix <tt><a>fmap</a></tt> for fields.
--   
--   Examples:
--   
--   <pre>
--   persons &lt;.#&gt; firstName
--   </pre>
--   
--   <pre>
--   do (v1, v2) &lt;- takeMVar mv &lt;.#&gt; (field1, field2)
--      putStrLn . unlines $ [ "v1: " ++ show v1, "v2: " ++ show v2 ]
--   </pre>
(<.#>) :: (Functor f, Field a) => f (Src a) -> a -> f (Dst a)

-- | <tt><a>Applicative</a></tt> functor composition for fields.
--   
--   <pre>
--   book .# characters &lt;#&gt; lastName
--   </pre>
(<#>) :: (Applicative f, Field a, Field b, (Dst a) ~ (f (Src b))) => a -> b -> Src a :-> f (Dst b)

-- | Flattening monadic composition for fields.
--   
--   <pre>
--   person .# superior &lt;##&gt; superior &lt;##&gt; superior &lt;##&gt; superior
--   </pre>
(<##>) :: (Monad m, Field a, Field b, (Dst a) ~ (m (Src b)), (Dst b) ~ (m c)) => a -> b -> Src a :-> m c

-- | Zippy field reference to be used with <tt>(<a>=*</a>)</tt>.
--   
--   <pre>
--   [ rec1, rec2 ] *# field =* [ value1, value2 ]
--   </pre>
(*#) :: (Field b) => [Src b] -> [b] -> [Dst b]

-- | Zippy infix assignment to be used with <tt>(<a>*#</a>)</tt>.
(=*) :: (Field a) => a -> [Dst a] -> [Src a :-> Src a]

-- | Infix assignment for the State monad.
--   
--   <pre>
--   (field1, field2) &lt;=: (value1, value2)
--   </pre>
(<=:) :: (MonadState (Src a) m, Field a) => a -> Dst a -> m ()

-- | Infix modification for the State monad.
--   
--   <pre>
--   (field1, field2) &lt;=~ (f, g)
--   </pre>
(<=~) :: (MonadState (Src a) m, Field a) => a -> (Dst a -> Dst a) -> m ()

-- | Utility combinator in the manner of
--   <tt><tt>Data.Function.on</tt></tt>.
--   
--   <pre>
--   sortBy (compare `onField` (lastName,firstName)) persons
--   </pre>
onField :: (Field a) => (Dst a -> Dst a -> t) -> a -> Src a -> Src a -> t


-- | Instances for tuples of fields up to a 10-tuple. This allows accessing
--   several fields simultaneously.
--   
--   <pre>
--   r.#(field1, field2, field3#field4) =: (value1, value2, value3)
--   </pre>
--   
--   In addition, the pair instance is recursively defined, which allows
--   stuff like
--   
--   <pre>
--   import Control.Arrow ((***))
--   r.#(field1, (field2, field3)) =~ (f *** g *** h)
--   </pre>
module Data.Record.Field.Tuple
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e, r :-> f, r :-> g, r :-> h, r :-> i, r :-> j)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e, r :-> f, r :-> g, r :-> h, r :-> i)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e, r :-> f, r :-> g, r :-> h)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e, r :-> f, r :-> g)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e, r :-> f)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d, r :-> e)
instance Field (r :-> a, r :-> b, r :-> c, r :-> d)
instance Field (r :-> a, r :-> b, r :-> c)
instance (r ~ Src f, Field f) => Field (r :-> a, f)


-- | Using records, especially nested records, in Haskell can sometimes be
--   a bit of a chore. Fortunately, there are several libraries in hackage
--   to make working with records easier. This library is my attempt to
--   build on top of these libraries to make working with records even more
--   pleasant!
--   
--   In most imperative languages, records are accessed using the infix dot
--   operator. Record fields can be read simply by suffixing a record value
--   with '.field' and they can be modified by simply assigning to that
--   location. Although this is not the only way to access records (indeed,
--   Haskell does not use it), many people (including myself) like it. This
--   library attempts to support this style for Haskell records in the
--   following manner:
--   
--   <pre>
--   record.field.subfield      becomes     record .# field # subfield
--   record.field = value       becomes     record .# field =: value
--   </pre>
--   
--   Of course, the infix assignment in Haskell is pure and doesn't
--   actually mutate anything. Rather, a modified version of the record is
--   returned.
--   
--   Below, a detailed and commented usage example is presented.
--   
--   <pre>
--   import Data.Record.Field
--   import Data.Record.Label hiding ((=:))
--   </pre>
--   
--   Currently, <tt><a>fields</a></tt> is built on top of
--   <tt><a>fclabels</a></tt>, so we import that package as well. We hide
--   the <tt>(=:)</tt> operator because that operator is also used by
--   <tt><a>fields</a></tt> itself.
--   
--   First, let's define some example data types and derive lenses for them
--   using <tt><a>fclabels</a></tt>.
--   
--   <pre>
--   data Person = Person
--        { _firstName :: String
--        , _lastName  :: String
--        , _age       :: Int
--        , _superior  :: Maybe Person
--        } deriving Show
--   
--   data Book = Book
--        { _title      :: String
--        , _author     :: Person
--        , _characters :: [Person]
--        } deriving Show
--   
--   $(mkLabels [''Person, ''Book])
--   </pre>
--   
--   Now, let's define some example data.
--   
--   <pre>
--   howard  = Person "Howard"  "Lovecraft" 46 Nothing
--   charles = Person "Charles" "Ward"      26 Nothing
--   marinus = Person "Marinus" "Willett"   56 Nothing
--   william = Person "William" "Dyer"      53 Nothing
--   frank   = Person "Frank"   "Pabodie"   49 Nothing
--   herbert = Person "Herbert" "West"      32 Nothing
--   abdul   = Person "Abdul"   "Alhazred"  71 Nothing
--   
--   mountains    = Book "At the Mountains of Madness"     undefined []
--   caseOfCDW    = Book "The Case of Charles Dexter Ward" undefined []
--   reanimator   = Book "Herbert West -- The Re-animator" undefined []
--   necronomicon = Book "Necronomicon"                    undefined []
--   
--   persons = [howard, charles, marinus, herbert, william, frank, abdul]
--   books   = [mountains, caseOfCDW, reanimator, necronomicon]
--   </pre>
--   
--   Now, to look up a book's title, we can use the <tt>(<a>.#</a>)</tt>
--   operator, which is the basis of all <tt><a>fields</a></tt>
--   functionality. <tt>(<a>.#</a>)</tt> takes a value of type <tt>a</tt>
--   and a <tt><a>Field</a></tt> from <tt>a</tt> to some other type (in
--   this case, <a>String</a>) and returns the value of that field. Since
--   an <tt><a>fclabels</a></tt> lens is an instance of
--   <tt><a>Field</a></tt>, we can just use the lens directly.
--   
--   <pre>
--   necronomicon .# title
--   -- :: String
--   </pre>
--   
--   The <tt>author</tt> field, however, was left undefined in the above
--   definition. We can set it using the <tt>(=:)</tt> operator
--   
--   <pre>
--   necronomicon .# author =: abdul
--   -- :: Book
--   </pre>
--   
--   A notable detail is that the above expression parenthesizes as
--   <tt>necronomicon .# (author =: abdul)</tt>. The <tt>(=:)</tt> operator
--   takes a <tt><a>Field</a></tt> and a value for that
--   <tt><a>Field</a></tt> and returns a new <tt><a>Field</a></tt> that,
--   when read, returns a modified version of the record.
--   
--   For the sake of the example, I will assume here that the subsequent
--   references to <tt>necronomicon</tt> refer to this modified version
--   (and similarly for all other assignment examples below), even though
--   nothing is mutated in reality.
--   
--   The <tt>(<a>=~</a>)</tt> operator is similar, except that instead of a
--   value, it takes a function that modifies the previous value. For
--   example
--   
--   <pre>
--   howard .# age =~ succ
--   -- :: Person
--   </pre>
--   
--   To access fields in nested records, <tt><a>Field</a></tt>s can be
--   composed using the <tt>(#)</tt> combinator.
--   
--   <pre>
--   necronomicon .# author # lastName
--   -- :: String
--   </pre>
--   
--   If we wish to access a field of several records at once, we can use
--   the <tt>(<a>&lt;.#&gt;</a>)</tt> operator, which can be used to access
--   fields of a record inside a <tt><a>Functor</a></tt>. For example
--   
--   <pre>
--   persons &lt;.#&gt; age
--   -- :: [Int]
--   </pre>
--   
--   This also works for assignment. For example, let's fix the
--   <tt>author</tt> fields of the rest of our books.
--   
--   <pre>
--   [mountains, caseOfCDW, reanimator ] &lt;.#&gt; author =: howard
--   -- :: [Book]
--   </pre>
--   
--   Because <tt>(<a>&lt;.#&gt;</a>)</tt> works for any
--   <tt><a>Functor</a></tt>, we could access values of type <tt>Maybe
--   Book</tt>, <tt>a -&gt; Book</tt> or <tt>IO Book</tt> similarly.
--   
--   We frequently wish to access several fields of a record
--   simultaneously. <tt><a>fields</a></tt> supports this using tuples. A
--   tuple of primitive <tt><a>Field</a></tt>s (currently, "primitive
--   <tt><a>Field</a></tt>" means an <tt><a>fclabels</a></tt> lens) is
--   itself a <tt><a>Field</a></tt>, provided that all the
--   <tt><a>Field</a></tt>s in the tuple have the same source type (ie. you
--   can combine <tt>Book :-&gt; String</tt> and <tt>Book :-&gt; Int</tt>
--   but not <tt>Book :-&gt; String</tt> and <tt>Person :-&gt;
--   String</tt>). For example, we could do
--   
--   <pre>
--   howard .# (firstName, lastName, age)
--   -- :: (String, String, Int)
--   </pre>
--   
--   <tt><a>fields</a></tt> defines instances for tuples of up to 10
--   elements. In addition, the 2-tuple instance is recursively defined so
--   that a tuple <tt>(a, b)</tt> is a <tt><a>Field</a></tt> if <tt>a</tt>
--   is a primitive <tt><a>Field</a></tt> and <tt>b</tt> is <i>any</i>
--   valid field. This makes it possible to do
--   
--   <pre>
--   howard .# (firstName, (lastName, age)) =~ (reverse *** reverse *** negate)
--   -- :: Person
--   </pre>
--   
--   We can also compose a <tt><a>Field</a></tt> with a pure function (for
--   example, a regular record field accessor function) using the
--   <tt>('#$')</tt> combinator. However, since a function is one-way, the
--   resulting <tt><a>Field</a></tt> cannot be used to set values, and
--   trying to do so will result in an <tt><a>error</a></tt>.
--   
--   <pre>
--   howard .# lastName #$ length
--   -- :: Int
--   </pre>
--   
--   If we wish to set fields of several records at once, but so that we
--   can also specify the value individually for each record, we can use
--   the <tt>(<a>*#</a>)</tt> and <tt>(<a>=*</a>)</tt> operators, which can
--   be thought of as "zippy" assignment. They can be used like this
--   
--   <pre>
--   [ mountains, caseOfCDW, reanimator ] *# characters =*
--       [ [ william, frank ]
--       , [ charles, marinus ]
--       , [ herbert ] ]
--   -- :: [Book]
--   </pre>
--   
--   For more complex queries, <tt><a>fields</a></tt> also provides the
--   <tt>(<a>&lt;#&gt;</a>)</tt> and <tt>(<a>&lt;##&gt;</a>)</tt>
--   combinators. <tt>(<a>&lt;#&gt;</a>)</tt> combines a
--   <tt><a>Field</a></tt> of type <tt>a :-&gt; f b</tt> with a field of
--   type <tt>b :-&gt; c</tt>, producing a <tt><a>Field</a></tt> of type
--   <tt>a :-&gt; f c</tt>, where <tt>f</tt> is any
--   <tt><tt>Applicative</tt></tt> functor.
--   
--   <pre>
--   mountains .# characters &lt;#&gt; (lastName, age)
--   -- :: [(String, Int)]
--   </pre>
--   
--   <tt>(<a>&lt;##&gt;</a>)</tt> is similar, except that flattens two
--   monadic <tt><a>Field</a></tt>s together. I.e. the type signature is
--   <tt>a :-&gt; m b -&gt; b :-&gt; m c -&gt; a :-&gt; m c</tt>. For
--   example
--   
--   <pre>
--   frank .# superior &lt;##&gt; superior &lt;##&gt; superior
--   -- :: Maybe Person
--   </pre>
--   
--   Both <tt>(<a>&lt;#&gt;</a>)</tt> and <tt>(<a>&lt;##&gt;</a>)</tt> also
--   support assignment normally, although the exact semantics vary
--   depending on the <tt><tt>Applicative</tt></tt> or
--   <tt><a>Monad</a></tt> in question.
--   
--   We might also like to sort or otherwise manipulate collections of
--   records easily. For this, <tt><a>fields</a></tt> provides the
--   <tt><a>onField</a></tt> combinator in the manner of
--   <tt><tt>Data.Function.on</tt></tt>. For example, to sort a list of
--   books by their authors' last names, we can use
--   
--   <pre>
--   sortBy (compare `onField` author # lastName) books
--   -- :: [Book]
--   </pre>
--   
--   Using tuples, we can also easily define sub-orderings. For example, if
--   we wish to break ties based on the authors' first names and then by
--   ages, we can use
--   
--   <pre>
--   sortBy (compare `onField` author # (lastName, firstName, age)) books
--   -- :: [Book]
--   </pre>
--   
--   Since <tt><a>onField</a></tt> accepts any <tt><a>Field</a></tt>, we
--   can easily specify more complex criteria. To sort a list of books by
--   the sum of their characters' ages (which is a bit silly), we could use
--   
--   <pre>
--   sortBy (compare `onField` (characters &lt;#&gt; age) #$ sum) books
--   -- :: [Book]
--   </pre>
--   
--   <tt><a>fields</a></tt> also attempts to support convenient pattern
--   matching by means of the <tt><a>match</a></tt> function and GHC's
--   <tt>ViewPatterns</tt> extension. To pattern match on records, you
--   could do something like this
--   
--   <pre>
--   case charles of
--        (match lastName        -&gt; "Dexter")    -&gt; Left False
--        (match lastName        -&gt; "Ward")      -&gt; Left True
--        (match (age, superior) -&gt; (a, Just s))
--           | a &gt; 18                            -&gt; Right a
--           | otherwise                         -&gt; Right (s .# age)
--   -- :: Either Bool Int
--   </pre>
--   
--   Finally, a pair of combinators is provided to access record fields of
--   collection types. The <tt>(#!)</tt> combinator has the type <tt>a
--   :-&gt; c b -&gt; i -&gt; a :-&gt; Maybe b</tt>, where <tt>c</tt> is an
--   instance of <tt><a>Indexable</a></tt> and <tt>i</tt> is an index type
--   suitable for <tt>c</tt>. For example, you can use an
--   <tt><a>Integral</a></tt> value to index a <tt><a>String</a></tt> and a
--   value of type <tt>k</tt> to index a <tt>Map k v</tt>. The
--   <tt>(#!!)</tt> combinator is also provided. It doesn't have
--   <tt>Maybe</tt> in the return type, so using a bad index will usually
--   result in an <tt><a>error</a></tt>.
--   
--   Currently, instances are provided for <tt>[a]</tt>,
--   <tt><tt>Data.Map</tt></tt>, <tt><tt>Data.IntMap</tt></tt>,
--   <tt><tt>Data.Array.IArray</tt></tt>, <tt><tt>Data.Set</tt></tt> and
--   <tt><tt>Data.IntSet</tt></tt>.
module Data.Record.Field
