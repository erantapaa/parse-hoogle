-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure-Haskell utilities for dealing with XML with the enumerator package. (deprecated)
--   
--   This package is deprecated in favor of xml-conduit.
--   
--   This package provides parsing and rendering functions for XML. It is
--   based on the datatypes found in the xml-types package. This package is
--   broken up into the following modules:
--   
--   <ul>
--   <li>Text.XML: DOM-based parsing and rendering. This is the most
--   commonly used module.</li>
--   <li>Text.XML.Cursor: A wrapper around <a>Text.XML</a> which allows
--   bidirectional traversing of the DOM, similar to XPath. (Note:
--   Text.XML.Cursor.Generic is the same concept, but will work with any
--   node representation.)</li>
--   <li>Text.XML.Unresolved: A slight modification to <a>Text.XML</a>
--   which does not require all entities to be resolved at parsing. The
--   datatypes are slightly more complicated here, and therefore this
--   module is only recommended when you need to deal directly with raw
--   entities.</li>
--   <li>Text.XML.Stream.Parse: Streaming parser, including some streaming
--   parser combinators.</li>
--   <li>Text.XML.Stream.Render: Streaming renderer.</li>
--   </ul>
--   
--   Additionally, the xml-hamlet package
--   <a>http://hackage.haskell.org/package/xml-hamlet</a> provides a more
--   convenient syntax for creating XML documents. For a more thorough
--   tutorial on this library, please see
--   <a>http://www.yesodweb.com/book/xml-enumerator</a>.
@package xml-enumerator
@version 0.4.4.1


-- | Generalized cursors to be applied to different nodes.
module Text.XML.Cursor.Generic

-- | A cursor: contains an XML <tt>Node</tt> and pointers to its children,
--   ancestors and siblings.
data Cursor node
type Axis node = Cursor node -> [Cursor node]
toCursor :: (node -> [node]) -> node -> Cursor node

-- | The current node.
node :: Cursor node -> node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
instance Show node => Show (Cursor node)


-- | <tt>Enumeratee</tt>s to render XML <a>Event</a>s. Unlike
--   libxml-enumerator and expat-enumerator, this module does not provide
--   IO and ST variants, since the underlying rendering operations are pure
--   functions.
module Text.XML.Stream.Render

-- | Render a stream of <a>Event</a>s into a stream of <a>Builder</a>s.
--   Builders are from the blaze-builder package, and allow the create of
--   optimally sized <a>ByteString</a>s with minimal buffer copying.
renderBuilder :: Monad m => RenderSettings -> Enumeratee Event Builder m b

-- | Render a stream of <a>Event</a>s into a stream of <a>ByteString</a>s.
--   This function wraps around <a>renderBuilder</a> and
--   <a>builderToByteString</a>, so it produces optimally sized
--   <a>ByteString</a>s with minimal buffer copying.
--   
--   The output is UTF8 encoded.
renderBytes :: MonadIO m => RenderSettings -> Enumeratee Event ByteString m b

-- | Render a stream of <a>Event</a>s into a stream of <a>ByteString</a>s.
--   This function wraps around <a>renderBuilder</a>,
--   <a>builderToByteString</a> and <a>renderBytes</a>, so it produces
--   optimally sized <a>ByteString</a>s with minimal buffer copying.
renderText :: MonadIO m => RenderSettings -> Enumeratee Event Text m b
data RenderSettings

-- | The default value for this type.
def :: Default a => a
rsPretty :: RenderSettings -> Bool

-- | Convert a stream of <a>Event</a>s into a prettified one, adding extra
--   whitespace. Note that this can change the meaning of your XML.
prettify :: Monad m => Enumeratee Event Event m a
instance Default RenderSettings


-- | This module provides both a native Haskell solution for parsing XML
--   documents into a stream of events, and a set of parser combinators for
--   dealing with a stream of events.
--   
--   As a simple example, if you have the following XML file:
--   
--   <pre>
--   &lt;?xml version="1.0" encoding="utf-8"?&gt;
--   &lt;people&gt;
--       &lt;person age="25"&gt;Michael&lt;/person&gt;
--       &lt;person age="2"&gt;Eliezer&lt;/person&gt;
--   &lt;/people&gt;
--   </pre>
--   
--   Then this code:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Text.XML.Stream.Parse
--   import Data.Text (Text, unpack)
--   
--   data Person = Person { age :: Int, name :: Text }
--       deriving Show
--   
--   parsePerson = tagName "person" (requireAttr "age") $ \age -&gt; do
--       name &lt;- content
--       return $ Person (read $ unpack age) name
--   
--   parsePeople = tagNoAttr "people" $ many parsePerson
--   
--   main = parseFile_ def "people.xml" $ force "people required" parsePeople
--   </pre>
--   
--   will produce:
--   
--   <pre>
--   [Person {age = 25, name = "Michael"},Person {age = 2, name = "Eliezer"}]
--   </pre>
--   
--   Previous versions of this module contained a number of more
--   sophisticated functions written by Aristid Breitkreuz and Dmitry
--   Olshansky. To keep this package simpler, those functions are being
--   moved to a separate package. This note will be updated with the name
--   of the package(s) when available.
module Text.XML.Stream.Parse

-- | Parses a byte stream into <a>Event</a>s. This function is implemented
--   fully in Haskell using attoparsec-text for parsing. The produced error
--   messages do not give line/column information, so you may prefer to
--   stick with the parser provided by libxml-enumerator. However, this has
--   the advantage of not relying on any C libraries.
--   
--   This relies on <a>detectUtf</a> to determine character encoding, and
--   <a>parseText</a> to do the actual parsing.
parseBytes :: Monad m => ParseSettings -> Enumeratee ByteString Event m a

-- | Parses a character stream into <a>Event</a>s. This function is
--   implemented fully in Haskell using attoparsec-text for parsing. The
--   produced error messages do not give line/column information, so you
--   may prefer to stick with the parser provided by libxml-enumerator.
--   However, this has the advantage of not relying on any C libraries.
parseText :: Monad m => ParseSettings -> Enumeratee Text Event m a

-- | Automatically determine which UTF variant is being used. This function
--   first checks for BOMs, removing them as necessary, and then check for
--   the equivalent of &lt;?xml for each of UTF-8, UTF-16LE<i>BE, and
--   UTF-32LE</i>BE. It defaults to assuming UTF-8.
detectUtf :: Monad m => Enumeratee ByteString Text m a

-- | A helper function which reads a file from disk using <a>enumFile</a>,
--   detects character encoding using <a>detectUtf</a>, parses the XML
--   using <a>parseBytes</a>, and then hands off control to your supplied
--   parser.
parseFile :: ParseSettings -> FilePath -> Iteratee Event IO a -> IO (Either SomeException a)

-- | The same as <a>parseFile</a>, but throws any exceptions.
parseFile_ :: ParseSettings -> FilePath -> Iteratee Event IO a -> IO a

-- | Parse an event stream from a lazy <a>ByteString</a>.
parseLBS :: ParseSettings -> ByteString -> Iteratee Event IO a -> IO (Either SomeException a)

-- | Same as <a>parseLBS</a>, but throws exceptions.
parseLBS_ :: ParseSettings -> ByteString -> Iteratee Event IO a -> IO a
data ParseSettings

-- | The default value for this type.
def :: Default a => a
type DecodeEntities = Text -> Content
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | The most generic way to parse a tag. It takes a predicate for checking
--   if this is the correct tag name, an <a>AttrParser</a> for handling
--   attributes, and then a parser for dealing with content.
--   
--   This function automatically absorbs its balancing closing tag, and
--   will throw an exception if not all of the attributes or child elements
--   are consumed. If you want to allow extra attributes, see
--   <a>ignoreAttrs</a>.
--   
--   This function automatically ignores comments, instructions and
--   whitespace.
tag :: Monad m => (Name -> Maybe a) -> (a -> AttrParser b) -> (b -> Iteratee Event m c) -> Iteratee Event m (Maybe c)

-- | A simplified version of <a>tag</a> which matches against boolean
--   predicates.
tagPredicate :: Monad m => (Name -> Bool) -> AttrParser a -> (a -> Iteratee Event m b) -> Iteratee Event m (Maybe b)

-- | A simplified version of <a>tag</a> which matches for specific tag
--   names instead of taking a predicate function. This is often
--   sufficient, and when combined with OverloadedStrings and the IsString
--   instance of <a>Name</a>, can prove to be very concise.
tagName :: Monad m => Name -> AttrParser a -> (a -> Iteratee Event m b) -> Iteratee Event m (Maybe b)

-- | A further simplified tag parser, which requires that no attributes
--   exist.
tagNoAttr :: Monad m => Name -> Iteratee Event m a -> Iteratee Event m (Maybe a)

-- | Grabs the next piece of content. If none if available, returns
--   <a>empty</a>. This is simply a wrapper around <a>contentMaybe</a>.
content :: Monad m => Iteratee Event m Text

-- | Grabs the next piece of content if available. This function skips over
--   any comments and instructions and concatenates all content until the
--   next start or end tag.
contentMaybe :: Monad m => Iteratee Event m (Maybe Text)

-- | A monad for parsing attributes. By default, it requires you to deal
--   with all attributes present on an element, and will throw an exception
--   if there are unhandled attributes. Use the <a>requireAttr</a>,
--   <a>optionalAttr</a> et al functions for handling an attribute, and
--   <a>ignoreAttrs</a> if you would like to skip the rest of the
--   attributes on an element.
--   
--   <a>Alternative</a> instance behave like <tt>First</tt> monoid. It
--   chooses first parser which doesn't fail.
data AttrParser a

-- | Require that a certain attribute be present and return its value.
requireAttr :: Name -> AttrParser Text

-- | Return the value for an attribute if present.
optionalAttr :: Name -> AttrParser (Maybe Text)
requireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b
optionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)

-- | Skip the remaining attributes on an element. Since this will clear the
--   list of attributes, you must call this <i>after</i> any calls to
--   <a>requireAttr</a>, <a>optionalAttr</a>, etc.
ignoreAttrs :: AttrParser ()

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <a>Just</a>), this function returns
--   <a>Nothing</a>.
--   
--   <pre>
--   orE a b = choose [a, b]
--   </pre>
orE :: Monad m => Iteratee Event m (Maybe a) -> Iteratee Event m (Maybe a) -> Iteratee Event m (Maybe a)

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <a>Just</a>), this function returns
--   <a>Nothing</a>.
choose :: Monad m => [Iteratee Event m (Maybe a)] -> Iteratee Event m (Maybe a)

-- | Keep parsing elements as long as the parser returns <a>Just</a>.
many :: Monad m => Iteratee Event m (Maybe a) -> Iteratee Event m [a]

-- | Force an optional parser into a required parser. All of the <a>tag</a>
--   functions, <a>choose</a> and <a>many</a> deal with <a>Maybe</a>
--   parsers. Use this when you want to finally force something to happen.
force :: Monad m => String -> Iteratee Event m (Maybe a) -> Iteratee Event m a
data XmlException
XmlException :: String -> Maybe Event -> XmlException
xmlErrorMessage :: XmlException -> String
xmlBadInput :: XmlException -> Maybe Event
InvalidEndElement :: Name -> XmlException
InvalidEntity :: Text -> XmlException
UnparsedAttributes :: [(Name, [Content])] -> XmlException
instance Typeable XmlException
instance Show XmlException
instance Alternative AttrParser
instance Applicative AttrParser
instance Functor AttrParser
instance Monad AttrParser
instance Exception XmlException
instance Default ParseSettings


-- | DOM-based XML parsing and rendering.
--   
--   In this module, attribute values and content nodes can contain either
--   raw text or entities. In most cases, these can be fully resolved at
--   parsing. If that is the case for your documents, the <a>Text.XML</a>
--   module provides simplified datatypes that only contain raw text.
module Text.XML.Unresolved
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
readFile :: ParseSettings -> FilePath -> IO (Either SomeException Document)
readFile_ :: ParseSettings -> FilePath -> IO Document
renderLBS :: RenderSettings -> Document -> ByteString
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
parseEnum :: Monad m => ParseSettings -> Enumerator ByteString m Document -> m (Either SomeException Document)
parseEnum_ :: Monad m => ParseSettings -> Enumerator ByteString m Document -> m Document
toEvents :: Document -> [Event]
fromEvents :: Monad m => Iteratee Event m Document
renderBuilder :: MonadIO m => RenderSettings -> Document -> Enumerator Builder m a
renderBytes :: MonadIO m => RenderSettings -> Document -> Enumerator ByteString m a
renderText :: MonadIO m => RenderSettings -> Document -> Enumerator Text m a
data InvalidEventStream
InvalidEventStream :: String -> InvalidEventStream
lazyConsume :: Enumerator a IO () -> IO [a]

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities
data RenderSettings
rsPretty :: RenderSettings -> Bool
instance Typeable InvalidEventStream
instance Show InvalidEventStream
instance Exception InvalidEventStream


-- | DOM-based parsing and rendering.
--   
--   This module requires that all entities be resolved at parsing. If you
--   need to interact with unresolved entities, please use
--   <a>Text.XML.Unresolved</a>. This is the recommended module for most
--   uses cases.
--   
--   While many of the datatypes in this module are simply re-exported from
--   <tt>Data.XML.Types</tt>, <a>Document</a>, <a>Node</a> and
--   <a>Element</a> are all redefined here to disallow the possibility of
--   unresolved entities. Conversion functions are provided to switch
--   between the two sets of datatypes.
--   
--   For simpler, bidirectional traversal of the DOM tree, see the
--   <a>Text.XML.Cursor</a> module.
module Text.XML
data Document
Document :: Prologue -> Element -> [Miscellaneous] -> Document
documentPrologue :: Document -> Prologue
documentRoot :: Document -> Element
documentEpilogue :: Document -> [Miscellaneous]
data Prologue :: *
Prologue :: [Miscellaneous] -> Maybe Doctype -> [Miscellaneous] -> Prologue
prologueBefore :: Prologue -> [Miscellaneous]
prologueDoctype :: Prologue -> Maybe Doctype
prologueAfter :: Prologue -> [Miscellaneous]
data Instruction :: *
Instruction :: Text -> Text -> Instruction
instructionTarget :: Instruction -> Text
instructionData :: Instruction -> Text
data Miscellaneous :: *
MiscInstruction :: Instruction -> Miscellaneous
MiscComment :: Text -> Miscellaneous
data Node
NodeElement :: Element -> Node
NodeInstruction :: Instruction -> Node
NodeContent :: Text -> Node
NodeComment :: Text -> Node
data Element
Element :: Name -> [(Name, Text)] -> [Node] -> Element
elementName :: Element -> Name
elementAttributes :: Element -> [(Name, Text)]
elementNodes :: Element -> [Node]

-- | A fully qualified name.
--   
--   Prefixes are not semantically important; they are included only to
--   simplify pass-through parsing. When comparing names with <a>Eq</a> or
--   <a>Ord</a> methods, prefixes are ignored.
--   
--   The <tt>IsString</tt> instance supports Clark notation; see
--   <a>http://www.jclark.com/xml/xmlns.htm</a> and
--   <a>http://infohost.nmt.edu/tcc/help/pubs/pylxml/etree-QName.html</a>.
--   Use the <tt>OverloadedStrings</tt> language extension for very simple
--   <tt>Name</tt> construction:
--   
--   <pre>
--   myname :: Name
--   myname = "{http://example.com/ns/my-namespace}my-name"
--   </pre>
data Name :: *
Name :: Text -> Maybe Text -> Maybe Text -> Name
nameLocalName :: Name -> Text
nameNamespace :: Name -> Maybe Text
namePrefix :: Name -> Maybe Text

-- | Note: due to the incredible complexity of DTDs, this type only
--   supports external subsets. I've tried adding internal subset types,
--   but they quickly gain more code than the rest of this module put
--   together.
--   
--   It is possible that some future version of this library might support
--   internal subsets, but I am no longer actively working on adding them.
data Doctype :: *
Doctype :: Text -> Maybe ExternalID -> Doctype
doctypeName :: Doctype -> Text
doctypeID :: Doctype -> Maybe ExternalID
data ExternalID :: *
SystemID :: Text -> ExternalID
PublicID :: Text -> Text -> ExternalID
readFile :: ParseSettings -> FilePath -> IO (Either SomeException Document)
readFile_ :: ParseSettings -> FilePath -> IO Document
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
parseEnum :: Monad m => ParseSettings -> Enumerator ByteString m Document -> m (Either SomeException Document)
parseEnum_ :: Monad m => ParseSettings -> Enumerator ByteString m Document -> m Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
parseTextEnum :: Monad m => ParseSettings -> Enumerator Text m Document -> m (Either SomeException Document)
parseTextEnum_ :: Monad m => ParseSettings -> Enumerator Text m Document -> m Document
fromEvents :: Monad m => Iteratee Event m Document
data UnresolvedEntityException
UnresolvedEntityException :: (Set Text) -> UnresolvedEntityException
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
renderLBS :: RenderSettings -> Document -> ByteString
renderText :: RenderSettings -> Document -> Text
renderBytes :: MonadIO m => RenderSettings -> Document -> Enumerator ByteString m a

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities
data RenderSettings
rsPretty :: RenderSettings -> Bool
toXMLDocument :: Document -> Document
fromXMLDocument :: Document -> Either (Set Text) Document
toXMLNode :: Node -> Node
fromXMLNode :: Node -> Either (Set Text) Node
toXMLElement :: Element -> Element
fromXMLElement :: Element -> Either (Set Text) Element
instance Typeable Element
instance Typeable Node
instance Typeable Document
instance Typeable UnresolvedEntityException
instance Show Element
instance Eq Element
instance Show Node
instance Eq Node
instance Show Document
instance Eq Document
instance Show UnresolvedEntityException
instance Exception UnresolvedEntityException


-- | This module provides for simple DOM traversal. It is inspired by
--   XPath. There are two central concepts here:
--   
--   <ul>
--   <li>A <a>Cursor</a> represents a node in the DOM. It also contains
--   information on the node's <i>location</i>. While the <a>Node</a>
--   datatype will only know of its children, a <tt>Cursor</tt> knows about
--   its parent and siblings as well. (The underlying mechanism allowing
--   this is called a zipper, see
--   <a>http://www.haskell.org/haskellwiki/Zipper</a> and
--   <a>http://www.haskell.org/haskellwiki/Tying_the_Knot</a>.)</li>
--   <li>An <a>Axis</a>, in its simplest form, takes a <tt>Cursor</tt> and
--   returns a list of <tt>Cursor</tt>s. It is used for selections, such as
--   finding children, ancestors, etc. Axes can be chained together to
--   express complex rules, such as all children named <i>foo</i>.</li>
--   </ul>
--   
--   The terminology used in this module is taken directly from the XPath
--   specification: <a>http://www.w3.org/TR/xpath/</a>. For those familiar
--   with XPath, the one major difference is that attributes are not
--   considered nodes in this module.
module Text.XML.Cursor

-- | A cursor: contains an XML <a>Node</a> and pointers to its children,
--   ancestors and siblings.
type Cursor = Cursor Node

-- | The type of an Axis that returns a list of Cursors. They are roughly
--   modeled after <a>http://www.w3.org/TR/xpath/#axes</a>.
--   
--   Axes can be composed with <a>&gt;=&gt;</a>, where e.g. <tt>f &gt;=&gt;
--   g</tt> means that on all results of the <tt>f</tt> axis, the
--   <tt>g</tt> axis will be applied, and all results joined together.
--   Because Axis is just a type synonym for <tt>Cursor -&gt;
--   [Cursor]</tt>, it is possible to use other standard functions like
--   <a>&gt;&gt;=</a> or <a>concatMap</a> similarly.
--   
--   The operators <tt>&amp;|</tt>, <tt>&amp;/</tt>, <tt>&amp;//</tt> and
--   <tt>&amp;.//</tt> can be used to combine axes so that the second axis
--   works on the context nodes, children, descendants, respectively the
--   context node as well as its descendants of the results of the first
--   axis.
--   
--   The operators <tt>$|</tt>, <tt>$/</tt>, <tt>$//</tt> and <tt>$.//</tt>
--   can be used to apply an axis (right-hand side) to a cursor so that it
--   is applied on the cursor itself, its children, its descendants,
--   respectively itself and its descendants.
--   
--   Note that many of these operators also work on <i>generalised Axes</i>
--   that can return lists of something other than Cursors, for example
--   Content elements.
type Axis = Cursor -> [Cursor]

-- | Convert a <a>Document</a> to a <a>Cursor</a>. It will point to the
--   document root.
fromDocument :: Document -> Cursor

-- | Convert a <a>Node</a> to a <a>Cursor</a> (without parents).
fromNode :: Node -> Cursor

-- | Cut a cursor off from its parent. The idea is to allow restricting the
--   scope of queries on it.
cut :: Cursor -> Cursor

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The current node.
node :: Cursor node -> node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | Filter cursors that don't pass a check.
check :: Boolean b => (Cursor -> b) -> Axis

-- | Filter nodes that don't pass a check.
checkNode :: Boolean b => (Node -> b) -> Axis

-- | Filter elements that don't pass a check, and remove all non-elements.
checkElement :: Boolean b => (Element -> b) -> Axis

-- | Filter elements that don't pass a name check, and remove all
--   non-elements.
checkName :: Boolean b => (Name -> b) -> Axis

-- | Remove all non-elements. Compare roughly to XPath: <i>A node test * is
--   true for any node of the principal node type. For example, child::*
--   will select all element children of the context node [...]</i>.
anyElement :: Axis

-- | Select only those elements with a matching tag name. XPath: <i>A node
--   test that is a QName is true if and only if the type of the node (see
--   [5 Data Model]) is the principal node type and has an expanded-name
--   equal to the expanded-name specified by the QName.</i>
element :: Name -> Axis

-- | Select only those elements with a loosely matching tag name. Namespace
--   and case are ignored. XPath: <i>A node test that is a QName is true if
--   and only if the type of the node (see [5 Data Model]) is the principal
--   node type and has an expanded-name equal to the expanded-name
--   specified by the QName.</i>
laxElement :: Text -> Axis

-- | Select only text nodes, and directly give the <tt>Content</tt> values.
--   XPath: <i>The node test text() is true for any text node.</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
content :: Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). XPath: <i>the attribute axis contains the attributes of the
--   context node; the axis will be empty unless the context node is an
--   element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
attribute :: Name -> Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). Namespace and case are ignored. XPath: <i>the attribute axis
--   contains the attributes of the context node; the axis will be empty
--   unless the context node is an element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
laxAttribute :: Text -> Cursor -> [Text]

-- | Select only those element nodes with the given attribute.
hasAttribute :: Name -> Axis

-- | Select only those element nodes containing the given attribute
--   key/value pair.
attributeIs :: Name -> Text -> Axis

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Something that can be used in a predicate check as a boolean.
class Boolean a
bool :: Boolean a => a -> Bool
force :: Failure e f => e -> [a] -> f a
forceM :: Failure e f => e -> [f a] -> f a
instance Boolean (Either a b)
instance Boolean (Maybe a)
instance Boolean [a]
instance Boolean Bool
