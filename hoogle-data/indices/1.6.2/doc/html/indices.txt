-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multi-dimensional statically bounded indices.
--   
--   Multi-dimensional statically bounded indices, with operations that
--   unroll.
@package indices
@version 1.6.2


-- | The indices supplied by this module are static type and value-level
--   linked lists. Since their type gives us information about them,
--   recursion on indices can be unrolled easily.
--   
--   Indices look like <tt> x:.y:.Z :: i:.j:.Z </tt>. The value is the
--   actual index used, and the type is the upper-bound on that index.
--   
--   For instance, one index of a 4x4 matrix is <tt> 2:.2:.Z :: 3:.3:.Z
--   </tt>, and another index for a 1024x1024x1024 cube is <tt>
--   512:.512:.512:.Z :: 1024:.1024:.1024:.Z </tt>
module Data.Index
class Ord n => Dim n where fromIndex = fromIndex' Proxy
each :: Dim n => Int -> n
rank :: Dim n => n -> Int
size :: Dim n => proxy n -> Int
next :: Dim n => n -> n
prev :: Dim n => n -> n
toIndex :: Dim n => n -> Int
fromIndex :: Dim n => Int -> n
correct :: Dim n => n -> n
zero :: Dim a => a
class Rank a b
setBound :: Rank a b => a -> b

-- | Index constructor, analogous to <tt>:</tt>
--   
--   The <a>Applicative</a> and <a>Monad</a> instances multiply in their
--   bind operations, and their 'return'/'pure' creates an index whose
--   first dimension is 1.
data (:.) a b
(:.) :: {-# UNPACK #-} !Int -> !b -> (:.) a b

-- | The zero index, used to end indices, just as '[]' ends a list.
data Z
Z :: Z

-- | Select whether to generate an unrolled loop or just the loop at
--   compile-time.
data Mode :: * -> *
Unroll :: Mode i
Roll :: Mode i

-- | You might prefer to use <a>dimr</a>
roll :: Dim a => Proxy a -> Mode a

-- | You might prefer to use <a>dimu</a>
unroll :: Ranged a => Proxy a -> Mode a
modeProxy :: Mode a -> Proxy a

-- | Lazy right fold over a range.
foldlRange :: Mode n -> (b -> n -> b) -> b -> b

-- | Lazy right fold over a range.
foldrRange :: Mode n -> (n -> b -> b) -> b -> b

-- | Compute something from a range
withRange :: Applicative m => Mode a -> (a -> m ()) -> m ()

-- | Strict left fold over the <i>raw</i> <a>Int</a> indices under a range
foldlRangeIndices :: Mode n -> (b -> Int -> b) -> b -> b

-- | Lazy right fold over the <i>raw</i> <a>Int</a> indices under a range
foldrRangeIndices :: Mode n -> (Int -> b -> b) -> b -> b

-- | Compute something using the <i>raw</i> indices under a range
withRangeIndices :: Applicative m => Mode n -> (Int -> m ()) -> m ()

-- | Types that support static range operations
class (Dim n, Range (ToPeano (Size n))) => Ranged n
class Range (n :: Peano)

-- | Peano numbers
data Peano
Zero :: Peano
Succ :: Peano -> Peano

-- | Convert a <a>Nat</a> to a type-level <a>Peano</a>

-- | Compute the size of an index

-- | Create a bound for use with e.g. "Data.Array.array"
bounds :: (Dim a, Bounded a) => Proxy a -> (a, a)

-- | The range of an index
range :: Mode n -> [n]
dimHead :: KnownNat x => x :. xs -> Int
dimTail :: x :. xs -> xs
pdimHead :: KnownNat x => proxy (x :. xs) -> Int
pdimTail :: proxy (x :. xs) -> Proxy xs

-- | <pre>
--   fromInteger . natVal
--   </pre>
cnat :: KnownNat n => proxy (n :: Nat) -> Int

-- | Expands to a <a>Proxy</a> with the phantom type being the dimension
--   specified. Works in types and expressions.
--   
--   Examples:
--   
--   <pre>
--   id [dim|3 4 5|] ==&gt; id (Proxy :: Proxy (3:.4:.5:.Z))
--   </pre>
--   
--   <pre>
--   Proxy :: [dim|3 4 5|] ==&gt; Proxy :: Proxy (3:.4:.5:.Z)
--   </pre>
dim :: QuasiQuoter

-- | Same as <a>dim</a>, but create an <a>Unroll</a> instead of a
--   <a>Proxy</a>.
dimu :: QuasiQuoter

-- | Same as <a>dim</a>, but create a <a>Roll</a> instead of a
--   <a>Proxy</a>.
dimr :: QuasiQuoter
instance Typeable Z
instance Show b => Show (a :. b)
instance Read b => Read (a :. b)
instance Eq b => Eq (a :. b)
instance Ord b => Ord (a :. b)
instance Generic (a :. b)
instance Functor ((:.) a)
instance Foldable ((:.) a)
instance Traversable ((:.) a)
instance Show Z
instance Read Z
instance Eq Z
instance Ord Z
instance Data Z
instance Generic Z
instance Datatype D1:.
instance Constructor C1_0:.
instance Datatype D1Z
instance Constructor C1_0Z
instance Range n => Range ('Succ n)
instance Range 'Zero
instance (Dim n, Range (ToPeano (Size n))) => Ranged n
instance (Ranged (x :. xs), Num xs) => Ix (x :. xs)
instance Ix Z
instance KnownNat s => Monad ((:.) s)
instance KnownNat s => Applicative ((:.) s)
instance (Dim (x :. xs), Monoid xs) => Monoid (x :. xs)
instance Monoid Z
instance Dim (x :. xs) => Bounded (x :. xs)
instance Bounded Z
instance (Integral xs, Dim (x :. xs), Enum (x :. xs)) => Integral (x :. xs)
instance Integral Z
instance Dim (x :. xs) => Enum (x :. xs)
instance Enum Z
instance (Num (x :. xs), Dim (x :. xs)) => Real (x :. xs)
instance Real Z
instance Dim (x :. xs) => Num (x :. xs)
instance Num Z
instance (KnownNat x, Dim xs) => Dim (x :. xs)
instance Dim Z
instance Rank xs ys => Rank (x :. xs) (y :. ys)
instance Rank Z Z
