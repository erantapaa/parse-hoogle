-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A software defined radio library
--   
--   Write software defined radio applications in Haskell.
--   
--   Features:
--   
--   <ul>
--   <li>Signal processing blocks can be chained together using the
--   <a>Pipes</a> library</li>
--   <li>Zero copy design</li>
--   <li>Signal processing functions are implemented in both Haskell and C
--   (with SIMD acceleration)</li>
--   <li>Can FIR filter, decimate and resample</li>
--   <li>Helper functions for FIR filter design using window functions and
--   plotting of the frequency response</li>
--   <li>FFTs using <a>FFTW</a></li>
--   <li>Line and waterfall plots using OpenGL</li>
--   <li>FM demodulation</li>
--   <li>PulseAudio sound sink</li>
--   <li><a>rtl-sdr</a> based radio source supported and other sources are
--   easily added</li>
--   </ul>
--   
--   See <a>https://github.com/adamwalker/sdr</a> for more features and
--   screenshots.
--   
--   A collection of simple apps that use this library can be found
--   <a>here</a>. These include an FM radio receiver, an OpenGL waterfall
--   plotter and an AM radio receiver.
@package sdr
@version 0.1.0.3


-- | Utilities for parsing command line arguments that might be useful when
--   writing a SDR application. Uses the optparse-applicative library.
module SDR.ArgUtils

-- | Parse a number that may have a decimal point and a suffix, e.g. 2.56M
parseSize :: ReadM Integer


-- | Pipes utility functions
module SDR.PipeUtils

-- | Fork a pipe
fork :: Monad m => Producer a m r -> Producer a (Producer a m) r

-- | Combine two consumers into a single consumer
combine :: Monad m => Consumer a m r -> Consumer a m r -> Consumer a m r

-- | A consumer that prints everything to stdout
printStream :: (Show a) => Int -> Consumer a IO ()

-- | A consumer that discards everything
devnull :: Monad m => Consumer a m ()

-- | Passthrough pipe that prints the sample rate
rate :: Int -> Pipe a a IO b


-- | Utility functions for serializing and deserializing samples.
module SDR.Serialize

-- | Convert a Vector of Floats to a ByteString.
floatVecToByteString :: Vector v Float => v Float -> ByteString

-- | Convert a ByteString to a Vector of Floats.
floatVecFromByteString :: Vector v Float => ByteString -> v Float

-- | Convert a Vector of Doubles to a ByteString.
doubleVecToByteString :: Vector v Double => v Double -> ByteString

-- | Convert a ByteString to a Vector of Doubles.
doubleVecFromByteString :: Vector v Double => ByteString -> v Double

-- | Convert a Vector of Storable values to a ByteString. This is fast as
--   it is just a cast.
toByteString :: Storable a => Vector a -> ByteString

-- | Convert a ByteString to a Vector of Storable values. This is fast as
--   it is just a cast.
fromByteString :: Storable a => ByteString -> Vector a

-- | Given a Handle, create a Consumer that dumps the Vectors written to it
--   to a Handle.
toHandle :: (Storable a) => Handle -> Consumer (Vector a) IO ()

-- | Given a Handle, create a Producer that creates Vectors from data read
--   from the Handle.
fromHandle :: (Storable a) => Int -> Handle -> Producer (Vector a) IO ()


-- | Filter design and plotting of frequency responses.
module SDR.FilterDesign

-- | Compute a sinc function
sinc :: (Floating n, Vector v n) => Int -> n -> v n

-- | Compute a Hanning window.
hanning :: (Floating n, Vector v n) => Int -> v n

-- | Compute a Hamming window.
hamming :: (Floating n, Vector v n) => Int -> v n

-- | Compute a Blackman window.
blackman :: (Floating n, Vector v n) => Int -> v n
windowedSinc :: (Floating n, Vector v n) => Int -> n -> (Int -> v n) -> v n

-- | Given filter coefficients, plot their frequency response and save the
--   graph as "frequency_response.png".
plotFrequency :: [Double] -> IO ()


-- | Fast FFTs using FFTW
module SDR.FFT

-- | Compute a vector of alternating 1s and 0s of the given size.
fftFixup :: (Vector v n, Num n) => Int -> v n

-- | Compute a Hamming window.
hamming :: (Floating n, Vector v n) => Int -> v n

-- | Compute a Hanning window.
hanning :: (Floating n, Vector v n) => Int -> v n

-- | Compute a Blackman window.
blackman :: (Floating n, Vector v n) => Int -> v n

-- | Creates a Pipe that performs a complex to complex DFT.
fftw :: (Vector v (Complex CDouble)) => Int -> IO (Pipe (v (Complex CDouble)) (Vector (Complex CDouble)) IO ())

-- | Creates a pipe that performs a real to complex DFT.
fftwReal :: (Vector v CDouble) => Int -> IO (Pipe (v CDouble) (Vector (Complex CDouble)) IO ())

-- | Creates a pipe that uses multiple threads to perform complex to
--   complex DFTs in a pipelined fashion. Each time a buffer is consumed,
--   it is given to a pool of threads to perform the DFT. Then, if a thread
--   has finished performing a previous DFT, the result is yielded.
fftwParallel :: (Vector v (Complex CDouble)) => Int -> Int -> IO (Pipe (v (Complex CDouble)) (Vector (Complex CDouble)) IO ())


-- | Various Vector based utility functions
module SDR.VectorUtils

-- | Like mapAccumL but monadic and over vectors. Doesn't return the
--   accumulator at the end because it doesn't seem to be possible to do
--   this with the Stream datatype, making this function pretty useless.
mapAccumMV :: (Monad m) => (acc -> x -> m (acc, y)) -> acc -> Stream m x -> Stream m y

-- | Create a vector from another vector containing only the elements that
--   occur every stride elements in the source vector.
stride :: Vector v a => Int -> v a -> v a

-- | Fill a mutable vector from a monadic stream
fill :: (PrimMonad m, Functor m, MVector vm a) => MStream m a -> vm (PrimState m) a -> m ()


-- | FM demodulation pipes
module SDR.Demod

-- | FM demodulate a stream of complex samples
fmDemodStr :: (RealFloat a) => Complex a -> Stream (Complex a) -> Stream a

-- | FM demodulate a vector of complex samples
fmDemodVec :: (RealFloat a, Vector v (Complex a), Vector v a) => Complex a -> v (Complex a) -> v a

-- | Pipe that performs FM demodulation
fmDemod :: (RealFloat a, Vector v (Complex a), Vector v a) => Pipe (v (Complex a)) (v a) IO ()


-- | Create graphical plots of signals and their spectrums. Uses OpenGL.
module SDR.Plot

-- | Create a window and plot a dynamic line graph of the incoming data.
plotLine :: Int -> Int -> Int -> Int -> EitherT String IO (Consumer (Vector GLfloat) IO ())

-- | Create a window and plot a dynamic line graph of the incoming data.
--   With Axes.
plotLineAxes :: Int -> Int -> Int -> Int -> Render () -> EitherT String IO (Consumer (Vector GLfloat) IO ())

-- | Create a window and plot a waterfall of the incoming data.
plotWaterfall :: Int -> Int -> Int -> Int -> [GLfloat] -> EitherT String IO (Consumer (Vector GLfloat) IO ())

-- | Create a window and plot a dynamic filled in line graph of the
--   incoming data.
plotFill :: Int -> Int -> Int -> [GLfloat] -> EitherT String IO (Consumer (Vector GLfloat) IO ())

-- | Create a window and plot a dynamic filled in line graph of the
--   incoming data. With Axes.
plotFillAxes :: Int -> Int -> Int -> [GLfloat] -> Render () -> EitherT String IO (Consumer (Vector GLfloat) IO ())

-- | Create a Cairo <a>Render</a> monad that draws a set of axes with 0 at
--   the bottom left.
zeroAxes :: Int -> Int -> Double -> Double -> Render ()

-- | Create a Cairo <a>Render</a> monad that draws a set of axes with the X
--   axis centered on a specified value.
centeredAxes :: Int -> Int -> Double -> Double -> Double -> Render ()


-- | This module is for detecting which SIMD instruction sets your CPU
--   supports. In particular, it can detect SSE4.2, AVX and AVX2.
module SDR.CPUID

-- | Execute the CPUID instruction
cpuid :: Word32 -> IO (Word32, Word32, Word32, Word32)

-- | Execute the CPUID instruction setting ECX as well
cpuidExtended :: Word32 -> Word32 -> IO (Word32, Word32, Word32, Word32)

-- | Information about the features supported by your CPU
data CPUInfo
[CPUInfo] :: Word32 -> Maybe Word32 -> CPUInfo
[features] :: CPUInfo -> Word32
[extendedFeatures] :: CPUInfo -> Maybe Word32

-- | Get a <a>CPUInfo</a>
getCPUInfo :: IO CPUInfo

-- | Check if the CPU supports SSE4.2
hasSSE42 :: CPUInfo -> Bool

-- | Check if the CPU supports AVX
hasAVX :: CPUInfo -> Bool

-- | Check if the CPU supports AVX2
hasAVX2 :: CPUInfo -> Bool

-- | Convenience function for selecting a function based on the features
--   that the CPU supports
featureSelect :: CPUInfo -> a -> [(CPUInfo -> Bool, a)] -> a


-- | Various utiliy signal processing functions
module SDR.Util

-- | A class for things that can be multiplied by a scalar.
class Mult a b
mult :: Mult a b => a -> b -> a

-- | Create a vector of complex float samples from a vector of interleaved
--   I Q component bytes.
makeComplexBufferVect :: (Num a, Integral a, Num b, Fractional b, Vector v1 a, Vector v2 (Complex b)) => v1 a -> v2 (Complex b)

-- | Same as <a>makeComplexBufferVect</a> but written in C and specialized
--   for Floats
convertC :: Vector CUChar -> Vector (Complex Float)

-- | Same as <a>makeComplexBufferVect</a> but written in C using SSE
--   intrinsics and specialized for Floats
convertCSSE :: Vector CUChar -> Vector (Complex Float)

-- | Same as <a>makeComplexBufferVect</a> but written in C using AVX
--   intrinsics and specialized for Floats
convertCAVX :: Vector CUChar -> Vector (Complex Float)

-- | Create a vector of complex float samples from a vector of interleaved
--   I Q component bytes. Uses the fastest SIMD instruction set your
--   processor supports.
convertFast :: CPUInfo -> Vector CUChar -> Vector (Complex Float)

-- | Scale a vector, written in C
scaleC :: Float -> Vector Float -> MVector RealWorld Float -> IO ()

-- | Scale a vector, written in C using SSE intrinsics
scaleCSSE :: Float -> Vector Float -> MVector RealWorld Float -> IO ()

-- | Scale a vector, written in C using AVX intrinsics
scaleCAVX :: Float -> Vector Float -> MVector RealWorld Float -> IO ()

-- | Scale a vector. Uses the fastest SIMD instruction set your processor
--   supports.
scaleFast :: CPUInfo -> Float -> Vector Float -> MVector RealWorld Float -> IO ()

-- | Apply a function to both parts of a complex number
cplxMap :: (a -> b) -> Complex a -> Complex b

-- | Multiplication by this vector shifts all frequencies up by 1/4 of the
--   sampling frequency
quarterBandUp :: (Vector v (Complex n), Num n) => Int -> v (Complex n)
instance Num a => Mult a a
instance Num a => Mult (Complex a) a


-- | Functions used internally by the SDR.Filter module. Most of these are
--   not actually used but exist for benchmarking purposes to determine the
--   fastest filter implementation.
module SDR.FilterInternal
filterHighLevel :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => v b -> Int -> v a -> vm (PrimState m) a -> m ()
filterImperative1 :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => v b -> Int -> v a -> vm (PrimState m) a -> m ()
filterImperative2 :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => v b -> Int -> v a -> vm (PrimState m) a -> m ()
type FilterCRR = CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
type FilterRR = Vector Float -> Int -> Vector Float -> MVector RealWorld Float -> IO ()
type FilterRC = Vector Float -> Int -> Vector (Complex Float) -> MVector RealWorld (Complex Float) -> IO ()
filterFFIR :: FilterCRR -> FilterRR
filterFFIC :: FilterCRR -> FilterRC
filterRR_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCRR :: FilterRR
filterRC_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCRC :: FilterRC
filterSSERR_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCSSERR :: FilterRR
filterSSESymmetricRR_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCSSESymmetricRR :: FilterRR
filterSSERC_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCSSERC :: FilterRC
filterSSERC2_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCSSERC2 :: FilterRC
filterAVXRR_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCAVXRR :: FilterRR
filterAVXSymmetricRR_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCAVXSymmetricRR :: FilterRR
filterAVXRC_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCAVXRC :: FilterRC
filterAVXRC2_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCAVXRC2 :: FilterRC
filterSSESymmetricRC_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCSSESymmetricRC :: FilterRC
filterAVXSymmetricRC_c :: CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
filterCAVXSymmetricRC :: FilterRC
decimateHighLevel :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> v b -> Int -> v a -> vm (PrimState m) a -> m ()
type DecimateCRR = CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
type DecimateRR = Int -> Vector Float -> Int -> Vector Float -> MVector RealWorld Float -> IO ()
type DecimateRC = Int -> Vector Float -> Int -> Vector (Complex Float) -> MVector RealWorld (Complex Float) -> IO ()
decimateFFIR :: DecimateCRR -> DecimateRR
decimateFFIC :: DecimateCRR -> DecimateRC
decimateCRR_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCRR :: DecimateRR
decimateCRC_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCRC :: DecimateRC
decimateSSERR_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCSSERR :: DecimateRR
decimateSSERC_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCSSERC :: DecimateRC
decimateSSERC2_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCSSERC2 :: DecimateRC
decimateAVXRR_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCAVXRR :: DecimateRR
decimateAVXRC_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCAVXRC :: DecimateRC
decimateAVXRC2_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCAVXRC2 :: DecimateRC
decimateSSESymmetricRR_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCSSESymmetricRR :: DecimateRR
decimateAVXSymmetricRR_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCAVXSymmetricRR :: DecimateRR
decimateSSESymmetricRC_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCSSESymmetricRC :: DecimateRC
decimateAVXSymmetricRC_c :: CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
decimateCAVXSymmetricRC :: DecimateRC
resampleHighLevel :: (PrimMonad m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> Int -> v b -> Int -> Int -> v a -> vm (PrimState m) a -> m Int
resample_c :: CInt -> CInt -> CInt -> CInt -> CInt -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
resampleCRR :: Int -> Int -> Int -> Int -> Vector Float -> Vector Float -> MVector RealWorld Float -> IO ()
pad :: a -> Int -> [a] -> [a]
strideList :: Int -> [a] -> [a]
roundUp :: Int -> Int -> Int
data Coeffs
[Coeffs] :: Int -> Int -> [Int] -> [[Float]] -> Coeffs
[numCoeffs] :: Coeffs -> Int
[numGroups] :: Coeffs -> Int
[increments] :: Coeffs -> [Int]
[groups] :: Coeffs -> [[Float]]
prepareCoeffs :: Int -> Int -> Int -> [Float] -> Coeffs
resampleFFIR :: (Ptr CFloat -> Ptr CFloat -> IO CInt) -> Vector Float -> MVector RealWorld Float -> IO Int
type ResampleR = CInt -> CInt -> CInt -> CInt -> Ptr CInt -> Ptr (Ptr CFloat) -> Ptr CFloat -> Ptr CFloat -> IO CInt
mkResampler :: ResampleR -> Int -> Int -> Int -> [Float] -> IO (Int -> Int -> Vector Float -> MVector RealWorld Float -> IO Int)
type ResampleRR = Int -> Int -> [Float] -> IO (Int -> Int -> Vector Float -> MVector RealWorld Float -> IO Int)
resample2_c :: CInt -> CInt -> CInt -> CInt -> Ptr CInt -> Ptr (Ptr CFloat) -> Ptr CFloat -> Ptr CFloat -> IO CInt
resampleCRR2 :: ResampleRR
resampleCSSERR_c :: CInt -> CInt -> CInt -> CInt -> Ptr CInt -> Ptr (Ptr CFloat) -> Ptr CFloat -> Ptr CFloat -> IO CInt
resampleCSSERR :: ResampleRR
resampleAVXRR_c :: CInt -> CInt -> CInt -> CInt -> Ptr CInt -> Ptr (Ptr CFloat) -> Ptr CFloat -> Ptr CFloat -> IO CInt
resampleCAVXRR :: ResampleRR
decimateCrossHighLevel :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> v b -> Int -> v a -> v a -> vm (PrimState m) a -> m ()
filterCrossHighLevel :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => v b -> Int -> v a -> v a -> vm (PrimState m) a -> m ()
resampleCrossHighLevel :: (PrimMonad m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> Int -> v b -> Int -> Int -> v a -> v a -> vm (PrimState m) a -> m Int
c_dcBlocker :: CInt -> CFloat -> CFloat -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> Ptr CFloat -> IO ()
dcBlocker :: Int -> Float -> Float -> Vector Float -> MVector RealWorld Float -> IO (Float, Float)


-- | FIR filtering, decimation and resampling.
--   
--   FIR filters (and decimators, resamplers) work by taking successive dot
--   products between the filter coefficients and the input data at
--   increasing offsets. Sometimes the dot product fits entirely within one
--   input buffer and other times it spans two input buffers (but never
--   more because we assume that the filter length is less than the buffer
--   size).
--   
--   We divide the filtering code by these two cases. Each filter (or
--   decimator, resampler) is described by a data structure such as
--   <a>Filter</a> with two functions, one for filtering within a single
--   buffer and one that crosses buffers.
--   
--   The user must first create one of these data structures using the
--   helper functions and pass this data structure to one of
--   <a>firFilter</a>, <a>firDecimator</a>, or <a>firResampler</a> to
--   create the <a>Pipe</a> that does the filtering. For example:
--   
--   <pre>
--   decimatorStruct   &lt;- fastDecimatorC cpuInfo decimation coeffs
--   let decimatorPipe :: Pipe (Vector (Complex Float)) (Vector (Complex Float)) IO ()
--       decimatorPipe =  firDecimator decimatorStruct outputSize
--   </pre>
--   
--   There are polymorphic Haskell only implementations of filtering,
--   decimation and resampling, for example, <a>haskellFilter</a>. In
--   addition, there are optimised C implementations that use SIMD
--   instructions on x86 machines, such as <a>fastFilterR</a>. These are
--   always specialized to either real or complex numbers. There are also
--   even faster implementations specialized for the case where the filter
--   coefficients are symmetric as in a linear phase filter such as
--   <a>fastFilterSymR</a>.
--   
--   The Haskell implementations are reasonably fast due to the Vector
--   library and GHC's LLVM backend, however, if speed is important you are
--   much better off with the C implementations.
--   
--   In the future we may avoid the cross buffer filtering function by
--   mapping the buffers consecutively in memory as (I believe) GNU Radio
--   does.
--   
--   An extensive benchmark suite exists in the /benchmarks subdirectory of
--   this package.
module SDR.Filter

-- | A <a>Filter</a> contains all of the information needed by the
--   <tt>filterr</tt> function to perform filtering. i.e. it contains the
--   filter coefficients and pointers to the functions to do the actual
--   filtering.
data Filter m v vm a
[Filter] :: Int -> (Int -> v a -> vm (PrimState m) a -> m ()) -> (Int -> v a -> v a -> vm (PrimState m) a -> m ()) -> Filter m v vm a
[numCoeffsF] :: Filter m v vm a -> Int
[filterOne] :: Filter m v vm a -> Int -> v a -> vm (PrimState m) a -> m ()
[filterCross] :: Filter m v vm a -> Int -> v a -> v a -> vm (PrimState m) a -> m ()

-- | A <a>Decimator</a> contains all of the information needed by the
--   <tt>decimate</tt> function to perform decimation i.e. it contains the
--   filter coefficients and pointers to the functions to do the actual
--   decimation.
data Decimator m v vm a
[Decimator] :: Int -> Int -> (Int -> v a -> vm (PrimState m) a -> m ()) -> (Int -> v a -> v a -> vm (PrimState m) a -> m ()) -> Decimator m v vm a
[numCoeffsD] :: Decimator m v vm a -> Int
[decimationD] :: Decimator m v vm a -> Int
[decimateOne] :: Decimator m v vm a -> Int -> v a -> vm (PrimState m) a -> m ()
[decimateCross] :: Decimator m v vm a -> Int -> v a -> v a -> vm (PrimState m) a -> m ()

-- | A <a>Resampler</a> contains all of the information needed by the
--   <tt>resample</tt> function to perform resampling i.e. it contains the
--   filter coefficients and pointers to the functions to do the actual
--   resampling.
data Resampler m v vm a
[Resampler] :: Int -> Int -> Int -> dat -> (dat -> Int -> v a -> vm (PrimState m) a -> m (dat, Int)) -> (dat -> Int -> v a -> v a -> vm (PrimState m) a -> m (dat, Int)) -> Resampler m v vm a
[numCoeffsR] :: Resampler m v vm a -> Int
[decimationR] :: Resampler m v vm a -> Int
[interpolationR] :: Resampler m v vm a -> Int
[startDat] :: Resampler m v vm a -> dat
[resampleOne] :: Resampler m v vm a -> dat -> Int -> v a -> vm (PrimState m) a -> m (dat, Int)
[resampleCross] :: Resampler m v vm a -> dat -> Int -> v a -> v a -> vm (PrimState m) a -> m (dat, Int)

-- | Returns a slow Filter data structure entirely implemented in Haskell
haskellFilter :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => [b] -> IO (Filter m v vm a)

-- | Returns a fast Filter data structure implemented in C. For filtering
--   real data with real coefficients.
fastFilterCR :: [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C using SSE
--   instructions. For filtering real data with real coefficients.
fastFilterSSER :: [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C using AVX
--   instructions. For filtering real data with real coefficients.
fastFilterAVXR :: [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For filtering
--   real data with real coefficients.
fastFilterR :: CPUInfo -> [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C For filtering
--   complex data with real coefficients.
fastFilterCC :: [Float] -> IO (Filter IO Vector MVector (Complex Float))

-- | Returns a fast Filter data structure implemented in C using SSE
--   instructions. For filtering complex data with real coefficients.
fastFilterSSEC :: [Float] -> IO (Filter IO Vector MVector (Complex Float))

-- | Returns a fast Filter data structure implemented in C using AVX
--   instructions. For filtering complex data with real coefficients.
fastFilterAVXC :: [Float] -> IO (Filter IO Vector MVector (Complex Float))

-- | Returns a fast Filter data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For filtering
--   complex data with real coefficients.
fastFilterC :: CPUInfo -> [Float] -> IO (Filter IO Vector MVector (Complex Float))

-- | Returns a fast Filter data structure implemented in C using SSE
--   instructions. For filtering real data with real coefficients. For
--   filters with symmetric coefficients, i.e. 'linear phase'. Coefficient
--   length must be a multiple of 4.
fastFilterSymSSER :: [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C using AVX
--   instructions. For filtering real data with real coefficients. For
--   filters with symmetric coefficients, i.e. 'linear phase'. Coefficient
--   length must be a multiple of 4.
fastFilterSymAVXR :: [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a fast Filter data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For filtering
--   complex data with real coefficients. For filters with symmetric
--   coefficients, i.e. 'linear phase'. Coefficient length must be a
--   multiple of 4.
fastFilterSymR :: CPUInfo -> [Float] -> IO (Filter IO Vector MVector Float)

-- | Returns a slow Decimator data structure entirely implemented in
--   Haskell
haskellDecimator :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> [b] -> IO (Decimator m v vm a)

-- | Returns a fast Decimator data structure implemented in C. For
--   decimating real data with real coefficients.
fastDecimatorCR :: Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C using SSE
--   instructions. For decimating real data with real coefficients.
fastDecimatorSSER :: Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C using AVX
--   instructions. For decimating real data with real coefficients.
fastDecimatorAVXR :: Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For decimating
--   real data with real coefficients.
fastDecimatorR :: CPUInfo -> Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C. For
--   decimating complex data with real coefficients.
fastDecimatorCC :: Int -> [Float] -> IO (Decimator IO Vector MVector (Complex Float))

-- | Returns a fast Decimator data structure implemented in C using SSE
--   instructions. For decimating complex data with real coefficients.
fastDecimatorSSEC :: Int -> [Float] -> IO (Decimator IO Vector MVector (Complex Float))

-- | Returns a fast Decimator data structure implemented in C using AVX
--   instructions. For decimating complex data with real coefficients.
fastDecimatorAVXC :: Int -> [Float] -> IO (Decimator IO Vector MVector (Complex Float))

-- | Returns a fast Decimator data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For decimating
--   complex data with real coefficients.
fastDecimatorC :: CPUInfo -> Int -> [Float] -> IO (Decimator IO Vector MVector (Complex Float))

-- | Returns a fast Decimator data structure implemented in C using SSE
--   instructions. For decimating real data with real coefficients. For
--   decimators with symmetric coefficients, i.e. 'linear phase'.
--   Coefficient length must be a multiple of 4.
fastDecimatorSymSSER :: Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C using AVX
--   instructions. For decimating real data with real coefficients. For
--   decimators with symmetric coefficients, i.e. 'linear phase'.
--   Coefficient length must be a multiple of 4.
fastDecimatorSymAVXR :: Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a fast Decimator data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For decimating
--   real data with real coefficients. For decimators with symmetric
--   coefficients, i.e. 'linear phase'. Coefficient length must be a
--   multiple of 4.
fastDecimatorSymR :: CPUInfo -> Int -> [Float] -> IO (Decimator IO Vector MVector Float)

-- | Returns a slow Resampler data structure entirely implemented in
--   Haskell
haskellResampler :: (PrimMonad m, Functor m, Num a, Mult a b, Vector v a, Vector v b, MVector vm a) => Int -> Int -> [b] -> IO (Resampler m v vm a)

-- | Returns a fast Resampler data structure implemented in C. For
--   filtering real data with real coefficients.
fastResamplerCR :: Int -> Int -> [Float] -> IO (Resampler IO Vector MVector Float)

-- | Returns a fast Resampler data structure implemented in C using SSE
--   instructions. For filtering real data with real coefficients.
fastResamplerSSER :: Int -> Int -> [Float] -> IO (Resampler IO Vector MVector Float)

-- | Returns a fast Resampler data structure implemented in C using AVX
--   instructions. For filtering real data with real coefficients.
fastResamplerAVXR :: Int -> Int -> [Float] -> IO (Resampler IO Vector MVector Float)

-- | Returns a fast Resampler data structure implemented in C using the
--   fastest SIMD instruction set your processor supports. For resampling
--   real data with real coefficients.
fastResamplerR :: CPUInfo -> Int -> Int -> [Float] -> IO (Resampler IO Vector MVector Float)

-- | Create a pipe that performs filtering
firFilter :: (PrimMonad m, Functor m, Vector v a, Num a) => Filter m v (Mutable v) a -> Int -> Pipe (v a) (v a) m ()

-- | Create a pipe that performs decimation
firDecimator :: (PrimMonad m, Functor m, Vector v a, Num a) => Decimator m v (Mutable v) a -> Int -> Pipe (v a) (v a) m ()

-- | Create a pipe that performs resampling
firResampler :: (PrimMonad m, Vector v a, Num a) => Resampler m v (Mutable v) a -> Int -> Pipe (v a) (v a) m ()

-- | A DC blocking filter
dcBlockingFilter :: Pipe (Vector Float) (Vector Float) IO ()


-- | Stream samples from a Realtek RTL2832U based device
module SDR.RTLSDRStream

-- | Returns a producer that streams data from a Realtek RTL2832U based
--   device. You probably want to use <tt>makeComplexBufferVect</tt> to
--   turn it into a list of complex Floats.
sdrStream :: Word32 -> Word32 -> Word32 -> Word32 -> EitherT String IO (Producer (Vector CUChar) IO ())


-- | Pulse Audio Pipes sink
module SDR.Pulse

-- | Returns a consumer that sends all incoming data to pulseaudio. Runs
--   Pulse Audio output writing in a different thread. This is probably
--   what you want as it does not block the entire pipline while the data
--   is being played.
pulseAudioSink :: IO (Consumer (Vector Float) IO ())

-- | Returns a consumer that sends all incoming data to pulseaudio.
doPulse :: IO (Consumer (Vector Float) IO ())
