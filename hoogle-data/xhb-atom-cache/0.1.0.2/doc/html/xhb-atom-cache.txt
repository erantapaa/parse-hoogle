-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Atom cache for XHB
--   
@package xhb-atom-cache
@version 0.1.0.2

module Graphics.XHB.AtomCache
data AtomId
AtomId :: l -> AtomId
class (Eq l, Hashable l, Typeable l) => AtomLike l where toAtom = AtomId fromAtom (AtomId a) = cast a
toAtom :: AtomLike l => l -> AtomId
fromAtom :: AtomLike l => AtomId -> Maybe l
toAtomName :: AtomLike l => l -> AtomName
newtype AtomCacheT m a
AtomCacheT :: StateT AtomCache m a -> AtomCacheT m a
unAtomT :: AtomCacheT m a -> StateT AtomCache m a
class Monad m => AtomCacheCtx m
insertATOM :: (AtomCacheCtx m, AtomLike l) => l -> ATOM -> m ()
lookupATOM :: (AtomCacheCtx m, AtomLike l) => l -> m (Maybe ATOM)
unsafeLookupATOM :: (AtomCacheCtx m, AtomLike l) => l -> m ATOM
lookupAtomId :: AtomCacheCtx m => ATOM -> m (Maybe AtomId)
unsafeLookupAtomId :: AtomCacheCtx m => ATOM -> m AtomId
type AtomName = String
atomName :: AtomId -> AtomName
runAtomCacheT :: Monad m => AtomCacheT m a -> m a

-- | Preseed the atom cache with <a>AtomLike</a>s. Example:
--   
--   <pre>
--   {-# LANGUAGE DeriveDataTypeable #-}
--   
--   import Data.Typeable (Typeable)
--   import Data.Hashable (Hashable(..))
--   import Control.Monad (forM_, void)
--   import Control.Monad.IO.Class (liftIO)
--   import Graphics.XHB (connect)
--   import Graphics.XHB.AtomCache
--   
--   data ATOMS = NET_CLIENT_LIST | NET_NUMBER_OF_DESKTOPS
--       deriving (Eq, Show, Typeable)
--   
--   instance Hashable ATOMS where
--       hashWithSalt s = hashWithSalt s . show
--   
--   instance AtomLike ATOMS where
--       toAtomName a = '_' : show a
--   
--   atoms :: [ATOMS]
--   atoms = [NET_CLIENT_LIST, NET_NUMBER_OF_DESKTOPS]
--   
--   main :: IO ()
--   main = do
--       Just c &lt;- connect
--       void $ runAtomCacheT . seedAtoms c atoms $ do
--           forM_ atoms $ \a -&gt; unsafeLookupATOM a &gt;&gt;= liftIO . print
--   </pre>
seedAtoms :: (AtomLike l, Applicative m, MonadIO m) => Connection -> [l] -> AtomCacheT m a -> AtomCacheT m (Either SomeError a)

-- | Lookup AtomName in cache first, if that fails, try to fetch from the X
--   server and put it into the cache
tryLookupAtom :: (AtomLike l, AtomCacheCtx m, MonadIO m) => Connection -> l -> m (Either SomeError ATOM)
instance [overlap ok] Typeable AtomId
instance [overlap ok] Typeable AtomCacheT
instance [overlap ok] (Monad m, Functor m) => Applicative (AtomCacheT m)
instance [overlap ok] Functor m => Functor (AtomCacheT m)
instance [overlap ok] Monad m => Monad (AtomCacheT m)
instance [overlap ok] MonadIO m => MonadIO (AtomCacheT m)
instance [overlap ok] MonadWriter w m => MonadWriter w (AtomCacheT m)
instance [overlap ok] MonadState s m => MonadState s (AtomCacheT m)
instance [overlap ok] MonadReader r m => MonadReader r (AtomCacheT m)
instance [overlap ok] (AtomCacheCtx m, MonadTrans t, Monad (t m)) => AtomCacheCtx (t m)
instance [overlap ok] MonadError e m => MonadError e (AtomCacheT m)
instance [overlap ok] Monad m => AtomCacheCtx (AtomCacheT m)
instance [overlap ok] MonadTrans AtomCacheT
instance [overlap ok] Hashable AtomId
instance [overlap ok] Eq AtomId
instance [overlap ok] Hashable ATOM
