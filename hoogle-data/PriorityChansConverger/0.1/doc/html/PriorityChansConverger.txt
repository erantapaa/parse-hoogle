-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Read single output from an array of inputs - channels with priorities
--   
--   Abbreviation for the <tt>PriorityChansConverger</tt> is PCC.
--   
--   Based on <tt>STM.TChan</tt>, extended with capacity control. Wrapped
--   into IO version is also available.
--   
--   When user reads from the PCC, the choice is made - from which channel
--   to read. System selects a nonempty channel, whose (CurrentPriority,
--   StartPriority) tuple is max. The side effect of the channel selection
--   is it's <i>CurrentPriority</i> decrease by one, if it's value becomes
--   less than one, then the <i>CurrentPriority</i> is set to
--   <i>StartPriority</i>.
--   
--   For the main API interface:
--   
--   <pre>
--   import Control.Concurrent.PriorityChansConverger
--   </pre>
--   
--   The realization probably isn't very fast and isn't good at memory
--   economy, since it uses fresh high level primitive - STM. It wasn't
--   intended to be used with millions of channels. But it's max throughput
--   comparing to the ordinary <tt>Chan</tt> throughput is to be estimated
--   (will do it in some future version).
@package PriorityChansConverger
@version 0.1

module Control.Concurrent.STM.TChan.ExtsCommons

-- | Bigger than <tt>Int</tt> might not work, because some list functions
--   are used, that consume <tt>Int</tt>
type ChanContentAmountMeasure = Int
type ChanLoad = ChanContentAmountMeasure
type ChanCapacity = ChanContentAmountMeasure
type PermitToBlock = Bool
type WriteSucceeded = Bool
type TakeElementOutShouldWe = Bool

module Control.Concurrent.PriorityChansConverger.Commons
type StartPriority = ChanContentAmountMeasure
type CurrentPriority = StartPriority
type PCC_ContainsGivenSpecification = Bool
type NothingElseIsInStruct = Bool
type InterruptShouldWe = Bool
data FailureReasonWPCC
BadKey_FRWPCC :: FailureReasonWPCC
ChanFull_FRWPCC :: FailureReasonWPCC
instance Show FailureReasonWPCC


-- | <pre>
--   <a>TChanL</a> = <a>TChan</a> + <a>TVar</a> <a>ChanLoad</a>
--   </pre>
module Control.Concurrent.STM.TChan.TChanL_
data TChanL a
TChanL :: TChan a -> TVar ChanLoad -> TChanL a
tclChan :: TChanL a -> TChan a
tclLoad :: TChanL a -> TVar ChanLoad
chanLoad :: TChanL a -> STM ChanLoad
newTChanL :: STM (TChanL a)
newTChanL_IO :: IO (TChanL a)
writeTChanL :: TChanL a -> a -> STM ()
readTChanL :: TChanL a -> STM a
isEmptyTChanL :: TChanL a -> STM Bool
tryReadTChanL :: TChanL a -> STM (Maybe a)
getTChanLContents :: TChanL a -> STM [a]
writeList2TChanL :: TChanL a -> [a] -> STM ()
filterOutTChanLElements :: (a -> TakeElementOutShouldWe) -> TChanL a -> STM [a]
viewChanLContent :: TChanL a -> STM [a]

module Control.Concurrent.STM.TChan.TChanL


-- | <pre>
--   <a>TChanL</a> = <a>TChan</a> + <a>TVar</a> <a>ChanLoad</a>
--   </pre>
--   
--   <pre>
--   <a>TChanB</a> = <a>TChanL</a> + <a>TVar</a> <a>ChanCapacity</a>
--   </pre>
module Control.Concurrent.STM.TChan.TChanB_
data TChanB a
TChanB :: TChanL a -> TVar ChanCapacity -> TChanB a
tcbChanL :: TChanB a -> TChanL a
tcbCapacity :: TChanB a -> TVar ChanCapacity
chanCapacity :: TChanB a -> STM ChanCapacity
changeChanCapacity :: ChanCapacity -> TChanB a -> STM ()
chanLoad :: TChanB a -> STM ChanCapacity
newTChanB :: ChanCapacity -> STM (TChanB a)
newTChanB_IO :: ChanCapacity -> IO (TChanB a)

-- | The "elastic-" prefix stands for the opportunity to regulate with
--   option <a>PermitToBlock</a>
elasticWriteTChanB :: PermitToBlock -> TChanB a -> a -> STM WriteSucceeded

-- | Wrapper around <a>elasticWriteTChanB</a>: <tt>writeTChanB tchb a =
--   return () &lt;&lt; elasticWriteTChanB True tchb a</tt>
writeTChanB :: TChanB a -> a -> STM ()
readTChanB :: TChanB a -> STM a
isEmptyTChanB :: TChanB a -> STM Bool

-- | <pre>
--   freeSpace = <a>chanCapacity</a> - <a>chanLoad</a>
--   </pre>
freeSpaceInTChanB :: TChanB a -> STM ChanContentAmountMeasure
tryReadTChanB :: TChanB a -> STM (Maybe a)

-- | Wrapper around <a>elasticWriteTChanB</a>: <tt>tryWriteTChanB =
--   elasticWriteTChanB False</tt>
tryWriteTChanB :: TChanB a -> a -> STM Bool

-- | Take everything from channel, and leave it empty.
getTChanBContents :: TChanB a -> STM [a]

-- | This procedure is highly uneffective and is dangerous, when
--   <tt><a>PermitToBlock</a></tt> is on. Since it won't complete unless
--   there is enough free space in the channnel. Even the part of input
--   that fits won't commit to get into the channel. If capacity isn't
--   enough, it won't ever commit, unless the capacity is made bigger.
elacticWriteList2TChanB :: PermitToBlock -> TChanB a -> [a] -> STM [a]

-- | Just filter out elements. Is abstracted over implementation, so
--   doesn't suffer from possible inconsistency between capacity and load
--   (when capacity &lt; load).
filterOutTChanBElements :: (a -> TakeElementOutShouldWe) -> TChanB a -> STM [a]
viewChanBContent :: TChanB a -> STM [a]

module Control.Concurrent.STM.TChan.TChanB


-- | A bottleneck for UI from multiple threads. Prevents mixing of output
--   messages. Also makes possible a primitive form of input. By mastering
--   <tt><a>cuisUIInput_E</a></tt> and <tt><a>cuisUIOutput_E</a></tt> it's
--   possible to construct <tt><a>ConcurrentUISupport</a></tt> with
--   different than UI I/O.
module Control.Concurrent.ConcurrentUISupport
type AskerID = String
type ReadFromConsoleStr = String
type ThreadFinisher = IO ()
data CUISCommand
NewPage_CUISC :: CUISCommand
PlusLine_CUISC :: CUISCommand
PutStrLn_CUISC :: String -> CUISCommand
ReadStr_CUISC :: AskerID -> CUISCommand
data ConcurrentUISupport
ConcurrentUISupport :: TChan [CUISCommand] -> TVar (Map AskerID (TChan ReadFromConsoleStr)) -> ThreadFinisher -> STM Bool -> IO () -> Either (STM String) (IO String) -> Either (String -> STM ()) (String -> IO ()) -> Maybe (IO ()) -> Maybe Int -> ConcurrentUISupport

-- | Supported threads are welcome to write their commands here. It is
--   recommended not to use this channel directly - use
--   <tt><a>cuisWrite</a></tt>, <tt><a>cuisReadLn</a></tt> and other
--   mediators instead.
cuisInputTChan :: ConcurrentUISupport -> TChan [CUISCommand]

-- | Map of feedback chans leading to threads, that issue the
--   <tt><a>ReadStr_CUISC</a></tt> commands.
cuisOutputChans :: ConcurrentUISupport -> TVar (Map AskerID (TChan ReadFromConsoleStr))

-- | Call this, when you want to finish supporter thread.
cuisFinish :: ConcurrentUISupport -> ThreadFinisher

-- | Was <tt><a>cuisFinish</a></tt> called?
cuisSupporterStopCheck :: ConcurrentUISupport -> STM Bool

-- | What to do, when supporter thread finishes?
cuisFinalizer :: ConcurrentUISupport -> IO ()

-- | How to input, when <tt><a>ReadStr_CUISC</a></tt> command comes?
cuisUIInput_E :: ConcurrentUISupport -> Either (STM String) (IO String)

-- | How to output, when <tt><a>PutStrLn_CUISC</a></tt> command comes?
cuisUIOutput_E :: ConcurrentUISupport -> Either (String -> STM ()) (String -> IO ())

-- | If set, then call it on each <tt><a>NewPage_CUISC</a></tt> command.
cuisPressAnyKey_uiCmd :: ConcurrentUISupport -> Maybe (IO ())

-- | For <tt>(Just i)</tt>, if count of printed lines is &gt; <tt>i</tt>,
--   then automatically issue <tt><a>NewPage_CUISC</a></tt> command and set
--   lines counter to 0.
cuisPressAnyKey_linesCountCond :: ConcurrentUISupport -> Maybe Int
defaultConcurrentUISupportIO :: IO ConcurrentUISupport

-- | UI in console + log to file.
defaultConcurrentUISupportIO_logInFile :: FilePath -> IOMode -> IO ConcurrentUISupport

-- | Whatever <tt><a>cuisUIInput_E</a></tt> is - <tt>Left</tt> or
--   <tt>Right</tt> - flattern it into IO.
cuisUIInput :: ConcurrentUISupport -> IO String

-- | Whatever <tt><a>cuisUIOutput_E</a></tt> is - <tt>Left</tt> or
--   <tt>Right</tt> - flattern it into IO.
cuisUIOutput :: ConcurrentUISupport -> String -> IO ()

-- | Not to be confised with <tt><a>cuisUIInput</a></tt>, which interfaces
--   with user. This <i>input</i> interfaces with threads, that makes use
--   of it.
--   
--   A wrapper around <tt><a>cuisInputTChan</a></tt>.
cuisInput :: ConcurrentUISupport -> [CUISCommand] -> IO ()
acquirePutStr_fromCmdsList :: [CUISCommand] -> Maybe CUISCommand
acquireReadStr_fromCmdsList :: [CUISCommand] -> Maybe CUISCommand
runConcurrentUISupport :: ConcurrentUISupport -> IO ()
cuisWriteSTM :: ConcurrentUISupport -> String -> STM ()
cuisWrite :: ConcurrentUISupport -> String -> IO ()
cuisNewPage :: ConcurrentUISupport -> IO ()
cuisReadLn :: ConcurrentUISupport -> AskerID -> IO ReadFromConsoleStr
reportExceptionIfAny :: (String -> IO ()) -> String -> IO a -> IO a
printExceptionIfAny :: String -> IO a -> IO a
reportExceptionIfAny_2 :: ConcurrentUISupport -> String -> IO a -> IO a
reportExceptionIfAnySTM :: (String -> STM ()) -> String -> STM a -> STM a
reportExceptionIfAnySTM_2 :: ConcurrentUISupport -> String -> STM a -> STM a
instance Eq CUISCommand


-- | Abbreviation for the <tt>PriorityChansConverger</tt> is PCC.
--   
--   Based on <tt>STM.TChan</tt>s, extended with capacity control (see
--   <tt><a>Control.Concurrent.STM.TChan.TChanB</a></tt>).
--   
--   When user reads from the PCC, the choice is made - from which channel
--   to read. System selects a nonempty channel, whose /(CurrentPriority,
--   StartPriority)/ tuple is max. The side effect of the channel selection
--   is it's <i>CurrentPriority</i> decrease by one, if it's value becomes
--   less than one, then the <i>CurrentPriority</i> is set to
--   <i>StartPriority</i>.
module Control.Concurrent.PriorityChansConverger.PriorityChansConvergerSTM

-- | Decrease <tt><a>CurrentPriority</a></tt> by one, if it's value becomes
--   less than one, then the <tt><a>CurrentPriority</a></tt> is set to
--   <tt><a>StartPriority</a></tt>.
decPriority :: (CurrentPriority, StartPriority) -> (CurrentPriority, StartPriority)
data Ord k => PriorityChansConvergerSTM k e
PriorityChansConvergerSTM :: Map k (PriorityChan k e) -> TVar (Map (CurrentPriority, StartPriority) [PriorityChan k e]) -> TVar (Map (CurrentPriority, StartPriority) [PriorityChan k e]) -> Maybe ConcurrentUISupport -> PriorityChansConvergerSTM k e

-- | All channels. Convenient to use for input. Map keys ==
--   <tt><a>pcID</a></tt> of elements.
pccStruct :: PriorityChansConvergerSTM k e -> Map k (PriorityChan k e)

-- | Empty channels. Map keys == <tt><a>pcPriorityTV</a></tt> of elements.
pccEmpties :: PriorityChansConvergerSTM k e -> TVar (Map (CurrentPriority, StartPriority) [PriorityChan k e])

-- | Nonempty channels. Map keys == <tt><a>pcPriorityTV</a></tt> of
--   elements. Convenient for taking output.
pccNonEmpties :: PriorityChansConvergerSTM k e -> TVar (Map (CurrentPriority, StartPriority) [PriorityChan k e])

-- | For testing and debugging purposes.
pccConcurrentUISupport :: PriorityChansConvergerSTM k e -> Maybe ConcurrentUISupport

-- | PriorityChan = ID + <tt><a>TChanB</a></tt> + <tt><a>TVar</a>
--   (<a>CurrentPriority</a>, <a>StartPriority</a>)</tt>
data PriorityChan k e
PriorityChan :: k -> TChanB e -> TVar (CurrentPriority, StartPriority) -> PriorityChan k e
pcID :: PriorityChan k e -> k
pcChanB :: PriorityChan k e -> TChanB e
pcPriorityTV :: PriorityChan k e -> TVar (CurrentPriority, StartPriority)

-- | <pre>
--   <a>pcLoad</a> = <a>chanLoad</a> . <a>pcChanB</a>
--   </pre>
pcLoad :: PriorityChan k e -> STM ChanLoad

-- | <pre>
--   <a>pcCapacity</a> = <a>chanCapacity</a> . <a>pcChanB</a>
--   </pre>
pcCapacity :: PriorityChan k e -> STM ChanCapacity

-- | <pre>
--   <a>pcIsEmpty</a> = <a>isEmptyTChanB</a> . <a>pcChanB</a>
--   </pre>
pcIsEmpty :: PriorityChan k e -> STM Bool

-- | <pre>
--   <a>pcPriority</a> = <a>readTVar</a> . <a>pcPriorityTV</a>
--   </pre>
pcPriority :: PriorityChan k e -> STM (CurrentPriority, StartPriority)

-- | <pre>
--   <a>pcStartPriority</a> pc = snd <a>liftM</a> <a>pcPriority</a> pc
--   </pre>
pcStartPriority :: PriorityChan k e -> STM StartPriority

-- | Constructor.
newPriorityChan :: k -> StartPriority -> ChanCapacity -> STM (PriorityChan k e)

-- | PCC constructor with an option to enable utility
--   <tt><a>ConcurrentUISupport</a></tt> (which is useful for debugging).
newPriorityChansConvergerSTM_wCUIS :: Ord k => Maybe ConcurrentUISupport -> Map k (StartPriority, ChanCapacity) -> STM (PriorityChansConvergerSTM k e)

-- | PCC constructor. <tt><a>ConcurrentUISupport</a></tt> is off.
--   
--   <pre>
--   newPriorityChansConvergerSTM = <a>newPriorityChansConvergerSTM_wCUIS</a> Nothing
--   </pre>
newPriorityChansConvergerSTM :: Ord k => Map k (StartPriority, ChanCapacity) -> STM (PriorityChansConvergerSTM k e)

-- | Checks:
--   
--   <ul>
--   <li>If PCC contains all channels, constructable by given
--   specification.</li>
--   <li>If PCC contains nothing else, than mentioned in the given
--   specification.</li>
--   </ul>
isOfStructPCC_STM :: Ord k => Map k (StartPriority, ChanCapacity) -> PriorityChansConvergerSTM k e -> STM (PCC_ContainsGivenSpecification, NothingElseIsInStruct)

-- | Updates PCC with given specification. New channels may be added or
--   existing alerted. But no operation for removing channels.
mutatePCC_STM :: Ord k => Map k (StartPriority, ChanCapacity) -> PriorityChansConvergerSTM k e -> STM (PriorityChansConvergerSTM k e)

-- | If blocking is on, then blocks, when trying to write to a full channel
--   (where's no free space).
writeInPCC_STM :: Ord k => PermitToBlock -> k -> e -> PriorityChansConvergerSTM k e -> STM (Maybe FailureReasonWPCC)

-- | Wrapper around <tt>(<a>writeInPCC_STM</a> True)</tt> - blocking write.
--   Uses <a>interruptableSTM</a>. If returns Left, then transaction ended
--   with interrupting condition.
interruptableWriteInPCC_STM :: Ord k => STM InterruptShouldWe -> k -> e -> PriorityChansConvergerSTM k e -> STM (Either () (Maybe FailureReasonWPCC))

-- | If <tt><a>PermitToBlock</a></tt> is <tt>True</tt>, then never returns
--   <tt>Nothing</tt>.
readFromPCC_STM :: Ord k => PermitToBlock -> PriorityChansConvergerSTM k e -> STM (Maybe (k, e))

-- | Wrapper around <tt>(<a>readFromPCC_STM</a> True)</tt> - blocking read.
--   Uses <a>interruptableSTM</a>. If returns Left, then transaction ended
--   with interrupting condition.
interruptableReadFromPCC_STM :: Ord k => STM InterruptShouldWe -> PriorityChansConvergerSTM k e -> STM (Either () (k, e))

-- | Composition of <tt><a>readFromPCC_STM</a></tt>s. Lazy (doublecheck
--   that).
flushPCC2List_STM :: Ord k => PriorityChansConvergerSTM k e -> STM [(k, e)]

-- | Strict. Should be a bit faster than <tt><a>flushPCC2List_STM</a></tt>.
flushPCC2List_STM' :: Ord k => PriorityChansConvergerSTM k e -> STM [(k, e)]

-- | Strict. This is a fast flush, it doesn't deal with priorities.
fastFlushPCC2List_STM' :: Ord k => PriorityChansConvergerSTM k e -> STM [(k, e)]
isEmptyPCC_STM :: Ord k => PriorityChansConvergerSTM k e -> STM Bool

-- | Free space in referenced channel = Capacity - Load.
freeSpaceInPCCInput_STM :: Ord k => PriorityChansConvergerSTM k e -> k -> STM (Maybe ChanContentAmountMeasure)

-- | Strict.
--   
--   Take everything, applu filter, return what's left in the PCC, return
--   what's taken out.
filterOutPCCElements_STM' :: Ord k => PriorityChansConvergerSTM k e -> (e -> TakeElementOutShouldWe) -> STM [(k, e)]

-- | Used wrapped in <tt>(unsafePerformIO . atomically)</tt> in the
--   definition of show instance.
showPCC_STM :: (Ord k, Show k, Show e) => PriorityChansConvergerSTM k e -> STM String

-- | Used wrapped in <tt>(unsafePerformIO . atomically)</tt> in the
--   definition of show instance.
showPC_STM :: (Show e, Show k) => PriorityChan k e -> STM String

-- | For <tt>interruptableSTM interrupter subj</tt>, when
--   <tt>interrupter</tt> returns <tt>True</tt>, the transaction returns
--   <tt>Nothing</tt>. Else the result of <tt>subj</tt> is waited and
--   returned wrapped into <tt>Just</tt>.
interruptableSTM :: STM InterruptShouldWe -> STM a -> STM (Maybe a)


-- | This module wraps STM PCC with IO. Some locks are added to balance
--   heavyweight transactions, to reduce "waste efforts".
module Control.Concurrent.PriorityChansConverger.PriorityChansConverger
data PCC_Lock
PCC_Lock :: PCC_Lock
PCC_IOInterruptableRead :: PCC_Lock
PCC_IOInterruptableWrite :: PCC_Lock

-- | Wrapper around <tt><a>PriorityChansConvergerSTM</a></tt>. Added locks.
--   <tt><a>Show</a></tt> instance is defined using
--   <tt><tt>unsafePerformIO</tt></tt>.
data Ord k => PriorityChansConverger k e
PriorityChansConverger :: PriorityChansConvergerSTM k e -> Map PCC_Lock (MVar ()) -> PriorityChansConverger k e
pccSTM :: PriorityChansConverger k e -> PriorityChansConvergerSTM k e
pccLocks :: PriorityChansConverger k e -> Map PCC_Lock (MVar ())
reportIfPossible :: Ord k => PriorityChansConverger k e -> String -> IO ()
maybeObserveExceptions :: Ord k => PriorityChansConverger k e -> FunctionName -> IO a -> IO a

-- | Wrapper around <tt><a>newPriorityChansConverger_wCUIS</a></tt>
--   constructor.
--   
--   <pre>
--   newPriorityChansConverger = <a>newPriorityChansConverger_wCUIS</a> Nothing
--   </pre>
newPriorityChansConverger :: Ord k => Map k (StartPriority, ChanCapacity) -> IO (PriorityChansConverger k e)

-- | Wrapper around <tt><a>newPriorityChansConvergerSTM_wCUIS</a></tt>
--   constructor. With an option to enable utility
--   <tt><a>ConcurrentUISupport</a></tt> (which is useful for debugging)
newPriorityChansConverger_wCUIS :: Ord k => Maybe ConcurrentUISupport -> Map k (StartPriority, ChanCapacity) -> IO (PriorityChansConverger k e)
type FunctionName = String
type LockUserName = FunctionName

-- | Sort the locks and lock them.
--   
--   WARNING !!! Asynchronous exceptions may cause loss of locks!
lockPCC :: Ord k => LockUserName -> [PCC_Lock] -> PriorityChansConverger k e -> IO ()

-- | Reverse sort the locks and unlock them.
--   
--   WARNING !!! Asynchronous exceptions may cause loss of locks!
unlockPCC :: Ord k => LockUserName -> [PCC_Lock] -> PriorityChansConverger k e -> IO ()

-- | Locking IO action wrapper.
--   
--   WARNING !!! Asynchronous exceptions may cause loss of locks!
withLockedDo :: Ord k => LockUserName -> [PCC_Lock] -> PriorityChansConverger k e -> IO a -> IO a

-- | Wrapper around <tt><a>isOfStructPCC_STM</a></tt>. Used locks: none.
isOfStructPCC :: Ord k => Map k (StartPriority, ChanCapacity) -> PriorityChansConverger k e -> IO (PCC_ContainsGivenSpecification, NothingElseIsInStruct)

-- | Wrapper around <tt><a>mutatePCC_STM</a></tt>. Used locks:
--   <tt>[<a>PCC_Lock</a>]</tt>
mutatePCC :: Ord k => Map k (StartPriority, ChanCapacity) -> PriorityChansConverger k e -> IO (PriorityChansConverger k e)

-- | Wrapper around <tt><a>writeInPCC_STM</a></tt>. Used locks: if
--   blocking, then <tt>[]</tt> else <tt>[<a>PCC_Lock</a>]</tt>.
--   
--   If blocking is enabled, may block, when there is no free space in
--   <tt><a>PriorityChan</a></tt>.
writeInPCC :: Ord k => PermitToBlock -> k -> e -> PriorityChansConverger k e -> IO (Maybe FailureReasonWPCC)

-- | Wrapper around <tt><a>interruptableWriteInPCC_STM</a></tt>. Used
--   locks: <tt>[]</tt>
--   
--   Blocking write.
--   
--   Do not put the control of the <tt><a>STM</a>
--   <a>InterruptShouldWe</a></tt> under <tt><a>PCC_Lock</a></tt>. Keep
--   there <tt>False</tt>, if you don't want to get <tt>Left ()</tt> in
--   return. Put there <tt>True</tt>, whenever you want to stop waiting.
stmInterruptableWriteInPCC :: Ord k => STM InterruptShouldWe -> k -> e -> PriorityChansConverger k e -> IO (Either () (Maybe FailureReasonWPCC))

-- | Wrapper around <tt><a>stmInterruptableWriteInPCC</a></tt>. Used locks:
--   <tt>[<a>PCC_IOInterruptableWrite</a>]</tt>
--   
--   Blocking read.
--   
--   Creates a <tt><a>TVar</a> Bool</tt> to control the interruptability of
--   write operation. Spawns additional thread, which cyclicly reads given
--   <tt>Chan</tt> and checks, if it signals terminating condition - if so,
--   then using <a>interrupter</a> <tt>TVar</tt> stops trying to write in
--   PCC. Temporary thread gets terminated at the end.
interruptableWriteInPCC :: Ord k => (Chan a, a -> InterruptShouldWe) -> k -> e -> PriorityChansConverger k e -> IO (Either () (Maybe FailureReasonWPCC))

-- | Wrapper around <tt><a>readFromPCC_STM</a></tt>. Used locks: if
--   blocking, then <tt>[]</tt> else <tt>[<a>PCC_Lock</a>]</tt>.
readFromPCC :: Ord k => PermitToBlock -> PriorityChansConverger k e -> IO (Maybe (k, e))

-- | Wrapper around <tt><a>interruptableReadFromPCC_STM</a></tt>. Used
--   locks: <tt>[]</tt>
--   
--   Blocking read.
stmInterruptableReadFromPCC :: Ord k => STM InterruptShouldWe -> PriorityChansConverger k e -> IO (Either () (k, e))

-- | Wrapper around <tt><a>stmInterruptableReadFromPCC</a></tt>. Used
--   locks: <tt>[<a>PCC_IOInterruptableRead</a>]</tt>
--   
--   Blocking read.
--   
--   Creates a <tt><a>TVar</a> Bool</tt> to control the interruptability of
--   read operation. Spawns additional thread, which cyclicly reads given
--   <tt>Chan</tt> and checks, if it signals terminating condition - if so,
--   then using <a>interrupter</a> <tt>TVar</tt> stops trying to write in
--   PCC. Temporary thread gets terminated at the end.
interruptableReadFromPCC :: Ord k => (Chan a, a -> InterruptShouldWe) -> PriorityChansConverger k e -> IO (Either () (k, e))

-- | Wrapper around <tt><a>flushPCC2List_STM</a></tt>. Used locks:
--   <tt>[<a>PCC_Lock</a>]</tt>
--   
--   Lazy (doublecheck that).
flushPCC2List :: Ord k => PriorityChansConverger k e -> IO [(k, e)]

-- | Wrapper around <tt>flushPCC2List_STM'</tt> (see
--   <a>Control.Concurrent.PriorityChansConverger.PriorityChansConverger</a>).
--   Used locks: <tt>[<a>PCC_Lock</a>]</tt>
--   
--   Strict. Should be a bit faster than <tt><a>flushPCC2List</a></tt>.
flushPCC2List' :: Ord k => PriorityChansConverger k e -> IO [(k, e)]

-- | Wrapper around <tt>fastFlushPCC2List_STM'</tt> (see
--   <a>Control.Concurrent.PriorityChansConverger.PriorityChansConverger</a>).
--   Used locks: <tt>[<a>PCC_Lock</a>]</tt>
--   
--   Strict. This is a fast flush, it doesn't deal with priorities.
fastFlushPCC2List' :: Ord k => PriorityChansConverger k e -> IO [(k, e)]

-- | Wrapper around <tt><a>isEmptyPCC_STM</a></tt>. Used locks: none
isEmptyPCC :: Ord k => PriorityChansConverger k e -> IO Bool

-- | Wrapper around <tt><a>freeSpaceInPCCInput_STM</a></tt>. Used locks:
--   none
freeSpaceInPCCInput :: Ord k => PriorityChansConverger k e -> k -> IO (Maybe ChanContentAmountMeasure)

-- | Wrapper around <tt>filterOutPCCElements_STM'</tt> (see
--   <a>Control.Concurrent.PriorityChansConverger.PriorityChansConverger</a>).
--   Used locks: <tt>[<a>PCC_Lock</a>]</tt>
--   
--   Strict.
--   
--   Take everything, applu filter, return what's left in the PCC, return
--   what's taken out.
filterOutPCCElements' :: Ord k => PriorityChansConverger k e -> (e -> TakeElementOutShouldWe) -> IO [(k, e)]

-- | Wrapper around <tt><a>showPCC</a></tt>. Used locks: none
showPCC :: (Ord k, Show k, Show e) => PriorityChansConverger k e -> IO String
instance Eq PCC_Lock
instance Ord PCC_Lock
instance Show PCC_Lock

module Control.Concurrent.PriorityChansConverger
